(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* ::Input::Initialization:: *)
xAct`FieldsX`$xTensorVersionExpected={"1.1.4",{2020,2,16}};
xAct`FieldsX`$Version={"1.1.4",{2021,8,26}};


(* ::Input::Initialization:: *)
(* FieldsX: An xTension to perform field-theoretic computations. *)

(* Copyright (C) 2019-2021 Markus B. Fr\[ODoubleDot]b *)

(* This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License,or (at your option) any later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place-Suite 330, Boston, MA 02111-1307, USA.
*)


(* ::Input::Initialization:: *)
(* :Title: FieldsX *)

(* :Author: Markus B. Fr\[ODoubleDot]b *)

(* :Summary: Perform field-theoretic computations. *)

(* :Brief Discussion: FieldsX is a package to perform calculations in classical field theory, including spinors. It includes functions to work with inner bundles, invariant tensors on Lie algebras, \[Gamma] matrices, Fierz identities, decomposition of spinor products into irreducibles, arbitrary gradings, left and right variational derivatives, the BRST-BV differential and filtrations. It extends the SymmetryOf and FindAllContractions functions to work with multiple bundles, and defines functions to generate a list of monomials with arbitrary constraints, both in standard tensor notation or the pseudo index-free notation of the xTras package. Lastly, it includes functions to calculate (relative) cohomologies for a nilpotent operator such as the BRST-BV differential. FieldsX uses the Multisets package (c) 2011 David Bevan under the Wolfram Library Archive License. *)
  
(* :Context: xAct`FieldsX` *)

(* :Package Version: 1.1.4 *)

(* :Copyright: Markus B. Fr\[ODoubleDot]b (2019-2021) *)

(* :History: 1.0   Initial release.
             1.0.1 Compatibility with Spinors package, fixed some leaking symbols
             1.0.2 Fixed warning messages
             1.0.3 BRST operator only commutes with PD (not general CovD), optimized JoinGammaMatrices and \[Gamma]* handling,
                   fixed EpsilonGammaReduce for partially contracted \[Gamma] matrices, added dual \[Gamma] matrices
             1.1   Added frame fields and spin connections and the corresponding utility functions and perturbations,
                   fixed UndefSpinStructure to also remove perturbations of \[Gamma] matrices
             1.1.1 Fixed some issues in TensorCount and printing of \[Gamma] matrices
             1.1.2 Added ChangeCurvature[\[Omega],PD], fixed tracelessness of irreducible tensors
             1.1.3 Fixed Parity of undeclared differential, fixed unevaluated constant expressions in TensorCount
             1.1.4 Fixed errors in FindAllContractions and TimesToCenterDot, simplified IrreducibleSpinDecompose, extended TensorCount and FierzExpand
 *)

(* :Keywords: TODO *)

(* :Source: FieldsX.nb *)

(* :Warning: Not every function has been tested throughly. Some functions may take very long to complete or run out of memory, such as the computation of cohomologies. *)

(* :Mathematica Version: 8.0 and later *)

(* :Limitations: Only Majorana and Dirac spinors are defined.
                 Conventions are the ones of the Supergravity book by Freedman and van Proeyen.
                 The Majorana flip relations are only valid for Lorentzian signature.
                 The decomposition into irreducible spin tensors only works in 4 dimensions and for spinors with at most one inner bundle index.
 *)
	
(* :Acknowledgements: *)


(* ::Input::Initialization:: *)
(****************************** 1.3 Begin package ******************************)


(* ::Input::Initialization:: *)
If[Unevaluated[xAct`xCore`Private`$LastPackage]===xAct`xCore`Private`$LastPackage,xAct`xCore`Private`$LastPackage="xAct`FieldsX`"];


(* ::Input::Initialization:: *)
BeginPackage["xAct`FieldsX`",{"xAct`xTensor`","xAct`xPerm`","xAct`xCore`","xAct`xPert`","xAct`xTras`","xAct`TexAct`"}]


(* ::Input::Initialization:: *)
Unprotect@@Map[StringJoin["xAct`FieldsX`",#]&,DeleteCases[Names["xAct`FieldsX`*"],"$xTensorVersionExpected"|"$Version"]];
ClearAll@@Map[StringJoin["xAct`FieldsX`",#]&,DeleteCases[Names["xAct`FieldsX`*"],"$xTensorVersionExpected"|"$Version"]];
Unprotect["xAct`FieldsX`Private`*"];
ClearAll["xAct`FieldsX`Private`*"];


(* ::Input::Initialization:: *)
If[Not@OrderedQ@Map[Last,{$xTensorVersionExpected,xAct`xTensor`$Version}],Throw@Message[General::versions,"xTensor",xAct`xTensor`$Version,$xTensorVersionExpected]]


(* ::Input::Initialization:: *)
Print[xAct`xCore`Private`bars]
Print["Package xAct`FieldsX` version ",$Version[[1]],", ",$Version[[2]]];
Print["Copyright \[Copyright] 2019-2021 Markus B. Fr\[ODoubleDot]b under the GNU General Public License."];
Print["FieldsX uses the Multisets package \[Copyright] 2011 David Bevan under the Wolfram Library Archive License."];


(* ::Input::Initialization:: *)
Off[General::shdw]
xAct`FieldsX`Disclaimer[]:=Print["These are points 11 and 12 of the General Public License:\n\nBECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW. EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM `AS IS\.b4 WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU. SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION.\n\nIN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES."]
On[General::shdw]


(* ::Input::Initialization:: *)
If[xAct`xCore`Private`$LastPackage==="xAct`FieldsX`",
Unset[xAct`xCore`Private`$LastPackage];
Print[xAct`xCore`Private`bars];
Print["These packages come with ABSOLUTELY NO WARRANTY; for details type Disclaimer[]. This is free software, and you are welcome to redistribute it under certain conditions. See the General Public License for details."];
Print[xAct`xCore`Private`bars]]


(* ::Input::Initialization:: *)
(****************************** 1.4 Non-standard setup ******************************)


(* ::Input::Initialization:: *)
ReportSet[$CovDFormat,"Prefix"];
ReportSetOption[DefCovD,CurvatureRelations->True];
ReportSet[$CommuteCovDsOnScalars,True];
ReportSet[$PrePrint,ScreenDollarIndices];
Off[TensorRank::rect];
(*Needs["Multisets`"];*)
DeclarePackage["Multisets`","Multisets"];


(* ::Input::Initialization:: *)
Begin["`Private`"];
usagerow[l_List]:=ToString[Row[l,""],StandardForm];
usagerows[arg:_List..]:=StringRiffle[Map[usagerow,{arg}],"\n"];
it[s_]:=Style[s,Italic];
PrependTo[$ContextPath,End[]];


(* ::Input::Initialization:: *)
Begin["`Private`"];
SpinorsPkgLoaded=MemberQ[$Packages,"xAct`Spinors`"];
SpinorsKeepDefs=If[ValueQ@Unevaluated[Global`$Keep2CompDefs],TrueQ[Global`$Keep2CompDefs],False];


(* ::Input::Initialization:: *)
(* Spinors functions are renamed if needed *)
If[SpinorsPkgLoaded&&(!SpinorsKeepDefs),
xAct`Spinors`Def2CompSpinStructure::usage=StringReplace[xAct`Spinors`DefSpinStructure::usage,"DefSpinStructure"->"Def2CompSpinStructure"];
xAct`Spinors`DefSpinStructure::usage=.;
xAct`Spinors`Undef2CompSpinStructure::usage=StringReplace[xAct`Spinors`UndefSpinStructure::usage,"UndefSpinStructure"->"Undef2CompSpinStructure"];
xAct`Spinors`UndefSpinStructure::usage=.;
xAct`Spinors`SpinorPrefix::usage=StringReplace[xAct`Spinors`SpinorPrefix::usage,"DefSpinStructure"->"Def2CompSpinStructure"];
xAct`Spinors`SpinorMark::usage=StringReplace[xAct`Spinors`SpinorMark::usage,"DefSpinStructure"->"Def2CompSpinStructure"];

xAct`Spinors`Def2CompSpinor::usage=StringReplace[xAct`Spinors`DefSpinor::usage,"DefSpinor"->"Def2CompSpinor"];
xAct`Spinors`DefSpinor::usage=.;
xAct`Spinors`Undef2CompSpinor::usage=StringReplace[xAct`Spinors`UndefSpinor::usage,"UndefSpinor"->"Undef2CompSpinor"];
xAct`Spinors`UndefSpinor::usage=.;
xAct`Spinors`PrintDaggerAs::usage=StringReplace[xAct`Spinors`PrintDaggerAs::usage,"DefSpinor"->"Def2CompSpinor"];
];


(* ::Input::Initialization:: *)
If[SpinorsPkgLoaded&&(!SpinorsKeepDefs),
DownValues[xAct`Spinors`Private`CheckMetric]=(DownValues[xAct`Spinors`Private`CheckMetric]/.{xAct`Spinors`DefSpinStructure->xAct`Spinors`Def2CompSpinStructure});
Unprotect[xAct`Spinors`DefSpinStructure];
Options[xAct`Spinors`Def2CompSpinStructure]=Options[xAct`Spinors`DefSpinStructure];
DownValues[xAct`Spinors`Def2CompSpinStructure]=(DownValues[xAct`Spinors`DefSpinStructure]/.{xAct`Spinors`DefSpinStructure->xAct`Spinors`Def2CompSpinStructure});
Protect[xAct`Spinors`Def2CompSpinStructure];
ClearAll[xAct`Spinors`DefSpinStructure];
Remove[xAct`Spinors`DefSpinStructure];

Unprotect[xAct`Spinors`UndefSpinStructure];
Options[xAct`Spinors`Undef2CompSpinStructure]=Options[xAct`Spinors`UndefSpinStructure];
DownValues[xAct`Spinors`Undef2CompSpinStructure]=(DownValues[xAct`Spinors`UndefSpinStructure]/.{xAct`Spinors`UndefSpinStructure->xAct`Spinors`Undef2CompSpinStructure});
Protect[xAct`Spinors`Undef2CompSpinStructure];
ClearAll[xAct`Spinors`UndefSpinStructure];
Remove[xAct`Spinors`UndefSpinStructure];

Unprotect[xAct`Spinors`DefSpinor];
Options[xAct`Spinors`Def2CompSpinor]=Options[xAct`Spinors`DefSpinor];
DownValues[xAct`Spinors`Def2CompSpinor]=(DownValues[xAct`Spinors`DefSpinor]/.{xAct`Spinors`DefSpinor->xAct`Spinors`Def2CompSpinor});
Protect[xAct`Spinors`Def2CompSpinor];
ClearAll[xAct`Spinors`DefSpinor];
Remove[xAct`Spinors`DefSpinor];

(* UndefSpinor is just UndefTensor *)
Unprotect[xAct`Spinors`UndefSpinor];
xAct`Spinors`Undef2CompSpinor=UndefTensor;
Protect[xAct`Spinors`Undef2CompSpinor];
ClearAll[xAct`Spinors`UndefSpinor];
Remove[xAct`Spinors`UndefSpinor];
];


(* ::Input::Initialization:: *)
End[];


(* ::Input::Initialization:: *)
(****************************** 1.5 Usage messages ******************************)


(* ::Input::Initialization:: *)
DummiesIn::usage=usagerow[{"DummiesIn[",it@"bundle",",",it@"k","] returns a list of ",it@"k"," unique abstract dollar-indices on the vector bundle ",it@"bundle",", using the last of the user-defined indices."}];
TensorCount::usage=usagerows[{"TensorCount[",it@"expr",",",it@"T","] returns the number of tensors ",it@"T"," occuring in ",it@"expr",", including covariant derivatives of ",it@"T",". ",it@"expr"," can be given in pseudo index-free notation."},{"TensorCount[",it@"expr",",",it@"T",",False,False] does not include covariant derivatives of ",it@"T"," nor its perturbations."},{"TensorCount[",it@"expr",",",it@"T",",False,True] does not include covariant derivatives of ",it@"T"," but includes perturbations."},{"TensorCount[",it@"expr",",",it@"T",",True,True] includes both covariant derivatives of ",it@"T"," and perturbations."}];
AllTensors::usage=usagerow[{"AllTensors[",it@"expr","] returns a list containing all tensors occuring in ",it@"expr"," together with their multiplicity. ",it@"expr"," must be given in pseudo index-free notation."}];


(* ::Input::Initialization:: *)
DefVBundleWithMetric::usage=usagerow[{"DefVBundleWithMetric[",it@"bundle",",",it@"M",",",it@"dim",",{",it@"a",",",it@"b",",",it@"c",",\[Ellipsis]},",it@"metric","] defines ",it@"bundle"," to be a vector bundle with base manifold ",it@"M"," and fiber vector space with dimension given by ",it@"dim"," and represented by the abstract indices ",{it@"a",it@"b",it@"c","\[Ellipsis]"},". It defines ",it@"metric"," to be a metric on the vector bundle ",it@"bundle"," without associated covariant derivative, which is constant with respect to the covariant derivative on the tangent bundle of ",it@"M","."}];
$InvariantTraceTensors::usage=usagerow[{"$InvariantTraceTensors is a global variable storing the list of all currently defined invariant tensors on inner bundles."}];
InvariantTraceTensor::usage=usagerow[{"InvariantTraceTensor[",it@"bundle",",",it@"n",",",it@"sym","] returns the invariant tensor on the inner bundle ",it@"bundle"," obtained as the trace over ",it@"n"," basis elements. For ",it@"n","=3, ",it@"sym"," determines whether the antisymmetric f tensor or the symmetric d tensor is returned."}];
InvariantTraceTensorQ::usage=usagerow[{"InvariantTraceTensorQ[",it@"expr","] gives True if ",it@"expr"," is an invariant tensor on some inner bundle, and False otherwise."}];
$StructureConstantSign::usage=usagerow[{"$StructureConstantSign defines the global sign of the structure constants of inner bundles: [",Subscript["T","a"],",",Subscript["T","b"],"]\[ThinSpace]=\[ThinSpace]$StructureConstantSign\[ThinSpace]",Subscript["f","abc"],Subscript["T","c"],". The default value is I."}];
ReduceInvariantTraceTensors::usage=usagerows[{"ReduceInvariantTraceTensors[",it@"expr","] expands products of the structure constants ",Subscript["f","abc"]," with invariant tensors on inner bundles into sums of invariant tensors."},{"ReduceInvariantTraceTensors[",it@"expr",it@"tens","] expands products of ",Subscript["f","abc"]," with the invariant tensor ",it@"tens"," only."},{"ReduceInvariantTraceTensors[",it@"expr",{it@"tens1",it@"tens2","\[Ellipsis]"},"] expands products of ",Subscript["f","abc"]," with the invariant tensors ",it@"tens1",",",it@"tens2",",\[Ellipsis]"}];


(* ::Input::Initialization:: *)
BundleSymmetryOf::usage=usagerows[{"BundleSymmetryOf[",it@"expr","] gives a description (a result with head Symmetry) of the symmetry of ",it@"expr",". This includes a generating set for that symmetry using Cycles notation on the indices of ",it@"expr",". Extending SymmetryOf, the number of indices and the symmetry group are ordered by bundle."}];
Sorted::usage=usagerow[{"Sorted is an option for BundleSymmetryOf that specifies if the replacements should be sorted by slot number. By default, it is True."}];
Offset::usage=Offset::usage<>"\n"<>usagerow[{"Offset is also an option for BundleSymmetryOf that specifies if the generating sets should use offsets for the slot numbers. By default, it is False."}];


(* ::Input::Initialization:: *)
CenterDot::usage=usagerow[{"CenterDot stands for the non-commutative product of Grassmann-odd indexed objects."}];
Parity::usage=usagerow[{"Parity[",it@"expr","] returns the Grassmann parity of ",it@"expr","."}];
TimesToCenterDot::usage=usagerow[{"TimesToCenterDot[",it@"expr","], returns ",it@"expr"," with all products replaced by non-commutative ones."}];
DefEvenTensor::usage=usagerows[{"DefEvenTensor[",it@"T","[-",it@"a",",",it@"b",",\[Ellipsis]],",it@"M","] defines ",it@"T"," to be a Grassmann-even tensor field on the manifold ",it@"M"," and the base manifolds associated to the vector bundles of its indices -",it@"a",",",it@"b",",\[Ellipsis]"},{"DefEvenTensor[",it@"T","[-",it@"a",",",it@"b",",\[Ellipsis]],",it@"M",",",it@"sym","] defines ",it@"T"," to be a Grassmann-even tensor field with symmetry ",it@"sym","."}];
DefOddTensor::usage=usagerows[{"DefOddTensor[",it@"T","[-",it@"a",",",it@"b",",\[Ellipsis]],",it@"M","] defines ",it@"T"," to be a Grassmann-odd tensor field on the manifold ",it@"M"," and the base manifolds associated to the vector bundles of its indices -",it@"a",",",it@"b",",\[Ellipsis]"},{"DefOddTensor[",it@"T","[-",it@"a",",",it@"b",",\[Ellipsis]],",it@"M",",",it@"sym","] defines ",it@"T"," to be a Grassmann-odd tensor field with symmetry ",it@"sym","."}];
$CenterDotTexSymbol::usage=usagerow[{"$CenterDotTexSymbol gives the symbol to use for TeX output of the non-commutative product. The default value is a space."}];


(* ::Input::Initialization:: *)
FrameBundleQ::usage=usagerow[{"FrameBundleQ[",it@"expr","] gives True if ",it@"expr"," is a frame bundle, and False otherwise."}];
DefFrameBundle::usage=usagerow[{"DefFrameBundle[",it@"frame","[-",it@"\[Mu]",", ",it@"a","], ",it@"eta","[-",it@"a",", -",it@"b","], {",it@"a",", ",it@"b",", ",it@"c",", ...}] defines a frame bundle ",it@"FrameM"," with abstract indices ",it@"a",", ",it@"b",", \[Ellipsis] on the base manifold ",it@"M"," of the tangent bundle represented by the abstract index ",it@"\[Mu]",". It also defines the flat frame bundle metric ",it@"eta","[-",it@"a",",-",it@"b","] and the frame field ",it@"frame","[-",it@"\[Mu]",", ",it@"a","] with inverse ",it@"frame","[",it@"\[Mu]",", -",it@"a","]."}];
UndefFrameBundle::usage=usagerow[{"UndefFrameBundle[",it@"frame","] undefines the frame bundle whose frame field is ",it@"frame","."}];
FrameFieldOfBundle::usage=usagerow[{"FrameFieldOfBundle[",it@"tb",", ",it@"fb","] returns the frame field connecting the tangent bundle ",it@"tb"," and the frame bundle",it@"fb","."}];
$SpinConnections::usage=usagerow[{"$SpinConnections is a global variable storing the list of all currently defined spin connections."}];
CovDOfSpinConnection::usage=usagerow[{"CovDOfSpinConnection[",it@"\[Omega]","] returns the covariant derivative corresponding to the spin connection ",it@"\[Omega]","."}];
DefSpinConnection::usage=usagerow[{"DefSpinConnection[",it@"\[Omega]","[-",it@"\[Mu]",", -",it@"a",", -",it@"b","], ",it@"CD","] defines the spin connection ",it@"\[Omega]","[-",it@"\[Mu]",", -",it@"a",", -",it@"b","] of the covariant derivative ",it@"CD"," and the associated curvature and torsion tensors."}];
UndefSpinConnection::usage=usagerow[{"UndefSpinConnection[",it@"\[Omega]","] undefines the spin connection ",it@"\[Omega]","."}];
SpinConnectionToFrame::usage=usagerow[{"SpinConnectionToFrame[",it@"expr",", ",it@"\[Omega]","] expands all occurrences of the spin connection ",it@"\[Omega]"," inside ",it@"expr"," in terms of derivatives of the frame field and the torsion. It also expands perturbations of the spin connection in terms of covariant derivatives of the perturbation of the frame field and the torsion. The second argument can be a list of spin connections."}];
ContortionToTorsion::usage=usagerows[{"ContortionToTorsion[",it@"expr",", ",it@"CD","] expresses the contortion tensor ",it@"ContortionCD"," of the covariant derivative ",it@"CD"," occurring inside ",it@"expr"," by the torsion tensor ",it@"TorsionCD","."},{"ContortionToTorsion[",it@"expr",", ",it@"\[Omega]","] expresses the contortion tensor ",it@"Contortion\[Omega]"," of the spin connection ",it@"\[Omega]"," occurring inside ",it@"expr"," by the torsion tensor ",it@"Torsion\[Omega]","."},{"In both cases, the second argument can be a list of covariant derivatives or spin connections."}];


(* ::Input::Initialization:: *)
GammaMatrixQ::usage=usagerow[{"GammaMatrixQ[",it@"expr","] gives True if ",it@"expr"," is a \[Gamma] matrix, and False otherwise."}];
GammaStarQ::usage=usagerow[{"GammaStarQ[",it@"expr","] gives True if ",it@"expr"," is the \!\(\*SubscriptBox[\(\[Gamma]\), \(*\)]\) (chiral) matrix, and False otherwise."}];
GammaZeroQ::usage=usagerow[{"GammaZeroQ[",it@"expr","] gives True if ",it@"expr"," is the \!\(\*SuperscriptBox[\(\[Gamma]\), \(0\)]\) matrix, and False otherwise."}];
$GammaStarSign::usage=usagerow[{"$GammaStarSign defines the global sign of the \!\(\*SubscriptBox[\(\[Gamma]\), \(*\)]\) (chiral) matrix. By default it is 1."}];
GammaMatrix::usage=usagerows[{"GammaMatrix[",it@"metric",", ",it@"n","] returns the generalized (totally antisymmetric) \[Gamma] matrix of order ",it@"n"," of the Clifford algebra associated to the metric ",it@"metric","."},{"GammaMatrix[",it@"metric",", Star] returns the \!\(\*SubscriptBox[\(\[Gamma]\), \(*\)]\) (chiral) matrix of the Clifford algebra associated to the metric ",it@"metric","."},{"GammaMatrix[",it@"metric",", Zero] returns the \!\(\*SuperscriptBox[\(\[Gamma]\), \(0\)]\) matrix of the Clifford algebra associated to the metric ",it@"metric","."}];
MetricOfGammaMatrix::usage=usagerow[{"MetricOfGammaMatrix[",it@"\[Gamma]","] returns the metric associated to the Clifford algebra of ",it@"\[Gamma]","."}];
$GammaMatrices::usage=usagerow[{"$GammaMatrices is a global variable storing the list of all currently defined \[Gamma] matrices."}];
$PrecomputeGammaMatrixProducts::usage=usagerow[{"$PrecomputeGammaMatrixProducts controls whether products of generalised \[Gamma] matrices are precomputed when a spin structure is defined, to speed up later computations. By default, it is True."}];
If[SpinorsPkgLoaded&&SpinorsKeepDefs,
(* FieldsX functions are renamed *)
(* Roundabout construction to avoid introducing the symbols if we don't need them (leaky evaluation of If) *)
MessageName[Evaluate@Symbol["DefGenSpinStructure"],"usage"]=usagerow[{"DefGenSpinStructure[",it@"metric",", {",it@"A",", ",it@"B",", \[Ellipsis]}] defines a spin structure on the base manifold ",it@"M"," of the metric ",it@"metric",". This includes the \[Gamma] matrices of the Clifford algebra associated to ",it@"metric"," and a spin bundle ",it@"SpinM"," with abstract indices ",it@"A",", ",it@"B",", \[Ellipsis], whose covariant derivative is induced from the one of ",it@"metric",", with the same name."}];
MessageName[Evaluate@Symbol["UndefGenSpinStructure"],"usage"]=usagerow[{"UndefGenSpinStructure[",it@"metric","] undefines the spin structure on the base manifold of the metric ",it@"metric","."}];
,
(* We have the nice names *)
MessageName[Evaluate@Symbol["DefSpinStructure"],"usage"]=
usagerow[{"DefSpinStructure[",it@"metric",", {",it@"A",", ",it@"B",", \[Ellipsis]}] defines a spin structure on the base manifold ",it@"M"," of the metric ",it@"metric",". This includes the \[Gamma] matrices of the Clifford algebra associated to ",it@"metric"," and a spin bundle ",it@"SpinM"," with abstract indices ",it@"A",", ",it@"B",", \[Ellipsis], whose covariant derivative is induced from the one of ",it@"metric",", with the same name."}];
MessageName[Evaluate@Symbol["UndefSpinStructure"],"usage"]=usagerow[{"UndefSpinStructure[",it@"metric","] undefines the spin structure on the base manifold of the metric ",it@"metric","."}];
];
SpinBundleQ::usage=usagerow[{"SpinBundleQ[",it@"bundle","] gives True if ",it@"bundle"," is a spin bundle, and False otherwise."}];
SplitGammaMatrix::usage=usagerow[{"SplitGammaMatrix[",it@"\[Gamma]",", ",it@"keep","] decomposes the generalized \[Gamma] matrix ",it@"\[Gamma]", " into an antisymmetrized product of individual \[Gamma] matrices. If ",it@"keep","=True, the \!\(\*SubscriptBox[\(\[Gamma]\), \(*\)]\) (chiral) matrix is kept."}];
SplitGammaMatrices::usage=usagerow[{"SplitGammaMatrices[",it@"\[Gamma]",", ",it@"keep","] decomposes all the generalized \[Gamma] matrices appearing within ",it@"expr", " into antisymmetrized products of individual \[Gamma] matrices. If ",it@"keep","=True, the \!\(\*SubscriptBox[\(\[Gamma]\), \(*\)]\) (chiral) matrix is kept."}];
JoinGammaMatrices::usage=usagerow[{"JoinGammaMatrices[",it@"expr",", ",it@"keep","] replaces products of \[Gamma] matrices within ",it@"expr"," by generalized \[Gamma] matrices. If ",it@"keep","=True, products of a single \!\(\*SubscriptBox[\(\[Gamma]\), \(*\)]\) (chiral) matrix and other generalized \[Gamma] matrices are kept."}];
DualGammaMatrix::usage=usagerow[{"DualGammaMatrix[",it@"\[Gamma]","[",it@"\[Mu]",", ..., -",it@"A",", ",it@"B","]] returns the dual matrix of the generalized \[Gamma] matrix ",it@"\[Gamma]","[",it@"\[Mu]",", ..., -",it@"A",", ",it@"B","]."}];
GammaMatricesToDual::usage=usagerows[{"GammaMatricesToDual[",it@"expr","] replaces generalized \[Gamma] matrices with more than d/2 indices within ",it@"expr"," by their dual, where d is the dimension of the manifold."},{"GammaMatricesToDual[",it@"expr",", All] replaces all generalized \[Gamma] matrices within ",it@"expr"," by their dual."},{"GammaMatricesToDual[",it@"expr",", ",it@"\[Gamma]","] replaces only the matrix \[Gamma] within ",it@"expr"," by its dual."}];
ChangeGammaMatrices::usage=usagerow[{"ChangeGammaMatrices[",it@"expr",", ",it@"met1",", ",it@"met2","] converts all generalized \[Gamma] matrices within ",it@"expr"," depending on the metric ",it@"met1"," to the corresponding ones depending on the metric ",it@"met2",". One of the metrics must be the metric of a tangent bundle, and the other one of the associated frame bundle."}];
EpsilonGammaReduce::usage=usagerow[{"EpsilonGammaReduce[",it@"expr",",",it@"metric","] replaces products of the totally antisymmetric \[Epsilon] tensor and generalized \[Gamma] matrices associated to the metric ",it@"metric"," within ",it@"expr"," by suitably contracted ones."}];
EpsilonYoungProject::usage=usagerow[{"EpsilonYoungProject[",it@"expr",",",it@"metric","] projects products of the totally antisymmetric \[Epsilon] tensor associated to the metric ",it@"metric"," and other tensors within ",it@"expr"," onto the corresponding Young tableaux."}];


(* ::Input::Initialization:: *)
MajoranaQ::usage=usagerow[{"MajoranaQ[",it@"expr","] gives True if ",it@"expr"," is a Majorana spinor, and False otherwise."}];
DiracQ::usage=usagerow[{"DiracQ[",it@"expr","] gives True if ",it@"expr"," is a Dirac spinor, and False otherwise."}];
SpinorQ::usage=usagerow[{"SpinorQ[",it@"expr","] gives True if ",it@"expr"," is a spinor, and False otherwise."}];
SpinorUnbarQ::usage=usagerow[{"SpinorUnbarQ[",it@"expr","] gives True if ",it@"expr"," is a spinor but not a conjugate one, and False otherwise."}];
SpinorBarQ::usage=usagerow[{"SpinorBarQ[",it@"expr","] gives True if ",it@"expr"," is a conjugate spinor, and False otherwise."}];
If[SpinorsPkgLoaded&&SpinorsKeepDefs,
(* FieldsX functions are renamed *)
(* Roundabout construction to avoid introducing the symbols if we don't need them (leaky evaluation of If) *)
MessageName[Evaluate@Symbol["DefGenSpinor"],"usage"]=usagerows[{"DefGenSpinor[",it@"\[Psi]"[-it@"a"],", ",it@"M","] defines ",it@"\[Psi]"," to be a spinor field on the manifold ",it@"M"," and the spin bundle associated to the index ",-it@"a",". The conjugate spinor ",it@"\!\(\*OverscriptBox[\(\[Psi]\), \(_\)]\)"," is automatically defined, with name ",it@"bar\[Psi]","."},{"DefGenSpinor[",it@"\[Psi]"[-it@"a"],", ",it@"M",", ",it@"sym","] defines ",it@"\[Psi]"," to be a spinor field with symmetry ",it@"sym","."},{"DefGenSpinor[",it@"\[Psi]"[it@"b",-it@"a"],", ",it@"M","] defines ",it@"\[Psi]"," to be a spinor field valued in the inner bundle associated to the index ",it@"b","."}];
SpinorType::usage=usagerow[{"SpinorType is an option for DefGenSpinor that specifies the type of spinor. By default, it is Majorana."}];
Majorana::usage=usagerow[{"Majorana is a value for the option SpinorType of DefGenSpinor."}];
Dirac::usage=usagerow[{"Dirac is a value for the option SpinorType of DefGenSpinor."}];
Conjugate::usage=Conjugate::usage<>"\n"<>usagerow[{"Conjugate is also an option for DefGenSpinor that specifies if the roles of spinor and conjugate spinor should be switched."}];
MessageName[Evaluate@Symbol["UndefGenSpinor"],"usage"]=usagerow[{"UndefGenSpinor[",it@"\[Psi]","] undefines ",it@"\[Psi]"," and the conjugate spinor ",it@"\!\(\*OverscriptBox[\(\[Psi]\), \(_\)]\)","."}];
,
(* We keep the nice names *)
MessageName[Evaluate@Symbol["DefSpinor"],"usage"]=usagerows[{"DefSpinor[",it@"\[Psi]"[-it@"a"],", ",it@"M","] defines ",it@"\[Psi]"," to be a spinor field on the manifold ",it@"M"," and the spin bundle associated to the index ",-it@"a",". The conjugate spinor ",it@"\!\(\*OverscriptBox[\(\[Psi]\), \(_\)]\)"," is automatically defined, with name ",it@"bar\[Psi]","."},{"DefSpinor[",it@"\[Psi]"[-it@"a"],", ",it@"M",", ",it@"sym","] defines ",it@"\[Psi]"," to be a spinor field with symmetry ",it@"sym","."},{"DefSpinor[",it@"\[Psi]"[it@"b",-it@"a"],", ",it@"M","] defines ",it@"\[Psi]"," to be a spinor field valued in the inner bundle associated to the index ",it@"b","."}];
SpinorType::usage=usagerow[{"SpinorType is an option for DefSpinor that specifies the type of spinor. By default, it is Majorana."}];
Majorana::usage=usagerow[{"Majorana is a value for the option SpinorType of DefSpinor."}];
Dirac::usage=usagerow[{"Dirac is a value for the option SpinorType of DefSpinor."}];
Conjugate::usage=Conjugate::usage<>"\n"<>usagerow[{"Conjugate is also an option for DefSpinor that specifies if the roles of spinor and conjugate spinor should be switched."}];
MessageName[Evaluate@Symbol["UndefSpinor"],"usage"]=usagerow[{"UndefSpinor[",it@"\[Psi]","] undefines ",it@"\[Psi]"," and the conjugate spinor ",it@"\!\(\*OverscriptBox[\(\[Psi]\), \(_\)]\)","."}];
];
DefEvenSpinor::usage=usagerows[{"DefEvenSpinor[",it@"\[Psi]"[-it@"a"],", ",it@"M","] defines ",it@"\[Psi]"," to be a Grassmann-even spinor field on the manifold ",it@"M"," and the spin bundle associated to the index ",-it@"a",". The conjugate spinor ",it@"\!\(\*OverscriptBox[\(\[Psi]\), \(_\)]\)"," is automatically defined, with name ",it@"bar\[Psi]","."},{"DefEvenSpinor[",it@"\[Psi]"[-it@"a"],", ",it@"M",", ",it@"sym","] defines ",it@"\[Psi]"," to be a Grassmann-even spinor field with symmetry ",it@"sym","."},{"DefEvenSpinor[",it@"\[Psi]"[it@"b",-it@"a"],", ",it@"M","] defines ",it@"\[Psi]"," to be a Grassmann-even spinor field valued in the inner bundle associated to the index ",it@"b","."}];
DefOddSpinor::usage=usagerows[{"DefOddSpinor[",it@"\[Psi]"[-it@"a"],", ",it@"M","] defines ",it@"\[Psi]"," to be a Grassmann-odd spinor field on the manifold ",it@"M"," and the spin bundle associated to the index ",-it@"a",". The conjugate spinor ",it@"\!\(\*OverscriptBox[\(\[Psi]\), \(_\)]\)"," is automatically defined, with name ",it@"bar\[Psi]","."},{"DefOddSpinor[",it@"\[Psi]"[-it@"a"],", ",it@"M",", ",it@"sym","] defines ",it@"\[Psi]"," to be a Grassmann-odd spinor field with symmetry ",it@"sym","."},{"DefOddSpinor[",it@"\[Psi]"[it@"b",-it@"a"],", ",it@"M","] defines ",it@"\[Psi]"," to be a Grassmann-odd spinor field valued in the inner bundle associated to the index ",it@"b","."}];
ConjugateSpinor::usage=usagerow[{"ConjugateSpinor[",it@"\[Psi]","] returns ",it@"\!\(\*OverscriptBox[\(\[Psi]\), \(_\)]\)",", and ConjugateSpinor[",it@"bar\[Psi]","] returns ",it@"\[Psi]","."}];
SpinScalar::usage=usagerow[{"SpinScalar[",it@"expr","] gives True if ",it@"expr"," (given in pseudo index-free notation) is a spin bundle scalar (i.e., all indices with values in a spin bundle can be contracted), and False otherwise."}];


(* ::Input::Initialization:: *)
$SpinorFlipSigns::usage=usagerow[{"$SpinorFlipSigns is a table of signs appearing in the Majorana flip relations."}];
SignOfGammaMatrix::usage=usagerow[{"SignOfGammaMatrix[",it@"\[Gamma]","] returns the sign needed for the generalized \[Gamma] matrix ",it@"\[Gamma]"," appearing in the Majorana flip relations."}];
FindSpinChain::usage=usagerow[{"FindSpinChain[",it@"expr",",",it@"start","[",it@"inds","]] returns a list of spinors and \[Gamma] matrices appearing within ",it@"expr"," whose indices are contracted with each other (spin chain). The chain starts with ",it@"start"[it@"inds"],", which must be a (conjugate) spinor appearing in ",it@"expr","."}];
FlipSpinChain::usage=usagerow[{"FlipSpinChain[",it@"expr",",",it@"chain","] returns ",it@"expr"," with the spin chain ",it@"chain"," flipped using the Majorana flip relations."}];
FlipSpinor::usage=usagerows[{"FlipSpinor[",it@"expr","] returns ",it@"expr"," with a spinor bilinear flipped using the Majorana flip relations. ",it@"expr"," must contain a single spinor bilinear."},{"FlipSpinor[",it@"expr",",",it@"\[Psi]","] returns ",it@"expr"," with a spinor bilinear flipped using the Majorana flip relations. ",it@"expr"," must contain a single bilinear formed with the spinor ",it@"\[Psi]","."},{"FlipSpinor[",it@"expr",",",it@Subscript["\!\(\*OverscriptBox[\(\[Psi]\), \(_\)]\)",1],",",it@Subscript["\[Psi]",2],"] returns ",it@"expr"," with a spinor bilinear flipped using the Majorana flip relations. ",it@"expr"," must contain a single bilinear formed with the spinors ",it@Subscript["\!\(\*OverscriptBox[\(\[Psi]\), \(_\)]\)",1]," and ",it@Subscript["\[Psi]",2],"."}];
FlipSpinorsToConjugateAmount::usage=usagerow[{"FlipSpinorsToConjugateAmount[",it@"expr",",",it@"\[Psi]",",",it@"count","] returns ",it@"expr"," with spinor bilinears formed with the spinor ",it@"\[Psi]"," flipped using the Majorana flip relations until ",it@"count"," conjugate spinors ",it@"\!\(\*OverscriptBox[\(\[Psi]\), \(_\)]\)"," remain."}];
SortSpinor::usage=usagerows[{"SortSpinor[",it@"expr",",",it@"\[Psi]"->it@"\!\(\*OverscriptBox[\(\[Psi]\), \(_\)]\)","] returns ",it@"expr"," with all bilinears formed with the spinor ",it@"\[Psi]"," flipped using the Majorana flip relations. The spinor ",it@"\[Psi]"," and its conjugate ",it@"\!\(\*OverscriptBox[\(\[Psi]\), \(_\)]\)"," can be exchanged."},{"SortSpinor[",it@"expr",", {",it@Subscript["\[Psi]",1]->it@Subscript["\!\(\*OverscriptBox[\(\[Psi]\), \(_\)]\)",1],"\[Ellipsis]}] returns ",it@"expr"," with all bilinears formed with the spinors ",it@Subscript["\[Psi]",1],",\[Ellipsis] flipped using the Majorana flip relations. The spinors ",it@Subscript["\[Psi]","i"]," and their conjugates ",it@Subscript["\!\(\*OverscriptBox[\(\[Psi]\), \(_\)]\)","i"]," can be exchanged."}];
SpinorFlipSymmetrize::usage=usagerow[{"SpinorFlipSymmetrize[",it@"expr","] returns ",it@"expr"," with all spinor bilinears symmetrized using the Majorana flip relations."}];
FierzExpand::usage=usagerow[{"FierzExpand[",it@Subscript["\!\(\*OverscriptBox[\(\[Psi]\), \(_\)]\)",1][Subscript["inds",1]],",",it@Subscript["\[Psi]",2][Subscript["inds",2]],"] expands the tensor product ",it@Subscript["\!\(\*OverscriptBox[\(\[Psi]\), \(_\)]\)",1][Subscript["inds",1]],it@Subscript["\[Psi]",2][Subscript["inds",2]]," in the basis of generalized \[Gamma] matrices (Fierz rearrangement). Both spinors may have covariant derivatives acting on them."}];


(* ::Input::Initialization:: *)
IrreducibleSpinTensor::usage=usagerow[{"IrreducibleSpinTensor[",it@"\[Psi]",",",it@"n",",",it@"rep","] returns the irreducible tensor of the Lorentz group corresponding to the representation ",it@"rep"," appearing in the decomposition of the tensor product of ",it@"n"," copies of the spinor ",it@"\[Psi]","."}];
IrreducibleSpinTensorQ::usage=usagerow[{"IrreducibleSpinTensorQ[",it@"expr","] gives True if ",it@"expr"," is an irreducible tensor of the Lorentz group for some representation, and False otherwise."}];
ExpandIrreducibleSpinTensor::usage=usagerow[{"ExpandIrreducibleSpinTensor[",it@"tens","[",it@"\[Psi]",",\[Ellipsis]][",it@"inds","]] expands the irreducible tensor ",it@"tens"," into a sum of products of spinors ",it@"\[Psi]"," with the right symmetries."}];
ExpandIrreducibleSpinTensors::usage=usagerow[{"ExpandIrreducibleSpinTensors[",it@"expr","] expands all irreducible tensors of the Lorentz group within ",it@"expr"," into a sum of products of spinors with the right symmetries."}];
IrreducibleSpinDecompose::usage=usagerow[{"IrreducibleSpinDecompose[",it@"expr",",",it@"\[Psi]","] decomposes all products of spinors ",it@"\[Psi]"," within ",it@"expr"," into sums of irreducible representations of the Lorentz group."}];
IrreducibleSpinProject::usage=usagerow[{"IrreducibleSpinProject[",it@"expr",",",it@"\[Psi]","] projects all irreducible tensors of the Lorentz group within ",it@"expr"," depending on the spinor ",it@"\[Psi]"," onto their Young tableaux. This includes their products with \[Gamma] matrices, and induced symmetries if the spinor ",it@"\[Psi]"," depends on inner bundles."}];


(* ::Input::Initialization:: *)
$Gradings::usage=usagerow[{"$Gradings is a global variable storing the list of all currently defined gradings."}];
DefGrading::usage=usagerows[{"DefGrading[",it@"grad","] defines the grading ",it@"grad","."},{"DefGrading[{",it@Subscript["grad",1],"\[Ellipsis]}] defines the gradings ",it@Subscript["grad",1],",\[Ellipsis]"}];
SumGrading::usage=usagerow[{"SumGrading is an option for DefGrading that specifies a function that determines the grading of a sum. By default it is Undefined&."}];
ZeroGrading::usage=usagerow[{"ZeroGrading is an option for DefGrading that specifies the grading of 0. By default it is Undefined."}];
UndefGrading::usage=usagerow[{"UndefGrading[",it@"grad","] undefines ",it@"grad","."}];
SetGrading::usage=usagerows[{"SetGrading[",it@"T",",",it@"grad","\[Rule]",it@"val","] sets the grading ",it@"grad"," of the tensor or spinor ",it@"T"," to the value ",it@"val","."},{"SetGrading[{",it@Subscript["T",1],",",it@Subscript["T",2],"\[Ellipsis]}",it@"grad","\[Rule]",it@"val","] sets the grading of all the tensors ",it@Subscript["T","i"],"."},{"SetGrading[",it@"T",",{",it@Subscript["grad",1],"\[Rule]",it@Subscript["val",1],",",it@Subscript["grad",2],"\[Rule]",it@Subscript["val",2],"\[Ellipsis]}] sets all gradings ",it@Subscript["grad","i"]," to their respective values ",it@Subscript["val","i"],"."}];


(* ::Input::Initialization:: *)
LeftVarD::usage=usagerows[{"LeftVarD[",it@"T","[",it@"inds","]][",it@"expr","] returns the left variational derivative of ",it@"expr"," with respect to the tensor or spinor field ",it@"T","[",it@"inds","]."},{"LeftVarD[",it@"T","[",it@"inds","],",it@"covd","][",it@"expr","] returns the left variational derivative of ",it@"expr"," with respect to the tensor or spinor field ",it@"T","[",it@"inds","]. Integration by parts uses the covariant derivative ",it@"covd"," instead of the partial derivative PD."}];
RightVarD::usage=usagerows[{"RightVarD[",it@"T","[",it@"inds","]][",it@"expr","] returns the right variational derivative of ",it@"expr"," with respect to the tensor or spinor field ",it@"T","[",it@"inds","]."},{"RightVarD[",it@"T","[",it@"inds","],",it@"covd","][",it@"expr","] returns the right variational derivative of ",it@"expr"," with respect to the tensor or spinor field ",it@"T","[",it@"inds","]. Integration by parts uses the covariant derivative ",it@"covd"," instead of the partial derivative PD."}];


(* ::Input::Initialization:: *)
FindAllContractions::usage=usagerows[{"FindAllContractions[",it@"expr","] returns a list of all possible full contractions of ",it@"expr"," over its free indices. Extending AllContractions, this function also works if the tensors within ",it@"expr"," depend on more than one bundle. ",it@"expr","can be given in pseudo index-free notation."},{"FindAllContractions[",it@"expr",", {",it@"a",",",it@"b",",\[Ellipsis]}] returns a list of all possible full contractions of ",it@"expr"," that have ",it@"a",",",it@"b","\[Ellipsis] as free indices."},{"FindAllContractions[",it@"expr",", {",it@"a",",",it@"b",",\[Ellipsis]},",it@"sym","] returns a list of all possible full contractions of ",it@"expr"," with the symmetry ",it@"sym"," imposed on the free indices ",it@"a",",",it@"b","\[Ellipsis]"}];
SymmetrizeMethod::usage=SymmetrizeMethod::usage<>"\n"<>usagerow[{"SymmetrizeMethod is also an option for FindAllContractions that specifies a function to symmetrize the free indices. By default, it is ImposeSymmetry."}];
AuxiliaryTensor::usage=AuxiliaryTensor::usage<>"\n"<>usagerow[{"AuxiliaryTensor is also an option for FindAllContractions that specifies the name of the auxiliary tensor used for the free indices."}];
Parallelization::usage=Parallelization::usage<>"\n"<>usagerow[{"Parallelization is also an option for FindAllContractions that specifies whether contractions should be calculated in parallel."}];
GenerateMonomials::usage=usagerow[{"GenerateMonomials[",it@"fields",",",it@"invtens","] returns a list of all monomials that can be formed from the fields ",it@"fields",", their covariant derivatives, and the invariant tensors ",it@"invtens","."}];
GenerateMonomialsByGrading::usage=usagerow[{"GenerateMonomialsByGrading[",it@"fields",",",it@"invtens",",",it@"grad"->it@"n","] returns a list of all monomials that can be formed from the fields ",it@"fields",", their covariant derivatives, and the invariant tensors ",it@"invtens",", restricted to the value ",it@"n"," for the grading ",it@"grad","."}];
FreeIndices::usage=usagerow[{"FreeIndices is an option for GenerateMonomials and GenerateMonomialsByGrading that specifies a list of free (uncontracted) indices that the returned monomials should have. By default, it is an empty list."}];
Constraint::usage=usagerow[{"Constraint is an option for GenerateMonomials and GenerateMonomialsByGrading that specifies the constraint function, a function returning True if its argument should be added to the list of monomials and False otherwise. By default, it is given by True& (i.e., no constraint)."}];
Replacements::usage=usagerow[{"Replacements is an option for GenerateMonomials and GenerateMonomialsByGrading that specifies a list of replacements to be made after contracting free indices in each monomial. By default, it is an empty list."}];
MaxNumberOfFields::usage=usagerow[{"MaxNumberOfFields is an option for GenerateMonomials and GenerateMonomialsByGrading that specifies the maximum number of fields of each type that can appear in an monomial. It can be an integer, or a list of integers specifying the maximum number for each field. By default, it is Infinity for GenerateMonomialsByGrading and 5 for GenerateMonomials."}];
MaxNumberOfInvTensors::usage=usagerow[{"MaxNumberOfInvTensors is an option for GenerateMonomials and GenerateMonomialsByGrading that specifies the maximum number of invariant tensors of each type that can appear in an monomial. It can be an integer, or a list of integers specifying the maximum number for each tensor. By default, it is Infinity for GenerateMonomialsByGrading and 1 for GenerateMonomials."}];
MaxNumberOfDerivatives::usage=usagerow[{"MaxNumberOfDerivatives is an option for GenerateMonomials and GenerateMonomialsByGrading that specifies the maximum number of derivatives that can be applied to a field. It can be an integer, or a list of integers specifying the maximum number for each field. By default, it is Infinity for GenerateMonomialsByGrading and 3 for GenerateMonomials."}];
IndexFree::usage=IndexFree::usage<>"\n"<>usagerow[{"IndexFree is also an option for GenerateMonomials and GenerateMonomialsByGrading that specifies if the list of monomials should returned in pseudo index-free notation. By default, it is False."}];
FilterGammaMatrices::usage=usagerow[{"FilterGammaMatrices is an option for GenerateMonomialsByGrading that specifies whether spinor bilinears containing more than one generalized \[Gamma] matrix should be dropped. By default, it is True."}];


(* ::Input::Initialization:: *)
DefOddDifferential::usage=usagerow[{"DefOddDifferential[",it@"brst","] defines a Grassmann-odd differential ",it@"brst"," that commutes with covariant derivatives. The BRST differential BRST is predefined."}];
BRST::usage=usagerow[{"BRST[",it@"expr","] returns the BRST differential applied to ",it@"expr",". BRST transformations can be defined using F/:BRST[F[inds]]^:=G[inds]."}];
BRSTWeightInequalities::usage=usagerows[{"BRSTWeightInequalities[{",it@Subscript["field",1],",",it@Subscript["field",2],",\[Ellipsis]},",it@"brst",",",it@"weight","] returns a list with inequalities that the weight function ",it@"weight"," has to fulfill to be an admissible filtration for the BRST operator ",it@"brst"," applied to the fields ",it@Subscript["field",1],",",it@Subscript["field",2],",\[Ellipsis]"},{"BRSTWeightInequalities[{",it@Subscript["field",1],",",it@Subscript["field",2],"\[Ellipsis]},",it@"brst",",",it@"weight",",False] does not apply the Reduce function to the obtained system of inequalities before returning it."}];
FindBRSTWeights::usage=usagerow[{"FindBRSTWeights[{",it@Subscript["field",1],",",it@Subscript["field",2],",\[Ellipsis]},",it@"brst",",",it@"maxweight","] returns a list of all weights admissible for filtrations of the BRST differential ",it@"brst", " applied to the fields ",it@Subscript["field",1],",",it@Subscript["field",2],",\[Ellipsis], with the maximum weight of each field restricted to be \[LessEqual]",it@"maxweight","."}];
CheckFiltration::usage=usagerows[{"CheckFiltration[{",it@Subscript["field",1],",",it@Subscript["field",2],",\[Ellipsis]}, {",it@Subscript["w",1],",",it@Subscript["w",2],",\[Ellipsis]},",it@"brst","] displays a table of the lowest-order terms of the BRST differential ",it@"brst"," applied to the fields ",it@Subscript["field",1],",",it@Subscript["field",2],",\[Ellipsis] and filtrated according to the weights ",it@Subscript["w",1],",",it@Subscript["w",2],",\[Ellipsis]","CheckFiltration[{",it@Subscript["field",1]->it@Subscript["w",1],",",it@Subscript["field",2]->it@Subscript["w",2],",\[Ellipsis]},",it@"brst","] displays a table of the lowest-order terms of the BRST differential ",it@"brst"," applied to the fields ",it@Subscript["field",1],",",it@Subscript["field",2],",\[Ellipsis] and filtrated according to the weights ",it@Subscript["w",1],",",it@Subscript["w",2],",\[Ellipsis]"}];
Display::usage=Display::usage<>"\n"<>usagerow[{"Display is also an option for CheckFiltration with values IndexFree and Full that specifies how the table entries should be displayed."}];
Filtrate::usage=usagerows[{"Filtrate[{",it@Subscript["field",1],",",it@Subscript["field",2],"\[Ellipsis]}, {",it@Subscript["w",1],",",it@Subscript["w",2],",\[Ellipsis]},",it@"brst"->it@"brst0","] defines rules for the differential ",it@"brst0"," such that it acts as the lowest-order terms of the BRST differential ",it@"brst"," applied to the fields ",it@Subscript["field",1],",",it@Subscript["field",2],",\[Ellipsis] and filtrated according to the weights ",it@Subscript["w",1],",",it@Subscript["w",2],",\[Ellipsis]"},{"Filtrate[{",it@Subscript["field",1]->it@Subscript["w",1],",",it@Subscript["field",2]->it@Subscript["w",2],",\[Ellipsis]},",it@"brst"->it@"brst0","] defines rules for the differential ",it@"brst0"," such that it acts as the lowest-order terms of the BRST differential ",it@"brst"," applied to the fields ",it@Subscript["field",1],",",it@Subscript["field",2],",\[Ellipsis] and filtrated according to the weights ",it@Subscript["w",1],",",it@Subscript["w",2],",\[Ellipsis]"}];
RemoveFiltration::usage=usagerows[{"RemoveFiltration[",it@"brst0","] removes the rules defined for the differential ",it@"brst0"," defined by Filtrate."}];


(* ::Input::Initialization:: *)
CohomologyFromAnsatz::usage=usagerow[{"CohomologyFromAnsatz[",it@"brst",",",it@"ansatzcc",",",it@"brstb",",",it@"ansatzcb","] returns a list of representatives of elements of the cohomology Ker(",it@"brst",")/Im(",it@"brstb","). For the BRST cohomology H(s), one needs to take ",it@"brst","=",it@"brstb","=BRST. A list of possible elements (cocycles) must be given as ",it@"ansatzcc",", and a list of possible exact elements (coboundaries) as ",it@"ansatzcb",". Both lists could be calculated using GenerateMonomials or GenerateMonomialsByGrading."}];
RelativeCohomologyFromAnsatz::usage=usagerow[{"RelativeCohomologyFromAnsatz[",it@"brst",",",it@"ansatzcc",",",it@"d",",",it@"ansatzd",",",it@"brstb",",",it@"ansatzcb",",",it@"db",",",it@"ansatzdb","] returns a list of representatives of elements of the relative cohomology Ker(",it@"brst","|",it@"d",")/Im(",it@"brstb","|",it@"db","). For the relative BRST cohomology H(s|d), one needs to take ",it@"brst","=",it@"brstb","=BRST, and ",it@"d","=",it@"db","=CD[-a]. A list of possible elements (cocycles) must be given as ",it@"ansatzcc"," and ",it@"ansatzd",", and a list of possible exact elements (coboundaries) as ",it@"ansatzcb"," and ",it@"ansatzdb",". All lists could be calculated using GenerateMonomials or GenerateMonomialsByGrading."}];
CanonicalizeMethod::usage=usagerow[{"CanonicalizeMethod is an option for CohomologyFromAnsatz and RelativeCohomologyFromAnsatz that specifies the function applied to an expression after the differential has acted, to obtain a canonical form. By default, it is given by CollectTensors[ReduceInvariantTraceTensors[ContractMetric[SymmetrizeCovDs[Expand[#]]]&."}];
SimplifyMethod::usage=usagerow[{"SimplifyMethod is an option for CohomologyFromAnsatz and RelativeCohomologyFromAnsatz that specifies the function applied to representatives of elements of the cohomology before they are returned. By default, it is given by Identity (i.e., no transformation)."}];


(* ::Input::Initialization:: *)
(****************************** 1.6 Error messages ******************************)


(* ::Input::Initialization:: *)
InvariantTraceTensor::sym1="A symmetry can only be specified for n=3, but n=`1` was given.";
InvariantTraceTensor::sym2="The symmetry specification must be either Symmetric or Antisymmetric, but `1` was given.";
IrreducibleSpinTensor::wrongdim="Irreducible tensors of the Lorentz group are only implemented for 4 dimensions, but spin bundle has dimension `1` and tangent bundle has dimension `2`.";
IrreducibleSpinTensor::toomanyinds="Irreducible tensors of the Lorentz group are only implemented for at most one Lie algebra index, but spinor has `1` Lie algebra indices.";
IrreducibleSpinTensor::nolie="Lie bundle of the spinor cannot be the tangent bundle, Rarita-Schwinger fields are not implemented yet.";
IrreducibleSpinTensor::nomajorana="Only Majorana spinors are implemented so far.";
IrreducibleSpinTensor::invalidrep="`1` is not a valid irreducible representation for the given spinor and multiplicity.";
IrreducibleSpinTensor::notimpl="The requested irreducible tensors are not implemented yet.";
SplitGammaMatrix::nogamma="`1` is not a generalized \[Gamma] matrix.";
DualGammaMatrix::wronggamma="Cannot dualise \!\(\*SuperscriptBox[\(\[Gamma]\), \(0\)]\).";
EpsilonGammaReduce::wrongdim="Reduction of \[Epsilon] tensors and \[Gamma] matrices is only implemented for integer dimensions, but tangent bundle has dimension `1`.";
EpsilonYoungProject::wrongdim="Young projection of \[Epsilon] tensors is only implemented for 4 dimensions, but tangent bundle has dimension `1`.";
If[SpinorsPkgLoaded&&SpinorsKeepDefs,
(* FieldsX functions are renamed *)
DefGenSpinor::nomanifold="No manifold found in `1`.";
DefGenSpinor::majoranawrongdim="Majorana spinors only exist ist d=2,3,4 (mod 8) dimensions, but `1` has dimension `2`.";
,
(* Roundabout construction to avoid introducing the symbols if we don't need them (leaky evaluation of If) *)
MessageName[Evaluate@Symbol["DefSpinor"],"nomanifold"]="No manifold found in `1`.";
MessageName[Evaluate@Symbol["DefSpinor"],"majoranawrongdim"]="Majorana spinors only exist ist d=2,3,4 (mod 8) dimensions, but `1` has dimension `2`.";
];
FlipSpinor::toomany="Only `3` `1` allowed, but found `2`.";
FlipSpinorsToConjugateAmount::amount="Only `3` `1` found in expression, but `4` `2` should be obtained.";
FierzExpand::diffbundles="Spinors must be defined on the same spin bundle, but found two different bundles `1` and `2`.";


(* ::Input::Initialization:: *)
$ContextPath=DeleteCases[$ContextPath,"xAct`FieldsX`Private`"];


(* ::Input::Initialization:: *)
(****************************** 1.7 Begin private ******************************)

Begin["`Private`"];


(* ::Input::Initialization:: *)
(****************************** 2. Main code for FieldsX ******************************)


(* ::Input::Initialization:: *)
(****************************** 2.0 Internal functions and initializations ******************************)


(* ::Input::Initialization:: *)
SetAttributes[inject1,HoldFirst];
Quiet[inject1[expr_,(Rule|RuleDelayed)[var_Symbol,values:Verbatim[Sequence][__]]]:=Replace[Unevaluated[values],Sequence[var__]:>expr];
inject1[expr_,(Rule|RuleDelayed)[var_Symbol,value_]]:=Replace[Unevaluated[value],var_:>expr],{RuleDelayed::rhs}];
SetAttributes[inject,HoldAll];
inject[rules_,expr_]:=Internal`InheritedBlock[{Rule,RuleDelayed},SetAttributes[{Rule,RuleDelayed},HoldFirst];
ReleaseHold@Fold[inject1,HoldComplete[expr],rules]];


(* ::Input::Initialization:: *)
(CM:xAct`xTensor`Private`ContractMetric1[{od_,aud_},{metric_,nv_}])[rest_. prod_?ProductQ[left___,der_?FirstDerQ[expr_],right___]met:metric_[b_,c_]]:=
Module[{dm=der[met],result},
If[(od||dm===0)&&xAct`xTensor`Private`differentexpressionsQ[result=CM[expr met],{expr,met}],
CM[rest prod[left,der[result],right]]-CM[rest prod[left,dm,expr,right]],
CM[rest met]prod[left,der[expr],right]]
]/;(ScalarsOfProduct[prod][metric[b,c]]&&MemberQ[FindFreeIndices[expr],ChangeIndex[c]|ChangeIndex[b]]&&Head[expr]=!=metric);


(* ::Input::Initialization:: *)
(CM:xAct`xTensor`Private`ContractMetric1[{od_,aud_},{metric_,nv_}])[rest_. prod_?ProductQ[left___,covd_?CovDQ[i1___,a_,i2___][expr_],right___]metric_[b_,c_]]:=xAct`xTensor`Private`SMP[metric,c,a]CM[rest prod[left,covd[i1,b,i2][expr],right]]/;(ScalarsOfProduct[prod][metric[b,c]]&&PairQ[c,a]&&(aud||DownIndexQ[b])&&xAct`xTensor`Private`PRJ[nv,covd,metric]);
(CM:xAct`xTensor`Private`ContractMetric1[{od_,aud_},{metric_,nv_}])[rest_. prod_?ProductQ[left___,covd_?CovDQ[i1___,a_,i2___][expr_],right___]metric_[b_,c_]]:=xAct`xTensor`Private`SMP[metric,a,b]CM[rest prod[left,covd[i1,c,i2][expr],right]]/;(ScalarsOfProduct[prod][metric[b,c]]&&PairQ[a,b]&&(aud||DownIndexQ[c])&&xAct`xTensor`Private`PRJ[nv,covd,metric]);


(* ::Input::Initialization:: *)
(CM:xAct`xTensor`Private`ContractMetric1[{od_,aud_},{metric_,nv_}])[rest_. der_?CovDQ[inds___][expr_]met:metric_[b_,c_]]:=
Module[{result},
If[xAct`xTensor`Private`differentexpressionsQ[result=CM[expr met],{expr,met}],
CM[rest der[inds][result]],
CM[rest met]der[inds][expr]]
]/;(der[inds][metric[b,c]]===0&MemberQ[FindFreeIndices[expr],ChangeIndex[c]|ChangeIndex[b]]&&Head[expr]=!=metric);


(* ::Input::Initialization:: *)
Unprotect[Grade];
Grade[der_?CovDQ[inds___][expr_],prod_?GradedProductQ]:=Grade[expr,prod]+xAct`xTensor`Private`GradeOfDer[der[inds],prod];
Protect[Grade];


(* ::Input::Initialization:: *)
xTension["FieldsX",UndefTensor,"Beginning"]:=Function[$InvariantTraceTensors=DeleteCases[$InvariantTraceTensors,#];$GammaMatrices=DeleteCases[$GammaMatrices,#];];


(* ::Input::Initialization:: *)
xAct`xCore`Private`setargs[f_,0,{2,4}]:=f[]:=Message[f::argt,f,0,2,4];
xAct`xCore`Private`setargs[f_,1,{2,4}]:=f[_]:=Message[f::argt,f,1,2,4];
xAct`xCore`Private`setargs[f_,Infinity,{2,4}]:=f[_,_,_,_,x__]:=Message[f::argt,f,4+Length[{x}],2,4];
SetNumberOfArguments[f_,{2,4}]:=(xAct`xCore`Private`setargs[f,0,{2,4}];xAct`xCore`Private`setargs[f,1,{2,4}];xAct`xCore`Private`setargs[f,Infinity,{2,4}];)


(* ::Input::Initialization:: *)
(****************************** 2.1 Helper functions ******************************)


(* ::Input::Initialization:: *)
DummiesIn[bundle_?VBundleQ,k_Integer]:=Nest[Append[#,DummyIn[bundle]]&,{},k];
SetNumberOfArguments[DummiesIn,2];
Protect[DummiesIn];


(* ::Input::Initialization:: *)
TensorCount[IndexFree[expr___],t_?xTensorQ]:=TensorCount[IndexFree[expr],t,True,False];
TensorCount[IndexFree[Verbatim[Plus][expr___]],t_?xTensorQ,ders_?BooleanQ,perts_?BooleanQ]:=Map[TensorCount[IndexFree[#],t,ders,perts]&,Plus[expr]];
TensorCount[IndexFree[Verbatim[Times][expr___]],t_?xTensorQ,ders_?BooleanQ,perts_?BooleanQ]:=Plus@@Map[TensorCount[IndexFree[#],t,ders,perts]&,List[expr]];
TensorCount[IndexFree[x_^y_],t_?xTensorQ,ders_?BooleanQ,perts_?BooleanQ]:=y TensorCount[IndexFree[x],t,ders,perts];
TensorCount[IndexFree[cd_?CovDQ[expr_]],t_?xTensorQ,True,perts_?BooleanQ]:=TensorCount[IndexFree[expr],t,True,perts];
TensorCount[IndexFree[cd_?CovDQ[expr_]],t_?xTensorQ,False,perts_?BooleanQ]:=0;
TensorCount[IndexFree[t1_?xTensorQ],t_?xTensorQ,ders_?BooleanQ,perts_?BooleanQ]:=If[t1===t,1,0];
TensorCount[IndexFree[Perturbation[t1_?xTensorQ]],t_?xTensorQ,ders_?BooleanQ,True]:=If[t1===t,1,0];
TensorCount[IndexFree[Perturbation[t1_?xTensorQ]],t_?xTensorQ,ders_?BooleanQ,False]:=0;
TensorCount[IndexFree[Perturbation[t1_?xTensorQ,n_]],t_?xTensorQ,ders_?BooleanQ,True]:=If[t1===t,1,0];
TensorCount[IndexFree[Perturbation[t1_?xTensorQ,n_]],t_?xTensorQ,ders_?BooleanQ,False]:=0;
TensorCount[IndexFree[x_?ConstantExprQ],t_?xTensorQ,ders_?BooleanQ,perts_?BooleanQ]:=0;


(* ::Input::Initialization:: *)
TensorCount[expr_,t_?xTensorQ]:=TensorCount[expr,t,True,False];
TensorCount[Verbatim[Plus][expr___],t_?xTensorQ,ders_?BooleanQ,perts_?BooleanQ]:=Map[TensorCount[#,t,ders,perts]&,Plus[expr]];
TensorCount[Verbatim[Times][expr___],t_?xTensorQ,ders_?BooleanQ,perts_?BooleanQ]:=Plus@@Map[TensorCount[#,t,ders,perts]&,List[expr]];
TensorCount[Verbatim[CenterDot][expr___],t_?xTensorQ,ders_?BooleanQ,perts_?BooleanQ]:=Plus@@Map[TensorCount[#,t,ders,perts]&,List[expr]];
TensorCount[cd_?CovDQ[inds__][expr_],t_?xTensorQ,True,perts_?BooleanQ]:=TensorCount[expr,t,True,perts];
TensorCount[cd_?CovDQ[inds__][expr_],t_?xTensorQ,False,perts_?BooleanQ]:=0;
TensorCount[t1_?xTensorQ[inds___],t_?xTensorQ,ders_?BooleanQ,perts_?BooleanQ]:=If[t1===t,1,0];
TensorCount[Perturbation[t1_?xTensorQ[inds___]],t_?xTensorQ,ders_?BooleanQ,True]:=If[t1===t,1,0];
TensorCount[Perturbation[t1_?xTensorQ[inds___]],t_?xTensorQ,ders_?BooleanQ,False]:=0;
TensorCount[Perturbation[t1_?xTensorQ[inds___],n_],t_?xTensorQ,ders_?BooleanQ,True]:=If[t1===t,1,0];
TensorCount[Perturbation[t1_?xTensorQ[inds___],n_],t_?xTensorQ,ders_?BooleanQ,False]:=0;
TensorCount[x_?ConstantExprQ,t_?xTensorQ,ders_?BooleanQ,perts_?BooleanQ]:=0;
TensorCount[t1_?xTensorQ[]^y_,t_?xTensorQ,ders_?BooleanQ,perts_?BooleanQ]:=y TensorCount[t1[],t,ders,perts];
(*TensorCount[h_?InertHeadQ[expr_],t_?xTensorQ,ders_?BooleanQ]:=TensorCount[expr,t,ders];*)
SetNumberOfArguments[TensorCount,{2,4}];
Protect[TensorCount];


(* ::Input::Initialization:: *)
AllTensors[IndexFree[expr_]]:=Tally[AllTensors1[expr]];
AllTensors1[Verbatim[Plus][expr___]]:=Flatten@Map[AllTensors1,List[expr]];
AllTensors1[Verbatim[Times][expr___]]:=Flatten@Map[AllTensors1,List[expr]];
AllTensors1[x_^k_]:=ConstantArray[AllTensors1[x],k];
AllTensors1[cd_?CovDQ[expr_]]:=AllTensors1[expr];
AllTensors1[t_?xTensorQ]:={t};
AllTensors1[x_?ConstantExprQ]:=Sequence[];
SetNumberOfArguments[AllTensors,1];
Protect[AllTensors];


(* ::Input::Initialization:: *)
(****************************** 2.2 Inner bundles ******************************)


(* ::Input::Initialization:: *)
Options@DefVBundleWithMetric=Options@DefVBundle;
DefVBundleWithMetric[vb_,man_,dims_,inds_:{__Symbol},metric_,options___]:=Catch@Module[{tangentcovd},
tangentcovd=CovDOfMetric@First@MetricsOfVBundle[Tangent[man]];
If[!CovDQ[tangentcovd],Throw@Message[DefVBundleWithMetric::error,"Cannot define metric on vbundle if tangent bundle has no covariant derivative."]];
If[Length[inds]<2,Throw@Message[DefVBundleWithMetric::error,"Need at least two indices to define the metric."]];
DefVBundle[vb,man,dims,inds,options];
DefTensor[metric[-inds[[1]],-inds[[2]]],man,Symmetric[{1,2}],Master->vb,DefInfo->{"metric of vbundle",""}];
MetricQ[metric]^=True;
xUpAppendTo[MetricsOfVBundle[vb],metric];
VBundleOfMetric[metric]^=vb;
$Metrics=Flatten[{$Metrics,metric}];
InducedFrom[metric]^=Null;
metric[a_Symbol,-b_Symbol]:=delta[a,-b];
metric[-a_Symbol,b_Symbol]:=delta[-a,b];
(* We also need a covariant derivative to make xAct happy. *)
CovDOfMetric[metric]^=tangentcovd;
metric/:tangentcovd[k__][metric[i_,j_]]:=0;
];
SetNumberOfArguments[DefVBundleWithMetric,{5,Infinity}];
Protect[DefVBundleWithMetric];


(* ::Input::Initialization:: *)
$InvariantTraceTensors={};
InvariantTraceTensorQ[_]:=False;


(* ::Input::Initialization:: *)
defInvTrTensor[bundle_,rank_,symdef_]:=Module[{bundlename,tens,inds,pa,sym,cd},
bundlename=SymbolName[bundle];
(* make a nice name *)
tens=Switch[rank,
3,Symbol["Inv"<>bundlename<>If[symdef===Symmetric,"d","f"]],
_,Symbol["Inv"<>bundlename<>ToString[rank]]
];
(* quit if already defined *)
If[xTensorQ[tens],Return[tens]];
(* print nicely *)
pa=Switch[rank,3,If[symdef===Symmetric,"d[","f["]<>bundlename<>"]",_,"tr["<>bundlename<>"]"];
(* get indices *)
inds=GetIndicesOfVBundle[bundle,rank];
(* find symmetry *)
sym=Switch[rank,3,If[symdef===Symmetric,Symmetric[{1,2,3}],Antisymmetric[{1,2,3}]],_,StrongGenSet[Range@rank,GenSet[Cycles[Range@rank]]]];
(* define it *)
DefTensor[tens@@inds,BaseOfVBundle[bundle],sym,PrintAs->pa];
(* covariantly constant *)
cd=CovDOfMetric[First@MetricsOfVBundle[bundle]];
xTagSetDelayed[{Evaluate[tens],Evaluate[cd[___]@tens[___]]},0];
(* add to list *)
AppendTo[$InvariantTraceTensors,tens];
InvariantTraceTensorQ[tens]^:=True;
tens
];


(* ::Input::Initialization:: *)
InvariantTraceTensor[bundle_?VBundleQ,n_Integer?Positive,sym_:Null]:=Catch@Module[{},
If[(sym=!=Null)&&(n=!=3),Throw@Message[InvariantTraceTensor::sym1,n]];
Switch[n,
1,Zero,
2,MetricsOfVBundle[bundle][[{1}]],
3,Switch[sym,Symmetric,defInvTrTensor[bundle,3,Symmetric],Antisymmetric,defInvTrTensor[bundle,3,Antisymmetric],_,Throw@Message[InvariantTraceTensor::sym2,sym]],
_,defInvTrTensor[bundle,n,Null]
]
];
SetNumberOfArguments[InvariantTraceTensor,{2,3}];
Protect[InvariantTraceTensor];


(* ::Input::Initialization:: *)
$StructureConstantSign=I;


(* ::Input::Initialization:: *)
ReduceInvariantTraceTensors[expr_]:=ReduceInvariantTraceTensors[expr,$InvariantTraceTensors];
ReduceInvariantTraceTensors[expr_,tens_Symbol]:=ReduceInvariantTraceTensors[expr,{tens}];
ReduceInvariantTraceTensors[expr_,list_List]:=Module[{tenslist},
(* check that all tensors in the list are indeed invariant tensors *)
tenslist=Select[list,(!MemberQ[$InvariantTraceTensors,#])&];
If[Length[tenslist]>0,Throw@Message[ReduceInvariantTraceTensors::unknown,"invariant tensor",First@tenslist]];
(* find all tensors who appear in the expression *)
tenslist=Select[list,MemberQ[expr,#,{0,Infinity},Heads->True]&];
(* internal function for the replacement *)
RITT[Expand[expr],tenslist]
];
SetNumberOfArguments[ReduceInvariantTraceTensors,{1,2}];
Protect[ReduceInvariantTraceTensors];

RITT[expr_,tenslist_List]:=Module[{tens,invtens,invt,bundle,invf,reps={},i,i1,i2,j1,j2,m},
(* create replacement rules *)
For[i=1,i<=Length[tenslist],i++,
tens=tenslist[[i]];
bundle=First@SlotsOfTensor[tens];
invf=InvariantTraceTensor[bundle,3,Antisymmetric];
(* special cases for f and d due to their symmetry properties at definition time *)
If[SymmetryGroupOfTensor[tens]===StrongGenSet[{1,2,3},GenSet[-Cycles[{1,2}],-Cycles[{2,3}]]],
(* f tensor: we replace f_{ijm} f_{klm} by - 4 {{1,3},{2,4}}_{ijkl} (for $StructureConstantSign=I) *)
invtens=InvariantTraceTensor[bundle,4];
AppendTo[reps,inject[{invt->invtens},tens[i1___,m_,i2___]tens[j1___,-m_,j2___]:>1/$StructureConstantSign(-1)^(1+Length[{i1}]+Length[{j1}])Module[{inds={i1,i2,j1,j2}},
invt@@(inds)-invt@@(inds[[{1,2,4,3}]])-invt@@(inds[[{1,3,4,2}]])+invt@@(inds[[{1,4,3,2}]])]]];
Continue[];
];
If[SymmetryGroupOfTensor[tens]===StrongGenSet[{1,2,3},GenSet[Cycles[{1,2}],Cycles[{2,3}]]],
(* d tensor: we replace d_{ijm} f_{klm} by - 4 I {{1,2},{3},{4}}_{ijkl} (for $StructureConstantSign=I) *)
invtens=InvariantTraceTensor[bundle,4];
AppendTo[reps,inject[{invt->invtens},tens[i1___,m_,i2___]invf[j1___,-m_,j2___]:>I/$StructureConstantSign(-1)^(1+Length[{j1}])Module[{inds={i1,i2,j1,j2}},
invt@@(inds)-invt@@(inds[[{1,2,4,3}]])+invt@@(inds[[{1,3,4,2}]])-invt@@(inds[[{1,4,3,2}]])]]];
AppendTo[reps,inject[{invt->invtens},tens[i1___,-m_,i2___]invf[j1___,m_,j2___]:>I/$StructureConstantSign(-1)^(1+Length[{j1}])Module[{inds={i1,i2,j1,j2}},
invt@@(inds)-invt@@(inds[[{1,2,4,3}]])+invt@@(inds[[{1,3,4,2}]])-invt@@(inds[[{1,4,3,2}]])]]];
Continue[];
];
(* other tensors *)
invtens=InvariantTraceTensor[bundle,Length[SlotsOfTensor[tens]]+1];
AppendTo[reps,inject[{invt->invtens},tens[i1___,m_,i2___]invf[j1___,-m_,j2___]:>1/$StructureConstantSign (-1)^(Length[{j1}])(invt[i1,j1,j2,i2]-invt[i1,Sequence@@Reverse[List[j1,j2]],i2])]];
AppendTo[reps,inject[{invt->invtens},tens[i1___,-m_,i2___]invf[j1___,m_,j2___]:>1/$StructureConstantSign (-1)^(Length[{j1}])(invt[i1,j1,j2,i2]-invt[i1,Sequence@@Reverse[List[j1,j2]],i2])]];
];
reps=Dispatch[reps];
expr/.reps
];


(* ::Input::Initialization:: *)
(****************************** 2.3 Functions extended to work with more than one bundle ******************************)


(* ::Input::Initialization:: *)
Options[BundleSymmetryOf]={Sorted->True,Offset->False};
BundleSymmetryOf[expr_,OptionsPattern[]]:=Module[{i,sym,indslist,indssorted,slotreps,sortedgenset,bundleindscount,symset},
sym=SymmetryOf[expr];
indslist=Function[{#[[1]],#[[2]],VBundleOfIndex[#[[2]]]}]/@sym[[3]];
(* Sort indices by bundle *)
indssorted=SortBy[indslist,Last];
slotreps=Table[Rule[indssorted[[i,1]],xAct`xTensor`Private`slot[i]],{i,1,Length[indssorted]}];
sortedgenset=sym[[4]]/.(slotreps/.{xAct`xTensor`Private`slot[ii_]:>ii});
(* Drop all indices from generating sets which do not belong to the bundle *)
bundleindscount=Function[{#[[1,3]],#[[2]]}]/@Tally[indssorted,(Last@#1===Last@#2)&];
symset=Table[With[{kmin=1+Plus@@(Last/@bundleindscount[[1;;i-1]]),kmax=Plus@@(Last/@bundleindscount[[1;;i]])},{bundleindscount[[i,1]],StrongGenSet[(sortedgenset[[1]]/.{k_Integer:>Sequence[]/;(k<kmin||k>kmax)}),Select[sortedgenset[[2]],Function[!MemberQ[#,k_Integer/;(k<kmin||k>kmax)&&k!=-1,Infinity]]]]}],{i,1,Length[bundleindscount]}];
(* Use offset for the generating set if specified *)
If[TrueQ@OptionValue[Offset],symset=Table[With[{sset=symset[[i]],offset=Plus@@(Last/@bundleindscount[[1;;i-1]])},{sset[[1]],offset,(sset[[2]]/.{k_Integer:>k-offset/;k!=-1})}],{i,1,Length[bundleindscount]}]];
(* Return result *)
indssorted=sym[[3]]/.slotreps;
Symmetry[bundleindscount,(sym[[2]]/.slotreps),If[TrueQ@OptionValue[Sorted],SortBy[indssorted,(First@#)&],indssorted],symset]
];
SetNumberOfArguments[BundleSymmetryOf,{1,Infinity}];
Protect[BundleSymmetryOf];


(* ::Input::Initialization:: *)
(****************************** 2.4 Noncommutative product, Grassmann-even and -odd tensors ******************************)


(* ::Input::Initialization:: *)
DefProduct[CenterDot,
AssociativeProductQ->True,
CommutativityOfProduct->"SuperCommutative",
GradedProductQ->True,
IdentityElementOfProduct->1,
ScalarsOfProduct->(SameQ[Grade[#,CenterDot],0]&),
DefInfo->Null
];
CenterDot/:GradeOfProduct[Times,CenterDot]=0;
CenterDot/:der_?CovDQ[i___][Verbatim[CenterDot][l_,r___]]:=If[FirstDerQ[der[i]],CenterDot[der[i][l],r]+CenterDot[l,der[i][CenterDot[r]]],SymmetrizeCovDs[With[{$AutoSymmetrizeCovDs=False},Symmetrize[Fold[der[#2][#1]&,CenterDot[l,r],{i}],{i}]]]];
CenterDot/:Grade[sum_Plus,CenterDot]:= With[{glist=Union[Mod[Grade[#,CenterDot],2]&/@List@@sum]},If[xAct`xTensor`Private`checkLengthOneGrade[glist],First[glist]]];
Protect[CenterDot];

Unprotect[Dagger];
Dagger[expr_CenterDot]:=Dagger/@Reverse[expr];
Protect[Dagger];


(* ::Input::Initialization:: *)
Parity[expr_]:=Mod[Grade[expr,CenterDot],2];
Protect[Parity];


(* ::Input::Initialization:: *)
TimesToCenterDot[expr_]:=With[{expr2=Expand[expr]},If[Head[expr2]===Times,CenterDot@@Map[TimesToCenterDot,expr2],Map[TimesToCenterDot,expr2]]]
Protect[TimesToCenterDot];


(* ::Input::Initialization:: *)
$CenterDotTexSymbol=" ";
xAct`TexAct`Tex[Verbatim[CenterDot][x_,y___]]:=xAct`TexAct`Tex[x]<>xAct`TexAct`Tex[$CenterDotTexSymbol]<>xAct`TexAct`Tex[CenterDot[y]]


(* ::Input::Initialization:: *)
DefOddTensor[tens_,mani_,options:OptionsPattern[{DefTensor}]]:=DefTensor[tens,mani,Flatten[{options,GradeOfTensor->{CenterDot->1}}]];
DefOddTensor[tens_,mani_,sym_,options:OptionsPattern[{DefTensor}]]:=DefTensor[tens,mani,sym,Flatten[{options,GradeOfTensor->{CenterDot->1}}]];
DefEvenTensor[tens_,mani_,options:OptionsPattern[{DefTensor}]]:=DefTensor[tens,mani,Flatten[{options,GradeOfTensor->{CenterDot->0}}]];
DefEvenTensor[tens_,mani_,sym_,options:OptionsPattern[{DefTensor}]]:=DefTensor[tens,mani,sym,Flatten[{options,GradeOfTensor->{CenterDot->0}}]];
SetNumberOfArguments[DefOddTensor,{2,Infinity}];
SetNumberOfArguments[DefEvenTensor,{2,Infinity}];
Protect[DefEvenTensor,DefOddTensor];


(* ::Input::Initialization:: *)
(****************************** 2.5 Frame bundles and spin connections ******************************)


(* ::Input::Initialization:: *)
FrameBundleQ[bundle_?VBundleQ]:=(bundle===Symbol["Frame"<>SymbolName@BaseOfVBundle[bundle]])
FrameBundleQ[_]:=False;
SetNumberOfArguments[FrameBundleQ,1];
Protect[FrameBundleQ];


(* ::Input::Initialization:: *)
Options[DefFrameBundle]={PrintAs->{},ProtectNewSymbol:>$ProtectNewSymbols};
DefFrameBundle[frame_Symbol[-mu_,aa_],eta_Symbol[-a_,-b_],inds_List,OptionsPattern[]]:=Catch@Module[{tbundle,man,met,cd,fbundle,detframe,epsframe,epsinds,pa,nu,rho,c,d,i,j,k,tsym,fsym,ccsym,dsym},
(* check that mu belongs to a valid tangent bundle with metric and that no spin bundle has been defined *)
If[!AbstractIndexQ[mu],Throw@Message[DefFrameBundle::unknown,"abstract index",mu]];
If[!MemberQ[inds,aa],Throw@Message[DefFrameBundle::elmntavl,"index",aa,"indices",inds]];
If[!MemberQ[inds,a],Throw@Message[DefFrameBundle::elmntavl,"index",a,"indices",inds]];
If[!MemberQ[inds,b],Throw@Message[DefFrameBundle::elmntavl,"index",b,"indices",inds]];
tbundle=VBundleOfIndex[mu];
man=BaseOfVBundle[tbundle];
If[Tangent[man]=!=tbundle,Throw@Message[DefFrameBundle::notan,mu]];
If[!MetricEndowedQ[tbundle],Throw@Message[DefFrameBundle::nomet,tbundle]];
If[SpinBundleQ[Symbol["Spin"<>SymbolName[man]]],Throw@Message[DefFrameBundle::error,"Cannot define frame bundle if a spin structure is already defined."]];
(* validate symbols *)
ValidateSymbol[frame];
ValidateSymbolInSession[frame];
detframe=Symbol["Det"<>SymbolName[frame]];
ValidateSymbol@Evaluate[detframe];
ValidateSymbolInSession@Evaluate[detframe];
ValidateSymbol[eta];
ValidateSymbolInSession[eta];
met=First@MetricsOfVBundle[tbundle];
cd=CovDOfMetric[met];
If[xAct`xTensor`Private`FrozenMetricQ[met],Throw@Message[DefFrameBundle::error,"A tangent bundle with frozen metric cannot be used."]];
pa=OptionValue[PrintAs];
If[Head[pa]=!=List,Throw@Message[DefFrameBundle::error,"PrintAs option must be a list with two elements."]];
If[(Length[pa]=!=0)&&(Length[pa]=!=2),Throw@Message[DefFrameBundle::error,"PrintAs option must be a list with two elements."]];
(* define the frame bundle and frame field *)
fbundle=Symbol["Frame"<>SymbolName[man]];
DefVBundleWithMetric[fbundle,man,DimOfVBundle[tbundle],inds,eta,PrintAs->("\[DoubleStruckCapitalF]"<>SymbolName[man])];
xUpSet[SignDetOfMetric[eta],SignDetOfMetric[met]];
DefTensor[frame[-mu,a],man,Master->eta,ProtectNewSymbol->False,DefInfo:>If[$DefInfoQ===False,False,{"frame field",""}],PrintAs->If[Length[pa]>0,pa[[1]],Identity]];
DefTensor[detframe[],man,Master->frame,ProtectNewSymbol->False,WeightOfTensor->AIndex,DefInfo:>If[$DefInfoQ===False,False,{"weight +1 density","Determinant."}],PrintAs->If[Length[pa]>0,pa[[1]],Identity]];
If[Length[pa]>0,
inject[{fsym->eta},PrintAs[fsym]^=pa[[2]]];
];
xTagSet[{fbundle,FrameFieldOfBundle[tbundle,fbundle]},frame];
(* soldering relations *)
xTagSetDelayed[{frame,frame[nu_,c_]frame[rho_,-c_]},met[nu,rho]];
xTagSetDelayed[{frame,frame[nu_,c_]frame[-nu_,d_]},eta[c,d]];
(* epsilon tensor *)
eta/:epsilonOrientation[eta,AIndex]:=$epsilonSign;
epsframe=GiveSymbol[epsilon,eta];
epsinds=GetIndicesOfVBundle[fbundle,If[IntegerQ[DimOfVBundle[fbundle]],DimOfVBundle[fbundle],2]];
DefTensor[epsframe@@epsinds,man,Antisymmetric[Range@Length@epsinds],PrintAs:>GiveOutputString[epsilon,eta],ProtectNewSymbol->False,Master->eta,TensorID->{epsilon,eta}];
If[!IntegerQ[DimOfVBundle[fbundle]],
Evaluate[epsframe]/:SymmetryGroupOfTensor[epsframe[i__]]:=Antisymmetric[Range@Length@i];
Evaluate[epsframe]/:SymmetryGroupOfTensor[epsframe]=.;
Evaluate[epsframe]/:SymmetryGroupOfTensor[epsframe]:=Antisymmetric[Range@DimOfVBundle@fbundle];
];
Evaluate[epsframe]/:epsframe[inds1__]epsframe[inds2__]:=SignDetOfMetric[eta]ExpandGdelta[Gdelta[inds1,inds2]];
(* covariantly constant *)
Evaluate[frame]/:TensorDerivative[frame,cd,i___]:=Zero;
Evaluate[detframe]/:TensorDerivative[detframe,cd,i___]:=Zero;
Evaluate[eta]/:TensorDerivative[eta,cd,i___]:=Zero;
Evaluate[epsframe]/:TensorDerivative[epsframe,cd,i___]:=Zero;
xTagSetDelayed[{frame,cd[i__]@frame[j__]},0];
xTagSetDelayed[{detframe,cd[i__]@detframe[]},0];
xTagSetDelayed[{epsframe,cd[i__]@epsframe[j__]},0];
(* general first derivatives *)
inject[{tsym->tbundle,fsym->fbundle,ccsym->frame},xTagSetDelayed[{ccsym,(d_?FirstDerQ)@ccsym[nu_?UpIndexQ,c_]},With[{r=DummyIn[tsym],e=DummyIn[fsym]},-ccsym[nu,-e]ccsym[r,c]d[ccsym[-r,e]]]]];
inject[{tsym->tbundle,fsym->fbundle,ccsym->frame,dsym->detframe},xTagSetDelayed[{dsym,(d_?FirstDerQ)@dsym[]},With[{r=DummyIn[tsym],e=DummyIn[fsym]},dsym[]ccsym[r,-e]d[ccsym[-r,e]]]]];
(* Perturbation depends on the index structure *)
inject[{tsym->tbundle,fsym->fbundle,ccsym->frame},xAct`xPert`Private`ExpandPerturbation1[Perturbation[ccsym[nu_?UpIndexQ,c_],Optional[order_Integer,1]],options___]:=If[order==0,ccsym[nu,c],ExpandPerturbation[Perturbation[With[{r=DummyIn[tsym],e=DummyIn[fsym]},-ccsym[nu,-e]ccsym[r,c]Perturbation[ccsym[-r,e],1]],order-1],options]]];
inject[{tsym->eta,fsym->fbundle,ccsym->frame},xAct`xPert`Private`ExpandPerturbation1[Perturbation[ccsym[nu_,c_?DownIndexQ],Optional[order_Integer,1]],options___]:=If[order==0,ccsym[nu,c],ExpandPerturbation[Perturbation[With[{e=DummyIn[fsym]},tsym[c,-e]Perturbation[ccsym[nu,e],1]],order-1],options]]];
inject[{tsym->tbundle,fsym->fbundle,ccsym->frame,dsym->detframe},xAct`xPert`Private`ExpandPerturbation1[Perturbation[dsym[],Optional[order_Integer,1]],options___]:=If[order==0,dsym[],ExpandPerturbation[Perturbation[With[{r=DummyIn[tsym],e=DummyIn[fsym]},dsym[]ccsym[r,-e]Perturbation[ccsym[-r,e],1]],order-1],options]]];
Evaluate[eta]/:Perturbation[eta[c_,d_],Optional[order_Integer,1]]:=If[order==0,eta[c,d],0];
Evaluate[epsframe]/:Perturbation[epsframe[inds1__],Optional[order_Integer,1]]:=If[order==0,epsframe[inds1],0];
(* protect symbols *)
If[TrueQ@OptionValue[ProtectNewSymbol],Protect[frame,detframe,eta,epsframe];];
];
SetNumberOfArguments[DefFrameBundle,{3,Infinity}];
Protect[DefFrameBundle];


(* ::Input::Initialization:: *)
UndefFrameBundle[frame_Symbol]:=Catch@Module[{fbundle,sbundle,cd},
If[Length@SlotsOfTensor[frame]=!=2,Throw@Message[UndefFrameBundle::unknown,"frame field",frame]];
fbundle=SlotsOfTensor[frame][[2]];
If[!FrameBundleQ[fbundle],Throw@Message[UndefFrameBundle::unknown,"frame bundle",fbundle]];
(* check that the corresponding spin bundle is undefined, if it exists *)
sbundle=Symbol["Spin"<>SymbolName[BaseOfVBundle[fbundle]]];
If[SpinBundleQ[sbundle],Throw@Message[UndefFrameBundle::error,"Spin bundle "<>ToString@sbundle<>" must be undefined first."]];
(* check that spin connections are undefined *)
If[MemberQ[Map[-Last@SlotsOfTensor[#]&,$SpinConnections],fbundle],Throw@Message[UndefFrameBundle::error,"Spin connection "<>ToString@FirstCase[Map[{#,-Last@SlotsOfTensor[#]}&,$SpinConnections],{cd_,fbundle}->cd]<>" must be undefined first."]];
cd=CovDOfMetric@First@MetricsOfVBundle[fbundle];
(* remove associated symbols from covariant derivative *)
VBundlesOfCovD[cd]^=DeleteCases[VBundlesOfCovD[cd],fbundle];
(* undefine objects *)
UndefVBundle[fbundle];
];


(* ::Input::Initialization:: *)
FrameFieldOfBundle[tb_?VBundleQ,fb_?VBundleQ]:=Catch@Module[{},
If[Tangent[BaseOfVBundle[tb]]=!=tb,Throw@Message[FrameFieldOfBundle::invalid,tb,"tangent bundle"];];
If[!FrameBundleQ[fb],Throw@Message[FrameFieldOfBundle::invalid,fb,"frame bundle"];];
If[BaseOfVBundle[tb]=!=BaseOfVBundle[fb],Throw@Message[FrameFieldOfBundle::error,"Bundles "<>SymbolName[tb]<>" and "<>SymbolName[fb]<>" must have the same base manifold."]];
Return[];
];
FrameFieldOfBundle[_,_]:=Null;
SetNumberOfArguments[FrameFieldOfBundle,2];
Protect[FrameFieldOfBundle];


(* ::Input::Initialization:: *)
CovDOfSpinConnection[_]:=Null;
SetNumberOfArguments[CovDOfSpinConnection,1];
Protect[CovDOfSpinConnection];
$SpinConnections={};


(* ::Input::Initialization:: *)
Options[DefSpinConnection]={PrintAs->Identity,CurvatureRelations->True,ProtectNewSymbol:>$ProtectNewSymbols};
DefSpinConnection[conn_Symbol[-mu_,-a_,-b_],cd_?CovDQ,OptionsPattern[]]:=Catch@Module[{tbundle,fbundle,sbundle,frame,tors,contors,contorscd,riem,ric,ricscal,rpa,nu,rho,achris,fbsym,sbsym,gamsym,tq,tbsym,tsym,frsym},
(* check that mu belongs to a valid tangent bundle with metric and a,b to the corresponding frame bundle *)
If[!AbstractIndexQ[mu],Throw@Message[DefSpinConnection::unknown,"abstract index",mu]];
If[!AbstractIndexQ[a],Throw@Message[DefSpinConnection::unknown,"abstract index",a]];
If[!AbstractIndexQ[b],Throw@Message[DefSpinConnection::unknown,"abstract index",b]];
tbundle=VBundleOfIndex[mu];
fbundle=VBundleOfIndex[a];
If[fbundle=!=VBundleOfIndex[b],Throw@Message[DefMetric::inds,a,b]];
If[First@VBundlesOfCovD[cd]=!=tbundle,Throw@Message[DefSpinConnection::error,"Covariant derivative must be defined on the tangent bundle "<>ToString[tbundle]<>"."]];
frame=FrameFieldOfBundle[tbundle,fbundle];
riem=Symbol["Riemann"<>SymbolName[conn]];
ric=Symbol["Ricci"<>SymbolName[conn]];
ricscal=Symbol["RicciScalar"<>SymbolName[conn]];
(* validate symbols *)
Map[ValidateSymbol,{conn,riem,ric,ricscal}];
Map[ValidateSymbolInSession,{conn,riem,ric,ricscal}];
If[TorsionQ[cd],
tors=Symbol["Torsion"<>SymbolName[conn]];
contors=Symbol["Contortion"<>SymbolName[conn]];
contorscd=Symbol["Contortion"<>SymbolName[cd]];
Map[ValidateSymbol,{tors,contors,contorscd}];
Map[ValidateSymbolInSession,{tors,contors,contorscd}];
];
(* define connection, curvature and possibly torsion *)
nu=DummyIn@tbundle;
rho=DummyIn@tbundle;
rpa=If[OptionValue[PrintAs]===Identity,"R["<>SymbolName[conn]<>"]","R["<>OptionValue[PrintAs]<>"]"];
DefTensor[conn[-mu,-a,-b],BaseOfVBundle@tbundle,Antisymmetric[{2,3}],PrintAs->OptionValue[PrintAs],ProtectNewSymbol->False,DefInfo:>If[$DefInfoQ===False,False,{"spin connection",""}]];
Evaluate[conn]/:CovDOfSpinConnection[conn]=cd;
Evaluate[conn]/:TorsionQ[conn]=TorsionQ[cd];
AppendTo[$SpinConnections,conn];
DefTensor[riem[-mu,-nu,-a,-b],BaseOfVBundle@tbundle,GenSet[-Cycles[{1,2}],-Cycles[{3,4}]],Master->conn,PrintAs->rpa,ProtectNewSymbol->False,DefInfo:>If[$DefInfoQ===False,False,{"Riemann curvature tensor",""}],TensorID->{Riemann,conn}];
DefTensor[ric[-mu,-a],BaseOfVBundle@tbundle,Master->conn,PrintAs->rpa,ProtectNewSymbol->False,DefInfo:>If[$DefInfoQ===False,False,{"Ricci curvature tensor",""}],TensorID->{Ricci,conn}];
DefTensor[ricscal[],BaseOfVBundle@tbundle,Master->conn,PrintAs->rpa,ProtectNewSymbol->False,DefInfo:>If[$DefInfoQ===False,False,{"Ricci curvature scalar",""}],TensorID->{RicciScalar,conn}];
If[TorsionQ[cd],
DefTensor[tors[-mu,-nu,a],BaseOfVBundle@tbundle,GenSet[-Cycles[{1,2}]],Master->conn,PrintAs->If[OptionValue[PrintAs]===Identity,"T["<>SymbolName[conn]<>"]","T["<>OptionValue[PrintAs]<>"]"],ProtectNewSymbol->False,DefInfo:>If[$DefInfoQ===False,False,{"Torsion tensor",""}],TensorID->{Torsion,conn}];
DefTensor[contors[-mu,-nu,-rho],BaseOfVBundle@tbundle,GenSet[-Cycles[{2,3}]],Master->conn,PrintAs->If[OptionValue[PrintAs]===Identity,"K["<>SymbolName[conn]<>"]","K["<>OptionValue[PrintAs]<>"]"],ProtectNewSymbol->False,DefInfo:>If[$DefInfoQ===False,False,{"Contortion tensor",""}],TensorID->{Contortion,conn}];
DefTensor[contorscd[-mu,-nu,-rho],BaseOfVBundle@tbundle,GenSet[-Cycles[{1,2}]],Master->cd,PrintAs->"K["<>SymbolOfCovD[cd][[2]]<>"]",ProtectNewSymbol->False,DefInfo:>If[$DefInfoQ===False,False,{"Contortion tensor",""}],TensorID->{Contortion,cd}];
];
(* christoffel of frame bundle and spin connection *)
xTagSet[{cd,CurvatureQ[cd,fbundle]},True];
VBundlesOfCovD[cd]^=DeleteDuplicates@Join[VBundlesOfCovD[cd],{fbundle}];
If[!xTensorQ[GiveSymbol[AChristoffel,cd]],xAct`xTensor`Private`defcovdFiber[cd,tbundle,fbundle,CurvatureQ[cd],$DefInfoQ]];
inject[{achris->Symbol["AChristoffel"<>SymbolName[cd]],fbsym->fbundle},achris[i_?UpIndexQ,j_?DownIndexQ,k_?DownIndexQ]/;(VBundleOfIndex[i]===fbsym):=conn[j,i,k]];
inject[{achris->Symbol["FRiemann"<>SymbolName[cd]],fbsym->fbundle,gamsym->Symbol["Riemann"<>SymbolName[conn]]},achris[nu_,rho_,i_,j_]/;(VBundleOfIndex[i]===fbsym):=gamsym[nu,rho,i,j]];
(* christoffel of spin connection *)
sbundle=Symbol["Spin"<>SymbolName[BaseOfVBundle@tbundle]];
If[SpinBundleQ[sbundle],
inject[{achris->Symbol["AChristoffel"<>SymbolName[cd]],fbsym->fbundle,sbsym->sbundle,gamsym->GammaMatrix[First@MetricsOfVBundle[fbundle],2]},achris[i_?UpIndexQ,j_?DownIndexQ,k_?DownIndexQ]/;(VBundleOfIndex[i]===sbsym):=With[{aa=DummyIn@fbsym,bb=DummyIn@fbsym},-1/4conn[j,-aa,-bb]gamsym[aa,bb,k,i]]];
];
(* christoffel of levi-civita connection *)
If[TorsionQ[cd],
With[{chrissym=GiveSymbol[Christoffel,cd,LC@MetricOfCovD[cd]]},
If[!xTensorQ[chrissym],xAct`xTensor`Private`defChristoffel[chrissym,{tbundle,tbundle},{Christoffel,cd,LC@MetricOfCovD[cd]}]];
inject[{gamsym->contorscd},chrissym[i_,j_,k_]:=-$TorsionSign gamsym[i,j,k]];
]
];
(* rules for contractions *)
Evaluate[conn]/:CurvatureRelations[conn,Riemann]=MakeRule@Evaluate[{riem[-mu,-nu,-a,-b]frame[mu,a],$RicciSign ric[-nu,-b]},MetricOn->All];
If[OptionValue[CurvatureRelations],
If[$DefInfoQ,Print["** DefSpinConnection: Contractions of Riemann automatically replaced by Ricci."];];
AutomaticRules[riem,CurvatureRelations[conn,Riemann],Verbose->False];
];
Evaluate[conn]/:CurvatureRelations[conn,Ricci]=MakeRule@Evaluate[{ric[-mu,-a]frame[mu,a],ricscal[]},MetricOn->All];
If[OptionValue[CurvatureRelations],
If[$DefInfoQ,Print["** DefSpinConnection: Contractions of Ricci automatically replaced by RicciScalar."];];
AutomaticRules[ric,CurvatureRelations[conn,Ricci],Verbose->False];
];
Evaluate[conn]/:CurvatureRelations[conn]=Join[CurvatureRelations[conn,Riemann],CurvatureRelations[conn,Ricci]];
(* TODO: Riemann Young projections *)
(*inject[{gamsym\[Rule]conn},RiemannYoungProject[expr_,gamsym]:=expr/.RiemannYoungRule[gamsym]];*)
(* rules for variation of curvature tensors *)
inject[{achris->riem,sbsym->cd,gamsym->conn,tq->TorsionQ[cd],tsym->tors,tbsym->tbundle,fbsym->fbundle,frsym->frame},xAct`xPert`Private`ExpandPerturbation1[Perturbation[achris[nu_?DownIndexQ,rho_?DownIndexQ,c_?DownIndexQ,d_?DownIndexQ],Optional[order_Integer,1]],options___]:=If[order==0,achris[nu,rho,c,d],ExpandPerturbation[Perturbation[With[{tau=DummyIn[tbsym],f=DummyIn@fbundle},sbsym[nu]@Perturbation[gamsym[rho,c,d],1]-sbsym[rho]@Perturbation[gamsym[nu,c,d],1]+If[tq,tsym[nu,rho,f]frsym[tau,-f]Perturbation[gamsym[-tau,c,d],1],0]],order-1],options]]];
inject[{achris->ric,tsym->riem,tbsym->tbundle,fbsym->fbundle,frsym->frame},xAct`xPert`Private`ExpandPerturbation1[Perturbation[achris[nu_?DownIndexQ,c_?DownIndexQ],Optional[order_Integer,1]],options___]:=If[order==0,achris[nu,c],ExpandPerturbation[Perturbation[With[{tau=DummyIn[tbsym],f=DummyIn@fbundle},Perturbation[tsym[nu,-tau,c,-f],1]frsym[tau,f]+tsym[nu,-tau,c,-f]Perturbation[frsym[tau,f],1]],order-1],options]]];
inject[{achris->ricscal,tsym->ric,tbsym->tbundle,fbsym->fbundle,frsym->frame},xAct`xPert`Private`ExpandPerturbation1[Perturbation[achris[],Optional[order_Integer,1]],options___]:=If[order==0,achris[],ExpandPerturbation[Perturbation[With[{tau=DummyIn[tbsym],f=DummyIn@fbundle},Perturbation[tsym[-tau,-f],1]frsym[tau,f]+tsym[-tau,-f]Perturbation[frsym[tau,f],1]],order-1],options]]];
(* convert curvature tensors *)
tq={};
inject[{achris->Riemann[cd],tsym->riem,fbsym->fbundle,frsym->frame},AppendTo[tq,achris[i1_,i2_,i3_,i4_]:>With[{aa=DummyIn@fbsym,bb=DummyIn@fbsym},tsym[i1,i2,aa,bb]frsym[i3,-aa]frsym[i4,-bb]]]];
inject[{achris->Ricci[cd],tsym->ric,fbsym->fbundle,frsym->frame},AppendTo[tq,achris[i1_,i2_]:>With[{aa=DummyIn@fbsym},tsym[i1,aa]frsym[i2,-aa]]]];
inject[{achris->RicciScalar[cd],tsym->ricscal},AppendTo[tq,achris[]:>tsym[]]];
inject[{gamsym->conn,sbsym->cd,fbsym->tq},gamsym/:ChangeCurvature[expr_,sbsym,gamsym]:=expr/.fbsym];
tq={};
inject[{achris->Riemann[cd],tsym->riem,fbsym->tbundle,frsym->frame},AppendTo[tq,tsym[i1_,i2_,i3_,i4_]:>With[{aa=DummyIn@fbsym,bb=DummyIn@fbsym},achris[i1,i2,aa,bb]frsym[-aa,i3]frsym[-bb,i4]]]];
inject[{achris->Ricci[cd],tsym->ric,fbsym->tbundle,frsym->frame},AppendTo[tq,tsym[i1_,i2_]:>With[{aa=DummyIn@fbsym},achris[i1,aa]frsym[-aa,i2]]]];
inject[{achris->RicciScalar[cd],tsym->ricscal},AppendTo[tq,tsym[]:>achris[]]];
inject[{gamsym->conn,sbsym->cd,fbsym->tq},gamsym/:ChangeCurvature[expr_,gamsym,sbsym]:=expr/.fbsym];
tq={};
inject[{achris->riem,tsym->conn,tbsym->tbundle,fbsym->fbundle,gamsym->First@MetricsOfVBundle[tbundle]},AppendTo[tq,achris[i1_,i2_,i3_,i4_]:>With[{aa=DummyIn@fbsym,mm=DummyIn@tbsym,nn=DummyIn@tbsym},gamsym[i1,mm]gamsym[i2,nn](PD[-mm]@tsym[-nn,i3,i4]-PD[-nn]@tsym[-mm,i3,i4]+tsym[-mm,i3,aa]tsym[-nn,-aa,i4]-tsym[-nn,i3,aa]tsym[-mm,-aa,i4])]]];
inject[{achris->ric,tsym->conn,tbsym->tbundle,fbsym->fbundle,gamsym->First@MetricsOfVBundle[tbundle],frsym->frame},AppendTo[tq,achris[i1_,i3_]:>With[{aa=DummyIn@fbsym,bb=DummyIn@fbsym,mm=DummyIn@tbsym,nn=DummyIn@tbsym},frsym[nn,bb]gamsym[i1,mm](PD[-mm]@tsym[-nn,i3,-bb]-PD[-nn]@tsym[-mm,i3,-bb]+tsym[-mm,i3,aa]tsym[-nn,-aa,-bb]-tsym[-nn,i3,aa]tsym[-mm,-aa,-bb])]]];
inject[{achris->ricscal,tsym->conn,tbsym->tbundle,fbsym->fbundle,gamsym->First@MetricsOfVBundle[tbundle],frsym->frame},AppendTo[tq,achris[]:>With[{aa=DummyIn@fbsym,bb=DummyIn@fbsym,cc=DummyIn@fbsym,mm=DummyIn@tbsym,nn=DummyIn@tbsym},frsym[nn,bb]frsym[mm,cc](PD[-mm]@tsym[-nn,-cc,-bb]-PD[-nn]@tsym[-mm,-cc,-bb]+tsym[-mm,-cc,aa]tsym[-nn,-aa,-bb]-tsym[-nn,-cc,aa]tsym[-mm,-aa,-bb])]]];
inject[{gamsym->conn,fbsym->tq},gamsym/:ChangeCurvature[expr_,gamsym,PD]:=expr/.fbsym];
(* convert torsion tensors *)
If[TorsionQ[cd],
(* christoffel symbols *)
tq={};
inject[{achris->Torsion[cd],tsym->tors,fbsym->fbundle,frsym->frame},AppendTo[tq,achris[i1_,i2_,i3_]:>With[{aa=DummyIn@fbsym},tsym[i2,i3,aa]frsym[i1,-aa]]]];
inject[{achris->contorscd,tsym->contors},AppendTo[tq,achris[i1_,i2_,i3_]:>tsym[i3,i1,i2]]];
inject[{gamsym->conn,sbsym->cd,fbsym->tq},gamsym/:ChangeTorsion[expr_,sbsym,gamsym]:=expr/.fbsym];
tq={};
inject[{achris->Torsion[cd],tsym->tors,fbsym->tbundle,frsym->frame},AppendTo[tq,tsym[i1_,i2_,i3_]:>With[{aa=DummyIn@fbsym},achris[aa,i1,i2]frsym[-aa,i3]]]];
inject[{achris->contorscd,tsym->contors},AppendTo[tq,tsym[i1_,i2_,i3_]:>achris[i2,i3,i1]]];
inject[{gamsym->conn,sbsym->cd,fbsym->tq},gamsym/:ChangeTorsion[expr_,gamsym,sbsym]:=expr/.fbsym];
(* convert torsion *)
tq={};
inject[{achris->contors,tsym->tors,fbsym->fbundle,frsym->frame},AppendTo[tq,achris[i1_,i2_,i3_]:>With[{aa=DummyIn@fbsym},(tsym[i2,i3,aa]frsym[i1,-aa]-tsym[i1,i2,aa]frsym[i3,-aa]+tsym[i1,i3,aa]frsym[i2,-aa])/2]]];
inject[{gamsym->conn,fbsym->tq},gamsym/:ContortionToTorsion[expr_,gamsym]:=expr/.fbsym];
tq={};
inject[{achris->contorscd,tsym->Torsion[cd]},AppendTo[tq,achris[i1_,i2_,i3_]:>-(tsym[i2,i3,i1]+tsym[i1,i2,i3]+tsym[i3,i2,i1])/2]];
inject[{gamsym->cd,fbsym->tq},gamsym/:ContortionToTorsion[expr_,gamsym]:=expr/.fbsym];
];
(* protect symbols s*)
If[OptionValue[ProtectNewSymbol],Protect[conn,riem,ric,ricscal]];
If[OptionValue[ProtectNewSymbol]&&TorsionQ[cd],Protect[tors,contors,contorscd]];
];
SetNumberOfArguments[DefSpinConnection,{2,Infinity}];
Protect[DefSpinConnection];


(* ::Input::Initialization:: *)
UndefSpinConnection[conn_Symbol]:=Catch@Module[{tbundle,fbundle,sbundle,cd,achris,fbsym,sbsym,gamsym},
If[!MemberQ[$SpinConnections,conn],Throw@Message[UndefSpinConnection::unknown,"spin connection",conn]];
tbundle=-First@SlotsOfTensor[conn];
fbundle=-Last@SlotsOfTensor[conn];
cd=CovDOfSpinConnection[conn];
sbundle=Symbol["Spin"<>SymbolName[BaseOfVBundle@tbundle]];
(* remove definitions for christoffel and curvature *)
inject[{achris->Symbol["AChristoffel"<>SymbolName[cd]],fbsym->fbundle},achris[i_?UpIndexQ,j_?DownIndexQ,k_?DownIndexQ]/;(VBundleOfIndex[i]===fbsym)=.];
inject[{achris->Symbol["FRiemann"<>SymbolName[cd]],fbsym->fbundle,gamsym->Symbol["Riemann"<>SymbolName[conn]]},achris[nu_,rho_,i_,j_]/;(VBundleOfIndex[i]===fbsym)=.];
If[SpinBundleQ[sbundle],
inject[{achris->Symbol["AChristoffel"<>SymbolName[cd]],fbsym->fbundle,sbsym->sbundle,gamsym->GammaMatrix[First@MetricsOfVBundle[fbundle],2]},achris[i_?UpIndexQ,j_?DownIndexQ,k_?DownIndexQ]/;(VBundleOfIndex[i]===sbsym)=.];
];
If[TorsionQ[cd],
inject[{achris->GiveSymbol[Christoffel,cd,LC@MetricOfCovD[cd]]},achris[i_,j_,k_]=.];
];
(* remove perturbation rules *)
inject[{achris->Symbol["Riemann"<>SymbolName[conn]]},xAct`xPert`Private`ExpandPerturbation1[Perturbation[achris[nu_?DownIndexQ,rho_?DownIndexQ,c_?DownIndexQ,d_?DownIndexQ],Optional[order_Integer,1]],options___]=.];
inject[{achris->Symbol["Ricci"<>SymbolName[conn]]},xAct`xPert`Private`ExpandPerturbation1[Perturbation[achris[nu_?DownIndexQ,c_?DownIndexQ],Optional[order_Integer,1]],options___]=.];
inject[{achris->Symbol["RicciScalar"<>SymbolName[conn]]},xAct`xPert`Private`ExpandPerturbation1[Perturbation[achris[],Optional[order_Integer,1]],options___]=.];
(* remove CD definitions *)
Evaluate[cd]/:CurvatureQ[cd,fbundle]=.;
VBundlesOfCovD[cd]^=DeleteCases[VBundlesOfCovD[cd],fbundle];
(* finally undefine the connection, which also removes all associated curvature tensors *)
$SpinConnections=DeleteCases[$SpinConnections,conn];
UndefTensor[conn];
]
SetNumberOfArguments[UndefSpinConnection,1];
Protect[UndefSpinConnection];


(* ::Input::Initialization:: *)
SpinConnectionToFrame[expr_,conns_List]:=Fold[SpinConnectionToFrame,expr,conns]
SpinConnectionToFrame[expr_,conn_Symbol]:=Catch@Module[{cd,tbundle,fbundle,frame,met,tors,contors},
cd=CovDOfSpinConnection[conn];
If[cd===Null,Throw@Message[SpinConnectionToFrame::unknown,"spin connection",conn]];
tbundle=Tangent[BaseOfVBundle@First@VBundlesOfCovD[cd]];
fbundle=Symbol["Frame"<>SymbolName@BaseOfVBundle@First@VBundlesOfCovD[cd]];
frame=FrameFieldOfBundle[tbundle,fbundle];
met=First@MetricsOfVBundle@tbundle;
tors=Symbol["Torsion"<>SymbolName[conn]];
contors=Symbol["Contortion"<>SymbolName[conn]];
With[{cds=cd,tbsym=tbundle,fbsym=fbundle,metsym=met,framesym=frame,tsym=tors,ctsym=contors,tb=TorsionQ[cd]},expr/.{conn[mu_,a_,b_]:>1/2With[{rho=DummyIn@tbsym,sigma=DummyIn@tbsym},framesym[rho,a](PD[mu]@framesym[-rho,b]-PD[-rho]@framesym[mu,b])-framesym[rho,b](PD[mu]@framesym[-rho,a]-PD[-rho]@framesym[mu,a])+metsym[-rho,mu](framesym[sigma,a]PD[-sigma]@framesym[rho,b]-framesym[sigma,b]PD[-sigma]@framesym[rho,a])+2If[tb,framesym[-rho,a]framesym[-sigma,b]contors[mu,rho,sigma],0]],Perturbation[conn[mu_,a_,b_],Optional[order_Integer,1]]:>Perturbation[1/2With[{rho=DummyIn@tbsym,sigma=DummyIn@tbsym,tau=DummyIn@tbsym,c=DummyIn@fbsym,d=DummyIn@fbsym},framesym[rho,a](cds[mu]@Perturbation@framesym[-rho,b]-cds[-rho]@Perturbation@framesym[mu,b])-framesym[rho,b](cds[mu]@Perturbation@framesym[-rho,a]-cds[-rho]@Perturbation@framesym[mu,a])+metsym[-rho,mu](framesym[sigma,a]cds[-sigma]@Perturbation@framesym[rho,b]-framesym[sigma,b]cds[-sigma]@Perturbation@framesym[rho,a])+If[tb,framesym[rho,a]framesym[sigma,b]framesym[mu,-c]Perturbation@tsym[-rho,-sigma,c]-framesym[rho,a]Perturbation@tsym[mu,-rho,b]+framesym[rho,b]Perturbation@tsym[mu,-rho,a]-framesym[sigma,a]framesym[tau,b]tsym[-sigma,-tau,d]framesym[rho,-d]framesym[mu,-c]Perturbation@framesym[-rho,c]+framesym[sigma,a]tsym[mu,-sigma,c]framesym[rho,-c]Perturbation@framesym[-rho,b]-framesym[sigma,b]tsym[mu,-sigma,c]framesym[rho,-c]Perturbation@framesym[-rho,a],0]],order-1]}]
]
SetNumberOfArguments[SpinConnectionToFrame,2];
Protect[SpinConnectionToFrame];


(* ::Input::Initialization:: *)
ContortionToTorsion[expr_,conncd_List]:=Fold[ContortionToTorsion,expr,conncd]
ContortionToTorsion[expr_,conncd_]:=expr
SetNumberOfArguments[ContortionToTorsion,2];
Protect[ContortionToTorsion];


(* ::Input::Initialization:: *)
(****************************** 2.6 Spin structure, \[Gamma] matrices ******************************)


(* ::Input::Initialization:: *)
(*GammaMatrixQ[f_Symbol[inds__]]:=GammaMatrixQ[f];*)
GammaMatrixQ[_]:=False;
(* Check if Gamma matrix is \[Gamma]^* *)
(*GammaStarQ[f_Symbol[inds__]]:=GammaStarQ[f];*)
GammaStarQ[f_Symbol]:=GammaMatrixQ[f]&&f===GammaMatrix[MetricOfGammaMatrix[f],Star];
GammaStarQ[_]:=False;
(* Check if Gamma matrix is \[Gamma]^0 *)
(*GammaZeroQ[f_Symbol[inds__]]:=GammaZeroQ[f];*)
GammaZeroQ[f_Symbol]:=GammaMatrixQ[f]&&f===GammaMatrix[MetricOfGammaMatrix[f],Zero];
GammaZeroQ[_]:=False;

SetNumberOfArguments[GammaMatrixQ,1];
SetNumberOfArguments[GammaStarQ,1];
SetNumberOfArguments[GammaZeroQ,1];
Protect[GammaMatrixQ,GammaStarQ,GammaZeroQ];


(* ::Input::Initialization:: *)
$GammaStarSign=1;


(* ::Input::Initialization:: *)
GammaMatrix[met_?MetricQ,n_Integer?Positive]:=Symbol["Gamma"<>SymbolName[met]<>ToString[n]];
GammaMatrix[met_?MetricQ,Star]:=Symbol["Gamma"<>SymbolName[met]<>"Star"];
GammaMatrix[met_?MetricQ,Zero]:=Symbol["Gamma"<>SymbolName[met]<>"0"];
SetNumberOfArguments[GammaMatrix,2];
Protect[GammaMatrix];


(* ::Input::Initialization:: *)
MetricOfGammaMatrix[_]:=Null;
SetNumberOfArguments[MetricOfGammaMatrix,1];
Protect[MetricOfGammaMatrix];
$GammaMatrices={};


(* ::Input::Initialization:: *)
$PrecomputeGammaMatrixProducts=True;

If[SpinorsPkgLoaded&&SpinorsKeepDefs,
DefGenSpinStructure[met_Symbol,inds_List]:=defSpinStruct[met,inds];
,
DefSpinStructure[met_Symbol,inds_List]:=defSpinStruct[met,inds];
];
defSpinStruct[met_Symbol,inds_List]:=Catch@Module[{funcname,tbundle,man,dimm,sdim,sbundle,cd,fbundle,eucl,i,j,k,l,spininds,gammainds,g0,g1,eta,gf1,gammasym,ccsym,tm,rie,gam,frame,fbsym},
If[SpinorsPkgLoaded&&SpinorsKeepDefs,funcname=DefGenSpinStructure;,funcname=DefSpinStructure;];
(* check that metric is the metric of a tangent bundle, with no inner bundles *)
If[!MetricQ[met],Throw@Message[Evaluate[MessageName[Evaluate@funcname,"unknown"]],"metric",met]];
If[xAct`xTensor`Private`FrozenMetricQ[met],Throw@Message[Evaluate[MessageName[Evaluate@funcname,"error"]],"A frozen metric cannot be used."]];
tbundle=VBundleOfMetric[met];
man=BaseOfVBundle[tbundle];
If[Tangent[man]=!=tbundle,Throw@Message[Evaluate[MessageName[Evaluate@funcname,"error"]],"The metric must be defined on a tangent bundle."]];
cd=CovDOfMetric[met];
(* the frame bundle, if it exists *)
fbundle=Symbol["Frame"<>SymbolName[man]];
If[Length@Complement[VBundlesOfCovD[cd],{fbundle,tbundle}]>0,Throw@Message[Evaluate[MessageName[Evaluate@funcname,"error"]],"The Levi-Civita connection of the metric cannot be defined on inner vector bundles."]];
(* manifold must have integer dimension *)
dimm=DimOfManifold[man];
If[(!IntegerQ[dimm])||(dimm<=0),Throw@Message[Evaluate[MessageName[Evaluate@funcname,"invalid"]],dimm,"positive integer"]];
sdim=2^(If[EvenQ[dimm],dimm,dimm-1]/2);
(* define the spin bundle *)
sbundle=Symbol["Spin"<>SymbolName[man]];
DefVBundle[sbundle,man,sdim,inds,PrintAs->("\[DoubleStruckCapitalS]"<>SymbolName[man])];
(* make it known to the covariant derivative *)
xTagSet[{cd,CurvatureQ[cd,sbundle]},True];
VBundlesOfCovD[cd]^=DeleteDuplicates@Join[VBundlesOfCovD[cd],{sbundle}];
xAct`xTensor`Private`defcovdFiber[cd,tbundle,sbundle,CurvatureQ[cd],$DefInfoQ];
(* define Gamma matrices. *)
(* Currently we only support Clifford algebra s.t. \[Gamma]^\[Mu]\[Gamma]^\[Nu]+\[Gamma]^\[Nu]\[Gamma]^\[Mu]=2g^\[Mu]\[Nu] *)
eucl=(SignDetOfMetric[met]==1);
If[$DefInfoQ,If[eucl,Print["** ",ToString@funcname,": Assuming metric signature (+,...,+)."],Print["** ",ToString@funcname,": Assuming metric signature (-,+,...,+)."]]];
spininds=GetIndicesOfVBundle[sbundle,2];
spininds[[1]]=-spininds[[1]];
(* Define the ordinary \[Gamma] matrix first, all others depend on it. We first declare all \[Gamma]'s as real and fix afterwards. *)
g1=GammaMatrix[met,1];
gammainds=Join[GetIndicesOfVBundle[tbundle,1],spininds];
DefTensor[g1@@gammainds,man,PrintAs->("\[Gamma]["<>PrintAs[met]<>"]"),Dagger->Real,GradeOfTensor->{CenterDot->0}];
AppendTo[$GammaMatrices,g1];
xUpSetDelayed[cd[__]@g1[__],0];
xTagSetDelayed[{g1,g1[__,-k_,k_]},0];
xUpSet[GammaMatrixQ[g1],True];
xUpSet[MetricOfGammaMatrix[g1],met];
(* If we have a frame field, define also the frame \[Gamma] matrices *)
If[FrameBundleQ[fbundle],
eta=First@MetricsOfVBundle[fbundle];
frame=FrameFieldOfBundle[tbundle,fbundle];
gf1=GammaMatrix[eta,1];
gammainds=Join[GetIndicesOfVBundle[fbundle,1],spininds];
DefTensor[gf1@@gammainds,man,PrintAs->("\[Gamma]["<>PrintAs[Evaluate@eta]<>"]"),Dagger->Real,GradeOfTensor->{CenterDot->0}];
AppendTo[$GammaMatrices,gf1];
xUpSetDelayed[cd[__]@gf1[__],0];
xTagSetDelayed[{gf1,gf1[__,-k_,k_]},0];
xUpSet[GammaMatrixQ[gf1],True];
xUpSet[MetricOfGammaMatrix[gf1],eta];
];
(* Perturbation depends on the index structure and whether a frame bundle is defined *)
Unprotect[LeftVarD];
If[FrameBundleQ[fbundle],
xTagSet[{gf1,ImplicitTensorDepQ[gf1,eta]},True];
xTagSet[{g1,ImplicitTensorDepQ[g1,frame]},True];
(* perturbations of frame gamma matrices *)
inject[{gam->gf1,ccsym->eta,fbsym->fbundle},xAct`xPert`Private`ExpandPerturbation1[Perturbation[gam[i_?DownIndexQ,j_,k_],Optional[order_Integer,1]],options___]:=If[order==0,gam[i,j,k],ExpandPerturbation[Perturbation[With[{a=DummyIn[fbsym]},ccsym[i,-a]Perturbation[gam[a,j,k],1]],order-1],options]]];
inject[{gam->gf1,ccsym->eta,fbsym->fbundle},LeftVarD[ccsym[a_,b_],covd_][gam[i_?DownIndexQ,j_,k_],lrest_,rrest_]:=With[{c=DummyIn[fbsym]},LeftVarD[ccsym[a,b],covd][ccsym[i,-c],lrest\[CenterDot]gam[c,j,k],rrest]]];
inject[{gam->gf1,ccsym->eta},LeftVarD[ccsym[a_,b_],covd_][gam[i_?UpIndexQ,j_,k_],lrest_,rrest_]:=0];
(* perturbations of tangent gamma matrices *)
inject[{gam->g1,g0->gf1,ccsym->frame,fbsym->fbundle},xAct`xPert`Private`ExpandPerturbation1[Perturbation[gam[i_,j_,k_],Optional[order_Integer,1]],options___]:=If[order==0,gam[i,j,k],ExpandPerturbation[Perturbation[With[{a=DummyIn[fbsym]},Perturbation[ccsym[i,-a]g0[a,j,k],1]],order-1],options]]];
inject[{gam->g1,g0->gf1,ccsym->frame,fbsym->fbundle},LeftVarD[ccsym[a_,b_],covd_][gam[i_,j_,k_],lrest_,rrest_]:=With[{c=DummyIn@fbsym},LeftVarD[ccsym[a,b],covd][ccsym[i,-c],lrest\[CenterDot]g0[a,j,k],rrest]]];
,
xTagSet[{g1,ImplicitTensorDepQ[g1,met]},True];
(* only perturbations of tangent gamma matrices in terms of the metric *)
inject[{gam->g1,ccsym->met,fbsym->tbundle},xAct`xPert`Private`ExpandPerturbation1[Perturbation[gam[i_?UpIndexQ,j_,k_],Optional[order_Integer,1]],options___]:=If[order==0,gam[i,j,k],ExpandPerturbation[Perturbation[With[{a=DummyIn[fbsym],b=DummyIn[fbsym]},-1/2ccsym[i,a]gam[b,j,k]Perturbation[ccsym[-a,-b],1]],order-1],options]]];
	inject[{gam->g1,ccsym->met,fbsym->tbundle},xAct`xPert`Private`ExpandPerturbation1[Perturbation[gam[i_?DownIndexQ,j_,k_],Optional[order_Integer,1]],options___]:=If[order==0,gam[i,j,k],ExpandPerturbation[Perturbation[With[{a=DummyIn[fbsym]},1/2 gam[a,j,k]Perturbation[ccsym[i,-a],1]],order-1],options]]];
inject[{gam->g1,ccsym->met,fbsym->tbundle},LeftVarD[ccsym[a_,b_],covd_][gam[i_?UpIndexQ,j_,k_],lrest_,rrest_]:=With[{c=DummyIn[fbsym],d=DummyIn[fbsym]},LeftVarD[ccsym[a,b],covd][ccsym[-c,-d],lrest\[CenterDot](-1/2 ccsym[i,c]gam[d,j,k]),rrest]]];
inject[{gam->g1,ccsym->met,fbsym->tbundle},LeftVarD[ccsym[a_,b_],covd_][gam[i_?DownIndexQ,j_,k_],lrest_,rrest_]:=With[{c=DummyIn[fbsym],d=DummyIn[fbsym]},LeftVarD[ccsym[a,b],covd][ccsym[-c,-d],lrest\[CenterDot](1/2ccsym[i,c] gam[d,j,k]),rrest]]];
];
Protect[LeftVarD];
(* Define the matrix that implements Hermitean conjugation for Lorentzian metrics (i.e., Dagger) - \[Gamma]^0 as per Freedman/van Proeyen. *)
If[Not[eucl],
g0=GammaMatrix[met,Zero];
DefTensor[g0@@spininds,man,{PrintAs->"\!\(\*SuperscriptBox[\(\[Gamma]\), \(0\)]\)["<>PrintAs[met]<>"]",Dagger->Real,Master->g1,GradeOfTensor->{CenterDot->0}}];
AppendTo[$GammaMatrices,g0];
xUpSetDelayed[cd[_]@g0[__],0];
xTagSetDelayed[{g0,g0[-k_,k_]},0];
xTagSetDelayed[{g0,g0[-i_,j_]g0[-j_,k_]},-delta[-i,k]];
xUpSet[GammaMatrixQ[g0],True];
xUpSet[MetricOfGammaMatrix[g0],met];
(* No Perturbation since it's a fixed matrix, but only if we have no frame bundle (and thus no Lorentz trafos) *)
If[!FrameBundleQ[fbundle],inject[{gam->g0},xAct`xPert`Private`ExpandPerturbation1[Perturbation[gam[j_,k_],Optional[order_Integer,1]],options___]:=If[order==0,gam[j,k],0]]];
(* Fix Dagger *)
inject[{gam->g0},Dagger[gam]^=Function[-gam[-#2,-#1]]];
inject[{gam->g0,rie->g1,tm->sbundle},Dagger[rie]^=Function[Module[{a=DummyIn[tm],b=DummyIn[tm]},gam[-#3,a]rie[#1,-a,b]gam[-b,-#2]]]];
(* same for frame bundle matrix *)
If[FrameBundleQ[fbundle],
g0=GammaMatrix[eta,Zero];
DefTensor[g0@@spininds,man,{PrintAs->"\!\(\*SuperscriptBox[\(\[Gamma]\), \(0\)]\)["<>PrintAs[Evaluate@eta]<>"]",Dagger->Real,Master->gf1,GradeOfTensor->{CenterDot->0}}];
AppendTo[$GammaMatrices,g0];
xUpSetDelayed[cd[_]@g0[__],0];
xTagSetDelayed[{g0,g0[-k_,k_]},0];
xTagSetDelayed[{g0,g0[-i_,j_]g0[-j_,k_]},-delta[-i,k]];
xUpSet[GammaMatrixQ[g0],True];
xUpSet[MetricOfGammaMatrix[g0],eta];
(* Fix Dagger *)
inject[{gam->g0},Dagger[gam]^=Function[-gam[-#2,-#1]]];
inject[{gam->g0,rie->gf1,tm->fbundle},Dagger[rie]^=Function[Module[{a=DummyIn[tm],b=DummyIn[tm]},gam[-#3,a]rie[#1,-a,b]gam[-b,-#2]]]];
];
];
(* all the higher \[Gamma] matrices are servants of \[Gamma]^\[Mu] *)
For[i=2,i<=dimm,i++,
gammasym=GammaMatrix[met,i];
gammainds=Join[GetIndicesOfVBundle[tbundle,i],spininds];
DefTensor[gammasym@@gammainds,man,Antisymmetric[Range[i]],PrintAs->("\[Gamma]["<>PrintAs[met]<>"]"),Dagger->Real,Master->g1,GradeOfTensor->{CenterDot->0}];
AppendTo[$GammaMatrices,gammasym];
xUpSetDelayed[cd[__]@gammasym[__],0];
xTagSetDelayed[{gammasym,gammasym[__,-k_,k_]},0];
xUpSet[GammaMatrixQ[gammasym],True];
xUpSet[MetricOfGammaMatrix[gammasym],met];
(* Fix Dagger *)
If[Not[eucl],inject[{gam->g0,rie->gammasym,tm->sbundle,j->i},Dagger[rie]^=Function[Module[{a=DummyIn[tm],b=DummyIn[tm]},(-1)^j gam[-{##}[[-1]],a]rie@@Join[{##}[[1;;j]],{-a,b}]gam[-b,-{##}[[-2]]]]]]];
(* Perturbation ist just the perturbation of its split form *)
inject[{gam->gammasym},xAct`xPert`Private`ExpandPerturbation1[Perturbation[gam[indices__],Optional[order_Integer,1]],options___]:=ExpandPerturbation[Perturbation[SplitGammaMatrix[gam[indices],True],order],options]];
(* tangent \[Gamma] matrices depend on metric or frame field *)
Unprotect[LeftVarD];
If[FrameBundleQ[fbundle],
xTagSet[{gammasym,ImplicitTensorDepQ[gammasym,frame]},True];
inject[{gam->gammasym,ccsym->frame},LeftVarD[ccsym[a_,b_],covd_][gam[indices__],lrest_,rrest_]:=LeftVarD[ccsym[a,b],covd][SplitGammaMatrix[gam[indices],True],lrest,rrest]];
,
xTagSet[{gammasym,ImplicitTensorDepQ[gammasym,met]},True];
inject[{gam->gammasym,ccsym->met},LeftVarD[ccsym[a_,b_],covd_][gam[indices__],lrest_,rrest_]:=LeftVarD[ccsym[a,b],covd][SplitGammaMatrix[gam[indices],True],lrest,rrest]];
];
Protect[LeftVarD];
(* same for frame bundle matrix *)
If[FrameBundleQ[fbundle],
gammasym=GammaMatrix[eta,i];
gammainds=Join[GetIndicesOfVBundle[fbundle,i],spininds];
DefTensor[gammasym@@gammainds,man,Antisymmetric[Range[i]],PrintAs->("\[Gamma]["<>PrintAs[Evaluate@eta]<>"]"),Dagger->Real,Master->gf1,GradeOfTensor->{CenterDot->0}];
AppendTo[$GammaMatrices,gammasym];
xUpSetDelayed[cd[__]@gammasym[__],0];
xTagSetDelayed[{gammasym,gammasym[__,-k_,k_]},0];
xUpSet[GammaMatrixQ[gammasym],True];
xUpSet[MetricOfGammaMatrix[gammasym],eta];
(* Fix Dagger *)
If[Not[eucl],inject[{gam->g0,rie->gammasym,tm->fbundle,j->i},Dagger[rie]^=Function[Module[{a=DummyIn[tm],b=DummyIn[tm]},(-1)^j gam[-{##}[[-1]],a]rie@@Join[{##}[[1;;j]],{-a,b}]gam[-b,-{##}[[-2]]]]]]];
(* Perturbation ist just the perturbation of its split form *)
inject[{gam->gammasym},xAct`xPert`Private`ExpandPerturbation1[Perturbation[gam[indices__],Optional[order_Integer,1]],options___]:=ExpandPerturbation[Perturbation[SplitGammaMatrix[gam[indices],True],order],options]];
(* frame \[Gamma] matrices depend on frame metric *)
xTagSet[{gammasym,ImplicitTensorDepQ[gammasym,eta]},True];
Unprotect[LeftVarD];
inject[{gam->gammasym,ccsym->eta},LeftVarD[ccsym[a_,b_],covd_][gam[indices__],lrest_,rrest_]:=LeftVarD[ccsym[a,b],covd][SplitGammaMatrix[gam[indices],True],lrest,rrest]];
Protect[LeftVarD];
];
];
If[EvenQ[dimm],
gammasym=GammaMatrix[met,Star];
DefTensor[gammasym@@spininds,man,PrintAs->("\!\(\*SuperscriptBox[\(\[Gamma]\), \(*\)]\)["<>PrintAs[met]<>"]"),Dagger->Real,Master->g1,GradeOfTensor->{CenterDot->0}];
AppendTo[$GammaMatrices,gammasym];
xUpSetDelayed[cd[__]@gammasym[__],0];
xTagSetDelayed[{gammasym,gammasym[-k_,k_]},0];
xTagSetDelayed[{gammasym,gammasym[-l_,j_]gammasym[-j_,k_]},$GammaStarSign^2delta[-l,k]];
xUpSet[GammaMatrixQ[gammasym],True];
xUpSet[MetricOfGammaMatrix[gammasym],met];
(* No Perturbation since it's a fixed matrix, but only if we have no frame bundle (and thus no Lorentz trafos). Otherwise perturbation of split form. *)
inject[{gam->gammasym},If[!FrameBundleQ[fbundle],xAct`xPert`Private`ExpandPerturbation1[Perturbation[gam[indices__],Optional[order_Integer,1]],options___]:=If[order==0,gam[indices],0],xAct`xPert`Private`ExpandPerturbation1[Perturbation[gam[indices__],Optional[order_Integer,1]],options___]:=ExpandPerturbation[Perturbation[SplitGammaMatrix[gam[indices],False],order],options]]];
(* same for frame bundle matrix *)
If[FrameBundleQ[fbundle],
gammasym=GammaMatrix[eta,Star];
DefTensor[gammasym@@spininds,man,PrintAs->("\!\(\*SuperscriptBox[\(\[Gamma]\), \(*\)]\)["<>PrintAs[Evaluate@eta]<>"]"),Dagger->Real,Master->gf1,GradeOfTensor->{CenterDot->0}];
AppendTo[$GammaMatrices,gammasym];
xUpSetDelayed[cd[__]@gammasym[__],0];
xTagSetDelayed[{gammasym,gammasym[-k_,k_]},0];
xTagSetDelayed[{gammasym,gammasym[-l_,j_]gammasym[-j_,k_]},$GammaStarSign^2delta[-l,k]];
xUpSet[GammaMatrixQ[gammasym],True];
xUpSet[MetricOfGammaMatrix[gammasym],eta];
inject[{gam->gammasym},xAct`xPert`Private`ExpandPerturbation1[Perturbation[gam[indices__],Optional[order_Integer,1]],options___]:=ExpandPerturbation[Perturbation[SplitGammaMatrix[gam[indices],False],order],options]];
];
];
(* dispatch to the correct Gamma matrix *)
gammasym=Symbol["Gamma"<>SymbolName[met]];
inject[{gam->gammasym},gam[ind__]:=With[{len=Length[{ind}]},If[len>2+DimOfVBundle[VBundleOfIndex[First[{ind}]]],0,If[len==2,delta[ind],Symbol[SymbolName[gam]<>ToString[len-2]][ind]]]]];
gammasym=Symbol["Gamma"<>SymbolName[eta]];
inject[{gam->gammasym},gam[ind__]:=With[{len=Length[{ind}]},If[len>2+DimOfVBundle[VBundleOfIndex[First[{ind}]]],0,If[len==2,delta[ind],Symbol[SymbolName[gam]<>ToString[len-2]][ind]]]]];
(* Perturbation of covariant derivative, only if no frame bundle is defined (otherwise determined by spin connection) *)
If[!FrameBundleQ[fbundle],
inject[{tm->tbundle,ccsym->Symbol["AChristoffel"<>SymbolName[cd]],rie->cd,gam->GammaMatrix[met,2]},xAct`xPert`Private`ExpandPerturbation1[Perturbation[ccsym[i_?UpIndexQ,j_?DownIndexQ,k_?DownIndexQ],Optional[order_Integer,1]],options___]:=If[order==0,ccsym[i,j,k],ExpandPerturbation[Perturbation[With[{rho=DummyIn@tm,sigma=DummyIn@tm},-1/4 gam[rho,sigma,k,i]rie[-sigma]@Perturbation[met[-rho,j]]],order-1],options]]];
];
(* let the FRiemann tensor expand into ordinary Riemann tensor and Gamma matrices *)
gammasym=GammaMatrix[met,2];
inject[{tm->tbundle,rie->Riemann[cd],gam->gammasym,ccsym->sbundle},FRiemann[cd][mu_,nu_,a_,b_]/;(VBundleOfIndex[a]===ccsym):=Module[{rho=DummyIn[tm],sigma=DummyIn[tm]},1/4 rie[mu,nu,rho,sigma]gam[-rho,-sigma,a,b]]];
(* fix some implicit dependencies to make Left/RightVarD work *)
Map[xTagSet[{#,ImplicitTensorDepQ[#,met]},True]&,{Determinant[met,AIndex],epsilon[met],GiveSymbol[Christoffel,cd],GiveSymbol[Riemann,cd],GiveSymbol[Ricci,cd],GiveSymbol[RicciScalar,cd],GiveSymbol[Einstein,cd],GiveSymbol[Weyl,cd],GiveSymbol[TFRicci,cd],GiveSymbol[Kretschmann,cd],GiveSymbol[SymRiemann,cd],GiveSymbol[Schouten,cd]}];
(* precompute \[Gamma] matrix products *)
If[$PrecomputeGammaMatrixProducts,
If[$DefInfoQ,PrintTemporary["** ",ToString@funcname,": Precomputing \[Gamma] products..."]];
xUpSet[GammaMatrixProducts[met],PrecomputeGammaProducts[met]];
If[FrameBundleQ[fbundle],xUpSet[GammaMatrixProducts[eta],PrecomputeGammaProducts[eta]];];
If[$DefInfoQ,Print["** ",ToString@funcname,": Precomputing \[Gamma] products... done."]];
,
If[$DefInfoQ,Print["** ",ToString@funcname,": Not precomputing \[Gamma] products."]];
];
];
If[SpinorsPkgLoaded&&SpinorsKeepDefs,
SetNumberOfArguments[DefGenSpinStructure,2];
Protect[DefGenSpinStructure];
,
SetNumberOfArguments[DefSpinStructure,2];
Protect[DefSpinStructure];
];


(* ::Input::Initialization:: *)
If[SpinorsPkgLoaded&&SpinorsKeepDefs,
UndefGenSpinStructure[met_Symbol]:=undefSpinStruct[met];
,
UndefSpinStructure[met_Symbol]:=undefSpinStruct[met];
];
undefSpinStruct[met_Symbol]:=Catch@Module[{funcname,cd,tbundle,sbundle,fbundle,eta,vislen,i,dimm,gammasym,gam,fbsym,ccsym},
If[SpinorsPkgLoaded&&SpinorsKeepDefs,funcname=UndefGenSpinStructure;,funcname=UndefSpinStructure;];
If[!MetricQ[met],Throw@Message[Evaluate[MessageName[Evaluate@funcname,"unknown"]],"metric",met]];
tbundle=VBundleOfMetric[met];
sbundle=Symbol["Spin"<>SymbolName[BaseOfVBundle[tbundle]]];
fbundle=Symbol["Frame"<>SymbolName[BaseOfVBundle[tbundle]]];
cd=CovDOfMetric[met];
If[!MemberQ[VBundlesOfCovD[cd],sbundle],Throw@Message[Evaluate[MessageName[Evaluate@funcname,"missing"]],"spin structure","the metric "<>SymbolName[gg]]];
(* check if there are tensors still defined on the spin bundle, except Gamma matrices and AChristoffel/FRiemann *)
dimm=DimOfVBundle[tbundle];
vislen=2+dimm+If[EvenQ[dimm],1,0]+If[SignDetOfMetric[met]==-1,1,0];
If[FrameBundleQ[fbundle],vislen=vislen+dimm+If[EvenQ[dimm],1,0]+If[SignDetOfMetric[met]==-1,1,0];];
If[Length@VisitorsOf[sbundle]>vislen,Throw@Message[Evaluate[MessageName[Evaluate@funcname,"noundef"]],"Spin bundle",sbundle,"it has visitors"]];
(* remove associated symbols from covariant derivative *)
Evaluate[cd]/:CurvatureQ[cd,sbundle]=.;
VBundlesOfCovD[cd]^=DeleteCases[VBundlesOfCovD[cd],sbundle];
ServantsOf[cd]^=DeleteCases[ServantsOf[cd],FRiemann[cd]|GiveSymbol[AChristoffel,cd]];
(* remove perturbations *)
Unprotect[LeftVarD];
If[FrameBundleQ[fbundle],
eta=First@MetricsOfVBundle@fbundle;
(* perturbations of frame gamma matrices *)
inject[{gam->GammaMatrix[eta,1]},xAct`xPert`Private`ExpandPerturbation1[Perturbation[gam[i_?DownIndexQ,j_,k_],Optional[order_Integer,1]],options___]=.];
inject[{gam->GammaMatrix[eta,1],ccsym->eta},LeftVarD[ccsym[a_,b_],covd_][gam[i_?DownIndexQ,j_,k_],lrest_,rrest_]=.];
inject[{gam->GammaMatrix[eta,1],ccsym->eta},LeftVarD[ccsym[a_,b_],covd_][gam[i_?UpIndexQ,j_,k_],lrest_,rrest_]=.];
(* perturbations of tangent gamma matrices *)
inject[{gam->GammaMatrix[met,1]},xAct`xPert`Private`ExpandPerturbation1[Perturbation[gam[i_,j_,k_],Optional[order_Integer,1]],options___]=.];
inject[{gam->GammaMatrix[met,1],ccsym->FrameFieldOfBundle[tbundle,fbundle]},LeftVarD[ccsym[a_,b_],covd_][gam[i_,j_,k_],lrest_,rrest_]=.];
For[i=2,i<=DimOfVBundle[tbundle],i++,
inject[{gam->GammaMatrix[met,i]},xAct`xPert`Private`ExpandPerturbation1[Perturbation[gam[indices__],Optional[order_Integer,1]],options___]=.];
inject[{gam->GammaMatrix[met,i],ccsym->FrameFieldOfBundle[tbundle,fbundle]},LeftVarD[ccsym[a_,b_],covd_][gam[indices__],lrest_,rrest_]=.];
inject[{gam->GammaMatrix[eta,i]},xAct`xPert`Private`ExpandPerturbation1[Perturbation[gam[indices__],Optional[order_Integer,1]],options___]=.];
inject[{gam->GammaMatrix[eta,i],ccsym->eta},LeftVarD[ccsym[a_,b_],covd_][gam[indices__],lrest_,rrest_]=.];
];
If[EvenQ[DimOfVBundle[tbundle]],
inject[{gam->GammaMatrix[met,Star]},xAct`xPert`Private`ExpandPerturbation1[Perturbation[gam[indices__],Optional[order_Integer,1]],options___]=.];
inject[{gam->GammaMatrix[eta,Star]},xAct`xPert`Private`ExpandPerturbation1[Perturbation[gam[indices__],Optional[order_Integer,1]],options___]=.];
];
,
(* only perturbations of tangent gamma matrices in terms of the metric *)
inject[{gam->GammaMatrix[met,1]},xAct`xPert`Private`ExpandPerturbation1[Perturbation[gam[i_?UpIndexQ,j_,k_],Optional[order_Integer,1]],options___]=.];
	inject[{gam->GammaMatrix[met,1]},xAct`xPert`Private`ExpandPerturbation1[Perturbation[gam[i_?DownIndexQ,j_,k_],Optional[order_Integer,1]],options___]=.];
inject[{gam->GammaMatrix[met,1],ccsym->met,fbsym->tbundle},LeftVarD[ccsym[a_,b_],covd_][gam[i_?UpIndexQ,j_,k_],lrest_,rrest_]=.];
inject[{gam->GammaMatrix[met,1],ccsym->met,fbsym->tbundle},LeftVarD[ccsym[a_,b_],covd_][gam[i_?DownIndexQ,j_,k_],lrest_,rrest_]=.];
For[i=2,i<=DimOfVBundle[tbundle],i++,
inject[{gam->GammaMatrix[met,i]},xAct`xPert`Private`ExpandPerturbation1[Perturbation[gam[indices__],Optional[order_Integer,1]],options___]=.];
inject[{gam->GammaMatrix[met,i],ccsym->met},LeftVarD[ccsym[a_,b_],covd_][gam[indices__],lrest_,rrest_]=.];
];
If[EvenQ[DimOfVBundle[tbundle]],
inject[{gam->GammaMatrix[met,Star]},xAct`xPert`Private`ExpandPerturbation1[Perturbation[gam[indices__],Optional[order_Integer,1]],options___]=.];
];
If[SignDetOfMetric[met]==-1,
inject[{gam->GammaMatrix[met,Zero]},xAct`xPert`Private`ExpandPerturbation1[Perturbation[gam[indices__],Optional[order_Integer,1]],options___]=.];
];
];
Protect[LeftVarD];
(* undefine precomputed \[Gamma] matrix products, the \[Gamma] matrices and AChristoffel/FRiemann *)
If[$PrecomputeGammaMatrixProducts,met/:GammaMatrixProducts[met]=.;];
gammasym=GammaMatrix[met,1];
UndefTensor[gammasym];
gammasym=Symbol["Gamma"<>SymbolName[met]];
ClearAll[gammasym];
(* also remove frame gamma matrices *)
If[FrameBundleQ[fbundle],
eta=First@MetricsOfVBundle[fbundle];
If[$PrecomputeGammaMatrixProducts,eta/:GammaMatrixProducts[eta]=.;];
gammasym=GammaMatrix[eta,1];
UndefTensor[gammasym];
gammasym=Symbol["Gamma"<>SymbolName[eta]];
ClearAll[gammasym];
];
MasterOf[FRiemann[cd]]^=Null;
UndefTensor[FRiemann[cd]];
MasterOf[GiveSymbol[AChristoffel,cd]]^=Null;
UndefTensor[GiveSymbol[AChristoffel,cd]];
(* finally undefine the bundle *)
UndefVBundle[sbundle];
];
If[SpinorsPkgLoaded&&SpinorsKeepDefs,
SetNumberOfArguments[UndefGenSpinStructure,1];
Protect[UndefGenSpinStructure];
,
SetNumberOfArguments[UndefSpinStructure,1];
Protect[UndefSpinStructure];
];


(* ::Input::Initialization:: *)
SpinBundleQ[bundle_?VBundleQ]:=Module[{tbundle,met},
tbundle=Tangent[BaseOfVBundle[bundle]];
If[bundle===tbundle,Return@False];
met=MetricsOfVBundle[tbundle];
If[Length[met]<1,Return@False];
met=First@met;
MemberQ[VisitorsOf[bundle],GammaMatrix[met,1]]
];
SpinBundleQ[_]:=False;
SetNumberOfArguments[SpinBundleQ,1];
Protect[SpinBundleQ];


(* ::Input::Initialization:: *)
SplitGammaMatrix[f_,keepgammas:(_?BooleanQ):False]:=Catch@Module[{len,dimm,metric,mfold,g1,ilist,silist},
If[!GammaMatrixQ[Head[f]],Throw@Message[SplitGammaMatrix::nogamma,Head[f]]];
If[GammaZeroQ[Head[f]],Return@f];
len=Length[f];
metric=MetricOfGammaMatrix[Head[f]];
mfold=BaseOfVBundle[VBundleOfMetric[metric]];
dimm=DimOfManifold[mfold];
g1=GammaMatrix[metric,1];
(* in even dimensions, \[Gamma]* *)
Switch[len,
2,If[!GammaStarQ[Head[f]],Throw@Message[SplitGammaMatrix::nogamma,Head[f]]];If[keepgammas===True,f,
ilist=DummiesIn[VBundleOfMetric[metric],dimm];
silist=DummiesIn[Symbol["Spin"<>SymbolName[mfold]],dimm-1];
silist=Join[{f[[1]]},Riffle[silist,-silist],{f[[2]]}];
silist=Partition[Riffle[silist,ilist,{1,-2,3}],3];
$GammaStarSign (-I)^(dimm/2+3)/dimm!epsilon[metric]@@(-ilist)Times@@(g1@@@silist)
],
3,(* can only be \[Gamma]^\[Mu] *)f,
_,
ilist=(List@@f)[[1;;-3]];
silist=DummiesIn[Symbol["Spin"<>SymbolName[mfold]],Length[ilist]-1];
silist=Join[{f[[-2]]},Riffle[silist,-silist],{f[[-1]]}];
silist=Partition[Riffle[silist,ilist,{1,-2,3}],3];
Antisymmetrize[Times@@(g1@@@silist),ilist]
]
];
SetNumberOfArguments[SplitGammaMatrix,{1,2}]
Protect[SplitGammaMatrix];

SplitGammaMatrices[f_,keepgammas:(_?BooleanQ):False]:=f//.{x_?GammaMatrixQ[inds__]:>SplitGammaMatrix[x[inds],keepgammas]}
SetNumberOfArguments[SplitGammaMatrices,{1,2}]
Protect[SplitGammaMatrices];


(* ::Input::Initialization:: *)
InternalGammaProduct[ainds_,binds_,metric_,ginds_]:=With[{i=Length[ainds],j=Length[binds],gname=Symbol["Gamma"<>SymbolName[metric]]},Module[{awdinds,bwdinds},
awdinds=GetIndicesOfVBundle[VBundleOfMetric[metric],i];
bwdinds=GetIndicesOfVBundle[VBundleOfMetric[metric],j,awdinds];
ToCanonical@ContractMetric[Antisymmetrize[Antisymmetrize[Sum[i!j!/(k! (i-k)!(j-k)!)gname@@Join[awdinds[[1;;i-k]],bwdinds[[k+1;;j]],ginds]Product[metric[awdinds[[i+1-r]],bwdinds[[r]]],{r,1,k}],{k,0,Min[i,j]}],bwdinds],awdinds]/.Thread@Rule[Join[awdinds,bwdinds],Join[ainds,binds]]]
]]


(* ::Input::Initialization:: *)
PrecomputeGammaProducts[metric_]:=With[{tm=VBundleOfMetric[metric],sm=Symbol["Spin"<>SymbolName[BaseOfVBundle@VBundleOfMetric[metric]]]},Table[Module[{ainds,binds,gindA,gindB,prod,tbl},
ainds=GetIndicesOfVBundle[tm,nainds];
binds=GetIndicesOfVBundle[tm,nbinds,ainds];
{gindA,gindB}=GetIndicesOfVBundle[sm,2];
prod=InternalGammaProduct[ainds,binds,metric,{-gindA,gindB}];
{ainds,binds,gindA,gindB,prod}
],{nainds,DimOfVBundle@tm},{nbinds,DimOfVBundle@tm}]]


(* ::Input::Initialization:: *)
PrecomputedGammaProduct[ainds_,binds_,metric_,ginds_]:=With[{i=Length[ainds],j=Length[binds],gamtbl=GammaMatrixProducts[metric]},
gamtbl[[i,j,5]]/.Join[Thread@Rule[gamtbl[[i,j,1]],ainds],Thread@Rule[gamtbl[[i,j,2]],binds],{gamtbl[[i,j,3]]->-ginds[[1]],gamtbl[[i,j,4]]->ginds[[2]]}]
]


(* ::Input::Initialization:: *)
JoinGammaMatrices[f_Plus,keep_?BooleanQ]:=Map[JoinGammaMatrices[#,keep]&,f]
JoinGammaMatrices[f_,keep:(_?BooleanQ):False]:=With[{f2=f//.{x_. ga_?GammaMatrixQ[indsa__,B_,A_]gb_?GammaMatrixQ[indsb__,-A_,C_]/;SameQ@@Map[MetricOfGammaMatrix,{ga,gb}]:>Expand[x If[$PrecomputeGammaMatrixProducts,PrecomputedGammaProduct[{indsa},{indsb},MetricOfGammaMatrix[ga],{B,C}],InternalGammaProduct[{indsa},{indsb},MetricOfGammaMatrix[ga],{B,C}]]]}//.{ga_?GammaStarQ[A_,B_]gb_?GammaMatrixQ[inds__,-B_,C_]gc_?GammaStarQ[-C_,D_]/;SameQ@@Map[MetricOfGammaMatrix,{ga,gb,gc}]:>(-1)^Length@List[inds]$GammaStarSign^2gb[inds,A,D],ga_?GammaStarQ[A_,B_]gb_?GammaZeroQ[-B_,C_]gc_?GammaStarQ[-C_,D_]/;SameQ@@Map[MetricOfGammaMatrix,{ga,gb,gc}]:>-$GammaStarSign^2gb[A,D],ga_?GammaZeroQ[A_,B_]gb_?GammaStarQ[-B_,C_]gc_?GammaZeroQ[-C_,D_]/;SameQ@@Map[MetricOfGammaMatrix,{ga,gb,gc}]:>gb[A,D]}},
If[keep,f2,f2/.{ga_?GammaMatrixQ[inds__,A_,B_]gb_?GammaStarQ[-B_,C_]/;SameQ@@Map[MetricOfGammaMatrix,{ga,gb}]:>DualGammaMatrix[ga[inds,A,B]]gb[-B,C],ga_?GammaStarQ[A_,B_]gb_?GammaMatrixQ[inds__,-B_,C_]/;SameQ@@Map[MetricOfGammaMatrix,{ga,gb}]:>(-1)^Length@List[inds]DualGammaMatrix[gb[inds,A,B]]ga[-B,C]}]]
SetNumberOfArguments[JoinGammaMatrices,{1,2}];
Protect[JoinGammaMatrices];


(* ::Input::Initialization:: *)
DualGammaMatrix[gam_?GammaMatrixQ[inds___,A_,B_]]:=Catch@Module[{met,bdl,sbdl,dim,gamdim,dualgam,gamstar},
If[GammaZeroQ[gam],Throw@Message[DualGammaMatrix::wronggamma]];
met=MetricOfGammaMatrix@gam;
bdl=VBundleOfMetric@met;
sbdl=SlotsOfTensor[gam][[-1]];
dim=DimOfVBundle@bdl;
gamdim=Length[SlotsOfTensor[gam]]-2;
dualgam=If[dim-gamdim>0,GiveSymbol[Gamma,met,dim-gamdim],delta];
gamstar=If[EvenQ[dim]&&gamdim>0,GiveSymbol[Gamma,met,Star],delta];
If[EvenQ[dim],
(-I)^(dim/2+3)/(dim-gamdim)!(-1)^(gamdim (gamdim-1)/2)If[gamdim>0,1/$GammaStarSign ,$GammaStarSign]With[{dinds=DummiesIn[bdl,dim-gamdim],C=DummyIn@sbdl},epsilon[met]@@Join[{inds},dinds]dualgam@@Join[-dinds,{A,C}]gamstar[-C,B]],
$GammaStarSign (I)^(dim/2+3)/(dim-gamdim)!(-1)^((dim-gamdim)(dim-gamdim-1)/2)With[{dinds=DummiesIn[bdl,dim-gamdim]},epsilon[met]@@Join[{inds},dinds]dualgam@@Join[-dinds,{A,B}]]
]]
SetNumberOfArguments[DualGammaMatrix,1];
Protect[DualGammaMatrix];


(* ::Input::Initialization:: *)
GammaMatricesToDual[expr_]:=Module[{gammas,gam,i,reps},
gammas=Complement[$GammaMatrices,Join[Select[$GammaMatrices,GammaStarQ],Select[$GammaMatrices,GammaZeroQ]]];
gammas=ReleaseHold@Map[If[2Length[SlotsOfTensor[#]]-4>DimOfVBundle[VBundleOfMetric[MetricOfGammaMatrix[#]]],#,Hold@Sequence[]]&,gammas];
reps=Table[inject[{gam->gammas[[i]]},gam[inds__]:>DualGammaMatrix[gam[inds]]],{i,1,Length@gammas}];
expr/.reps
]
GammaMatricesToDual[expr_,All]:=Module[{gammas,gam,i,reps},
gammas=Complement[$GammaMatrices,Join[Select[$GammaMatrices,GammaStarQ],Select[$GammaMatrices,GammaZeroQ]]];
reps=Table[inject[{gam->gammas[[i]]},gam[inds__]:>DualGammaMatrix[gam[inds]]],{i,1,Length@gammas}];
expr/.reps]
GammaMatricesToDual[expr_,gam_?GammaMatrixQ]:=Catch@If[GammaZeroQ[gam],Throw@Message[DualGammaMatrix::wronggamma],expr/.{gam[inds__]:>DualGammaMatrix[gam[inds]]}]
SetNumberOfArguments[GammaMatricesToDual,{1,2}];
Protect[GammaMatricesToDual];


(* ::Input::Initialization:: *)
ChangeGammaMatrices[expr_,met1_?MetricQ,met2_?MetricQ]:=Catch@Module[{gamlist,bdl1,bdl2,frame,gammas,reps,i,ngam,bsym,gsym,gamsym,frsym},
bdl1=VBundleOfMetric[met1];
bdl2=VBundleOfMetric[met2];
If[(!FrameBundleQ[bdl1])&&(!FrameBundleQ[bdl2]),Throw@Message[ChangeGammaMatrices::error,"None of "<>ToString@met1<>", "<>ToString@met2<>" is a frame bundle metric."]];
If[(bdl1=!=Tangent@BaseOfVBundle[bdl1])&&(bdl2=!=Tangent@BaseOfVBundle[bdl2]),Throw@Message[ChangeGammaMatrices::error,"None of "<>ToString@met1<>", "<>ToString@met2<>" is a tangent bundle metric."]];
If[FrameBundleQ[bdl1],
frame=FrameFieldOfBundle[bdl2,bdl1];
,
frame=FrameFieldOfBundle[bdl1,bdl2];
];
gammas=Select[$GammaMatrices,(MetricOfGammaMatrix[#]===met1)&];
reps={};
For[i=1,i<=Length@gammas,i=i+1,
ngam=Symbol["Gamma"<>SymbolName[met2]<>StringDrop[SymbolName[gammas[[i]]],5+StringLength@SymbolName[met1]]];
If[Length@SlotsOfTensor[gammas[[i]]]==2,
(* special \[Gamma] matrices *)
inject[{gamsym->ngam,gsym->gammas[[i]]},AppendTo[reps,gsym[inds__]:>gamsym[inds]]];
,
(* generalized \[Gamma] matrices. need to check order of indices on frame field *)
If[FrameBundleQ[bdl1],
inject[{gamsym->ngam,gsym->gammas[[i]],frsym->frame,bsym->bdl2},AppendTo[reps,gsym[inds__,A_,B_]:>With[{inds2=DummiesIn[bsym,Length[{inds}]]},Times@@frsym@@@Transpose[{-inds2,{inds}}]gamsym@@Join[inds2,{A,B}]]]];
,
inject[{gamsym->ngam,gsym->gammas[[i]],frsym->frame,bsym->bdl2},AppendTo[reps,gsym[inds__,A_,B_]:>With[{inds2=DummiesIn[bsym,Length[{inds}]]},Times@@frsym@@@Transpose[{{inds},-inds2}]gamsym@@Join[inds2,{A,B}]]]];
];
];
];
reps=Dispatch[reps];
expr/.reps
]
SetNumberOfArguments[ChangeGammaMatrices,3];
Protect[ChangeGammaMatrices];


(* ::Input::Initialization:: *)
EpsGammaRep[dim_,met_,tm_,eps_[epsinds__],gam_[ginds__,A_,B_]]:=With[{i=Length[{ginds}]},Module[{dinds=DummiesIn[tm,i],grepinds=DummiesIn[tm,i],prodmet,epswithin,res},
prodmet=Times@@(met@@@Transpose[{grepinds,{epsinds}[[1;;i]]}]);
epswithin=eps@@Join[{epsinds}[[i+1;;-1]],-dinds];
res=ToCanonical[(-1)^(i(dim+1))dim!/(i!(dim-i)!)Antisymmetrize[prodmet epswithin,{epsinds}]]gam@@Join[dinds,{A,B}];
ToCanonical[res/.Rule@@@Transpose[{grepinds,{ginds}}]]
]]
EpsilonGammaReduce[expr_,met_]:=Catch@Module[{i,eps,gam,gams,tm,dim,reps},
tm=VBundleOfMetric[met];
dim=DimOfVBundle[tm];
If[!IntegerQ[dim],Throw@Message[EpsilonGammaReduce::wrongdim,dim]];
eps=epsilon[met];
gams=Table[GiveSymbol[Gamma,met,i],{i,1,dim}];
If[!xTensorQ[gams[[1]]],Throw@Message[EpsilonGammaReduce::missing,"spin structure defined",BaseOfVBundle[tm]]];
reps=Table[inject[{gam->gams[[i]]},eps[inds__]gam[ginds__,A_,B_]:>EpsGammaRep[dim,met,tm,eps[inds],gam[ginds,A,B]]],{i,1,dim}];
expr/.reps
]
SetNumberOfArguments[EpsilonGammaReduce,2];
Protect[EpsilonGammaReduce];


(* ::Input::Initialization:: *)
(* internal function to project an expression even if indices are contracted *)
EpsYoungProj[expr_,tab_]:=Module[{transtab,n1,n2,erg},transtab=Flatten[tab,{2}];
n1=Times@@(Length[#1]!&)/@tab;
n2=Times@@(Length[#1]!&)/@transtab;
erg=Fold[Symmetrize[#1,#2]&,expr,tab];
ToCanonical[((TableauDimension[tab] n1 n2) Fold[Antisymmetrize[#1,#2]&,erg,transtab])/Length[Flatten[tab]]!]
]
(* only works with one or two additional indices for now, and in 4D *)
EpsilonYoungProject[lst_List,met_?MetricQ]:=(EpsilonYoungProject[#1,met]&)/@lst
EpsilonYoungProject[sum_Plus,met_?MetricQ]:=(EpsilonYoungProject[#1,met]&)/@sum
EpsilonYoungProject[expr_,met_?MetricQ]:=Catch@Module[{tm,epsm,allinds,epsinds,otherinds,tableau,transtab,n1,n2,erg},
tm=VBundleOfMetric[met];
If[DimOfVBundle[tm]=!=4,Throw@Message[EpsilonYoungProject::wrongdim,DimOfVBundle[tm]]];
epsm=GiveSymbol[epsilon,met];
If[FreeQ[expr,epsm],Return[expr]];
allinds=List@@IndicesOf[tm][expr];
epsinds=List@@FirstCase[expr,epsm[__]];
otherinds=DeleteDuplicates[Complement[allinds,epsinds,-epsinds],((#1===#2)||(#1===-#2))&];
Switch[Length[otherinds],
0,expr,
1,EpsYoungProj[expr,{{epsinds[[1]],otherinds[[1]]},{epsinds[[2]]},{epsinds[[3]]},{epsinds[[4]]}}],
2,EpsYoungProj[expr,{{epsinds[[1]],otherinds[[1]],otherinds[[2]]},{epsinds[[2]]},{epsinds[[3]]},{epsinds[[4]]}}]+EpsYoungProj[expr,{{epsinds[[1]],otherinds[[1]]},{epsinds[[2]],otherinds[[2]]},{epsinds[[3]]},{epsinds[[4]]}}],
_,expr]
]
SetNumberOfArguments[EpsilonYoungProject,2];
Protect[EpsilonYoungProject];


(* ::Input::Initialization:: *)
(****************************** 2.7 Spinors ******************************)


(* ::Input::Initialization:: *)
MajoranaQ[_]:=False;
DiracQ[_]:=False;
SpinorQ[_]:=False;
SpinorUnbarQ[_]:=False;
SpinorBarQ[_]:=False;

SetNumberOfArguments[MajoranaQ,1];
SetNumberOfArguments[DiracQ,1];
SetNumberOfArguments[SpinorQ,1];
SetNumberOfArguments[SpinorUnbarQ,1];
SetNumberOfArguments[SpinorBarQ,1];
Protect[MajoranaQ,DiracQ,SpinorQ,SpinorUnbarQ,SpinorBarQ];


(* ::Input::Initialization:: *)
If[SpinorsPkgLoaded&&SpinorsKeepDefs,
Options[DefGenSpinor]={SpinorType->Majorana,Conjugate->False};
DefGenSpinor[tensor_,dependencies_,options:OptionsPattern[{DefGenSpinor,DefTensor}]]:=DefGenSpinor[tensor,dependencies,GenSet[],options];
DefGenSpinor[head_[indices__],dependencies_,sym_,options:OptionsPattern[{DefGenSpinor,DefTensor}]]:=defSpinor[head[indices],dependencies,sym,options];
,
Options[DefSpinor]={SpinorType->Majorana,Conjugate->False};
DefSpinor[tensor_,dependencies_,options:OptionsPattern[{DefSpinor,DefTensor}]]:=DefSpinor[tensor,dependencies,GenSet[],options];
DefSpinor[head_[indices__],dependencies_,sym_,options:OptionsPattern[{DefSpinor,DefTensor}]]:=defSpinor[head[indices],dependencies,sym,options];
];
defSpinor[head_[indices__],dependencies_,sym_,options:OptionsPattern[{DefSpinor,DefGenSpinor,DefTensor}]]:=Catch@Module[{funcname,st,conj,mfold,met,dimm,sbundle,bar,barpa,pns,dto,dtobar,g0,eucl},
If[SpinorsPkgLoaded&&SpinorsKeepDefs,funcname=DefGenSpinor;,funcname=DefSpinor;];
(* Options *)
{st,conj,pns}=OptionValue[{SpinorType,Conjugate,ProtectNewSymbol}];
(* Majorana spinors only exist in dimensions 2,3,4 mod 8. We only check the first manifold, which should make it work on products as well. *)
mfold=SelectFirst[If[Head[dependencies]===List,dependencies,{dependencies}],ManifoldQ,Null];
If[mfold==Null,Throw@Message[Evaluate[MessageName[Evaluate@funcname,"nomanifold"]],dependencies]];
dimm=DimOfManifold[mfold];
met=MetricsOfVBundle[Tangent[mfold]];
If[Length[met]<1,Throw@Message[Evaluate[MessageName[Evaluate@funcname,"missing"]],"metric defined",mfold]];
met=First[met];
(* check that a spin structure has been defined *)
If[!xTensorQ[Symbol["Gamma"<>SymbolName[met]<>"1"]],Throw@Message[Evaluate[MessageName[Evaluate@funcname,"missing"]],"spin structure defined",mfold]];
(* check that the last index is a down index of the spin bundle *)
sbundle=Symbol["Spin"<>SymbolName[mfold]];
If[(!DownIndexQ[Last@{indices}])||(VBundleOfIndex[Last@{indices}]=!=sbundle),Throw@Message[Evaluate[MessageName[Evaluate@funcname,"invalid"]],Last@{indices},"index"]];
eucl=(SignDetOfMetric[met]==1);
bar=Symbol[StringJoin["bar",SymbolName[head]]];
Switch[st,
Majorana,If[MemberQ[{2,3,4},Mod[dimm,8]],MajoranaQ[head]^=True;MajoranaQ[bar]^=True,Throw@Message[Evaluate[MessageName[Evaluate@funcname,"majoranawrongdim"]],mfold,dimm]],
Dirac,DiracQ[head]^=True;DiracQ[bar]^=True,
_,Throw@Message[Evaluate[MessageName[Evaluate@funcname,"invalid"]],"spinor type",st];
];
SpinorQ[head]^=True;SpinorQ[bar]^=True;
If[TrueQ@conj,SpinorBarQ[head]^=True;SpinorBarQ[bar]^=False,SpinorBarQ[head]^=False;SpinorBarQ[bar]^=True];
If[TrueQ@conj,SpinorUnbarQ[head]^=False;SpinorUnbarQ[bar]^=True,SpinorUnbarQ[head]^=True;SpinorUnbarQ[bar]^=False];
dto=FilterRules[FilterRules[{options},Options[DefTensor]],Except[Dagger]];
dto=Join[If[Head[dto]===List,dto,{dto}],{Dagger->Real}];
barpa=OverBar[xAct`xTensor`Private`PrintAsString[head,Quiet[Check[OptionValue[dto,PrintAs],Identity,{OptionValue::optnf}],{OptionValue::optnf}]]];
dtobar=FilterRules[dto,Except[Master|PrintAs]];
dtobar=Join[If[Head[dtobar]===List,dtobar,{dtobar}],{Master->head,PrintAs->ToString[barpa,StandardForm]}];
If[TrueQ@conj,
DefTensor[head@@Append[DaggerIndex@IndexList[indices][[1;;-2]],-Last@{indices}],dependencies,sym,dto];
DefTensor[bar[indices],dependencies,sym,dtobar];
,
DefTensor[head[indices],dependencies,sym,dto];
DefTensor[bar@@Append[DaggerIndex@IndexList[indices][[1;;-2]],-Last@{indices}],dependencies,sym,dtobar];
];
If[pns,Unprotect[head];Unprotect[bar]];
(* set up the dagger relations. *)
If[eucl,xAct`xTensor`Private`SetDaggerPair[head,bar],
g0=GammaMatrix[met,Zero];
If[TrueQ@conj,
inject[{dto->head,dtobar->bar,barpa->g0,st->sbundle},Dagger[dtobar]^=Function[Module[{a=DummyIn[st]},I dto@@Append[{##}[[1;;-2]],a]barpa[-a,-Last@{##}]]];
Dagger[dto]^=Function[Module[{a=DummyIn[st]},I barpa[-Last@{##},a] dtobar@@Append[{##}[[1;;-2]],-a]]];
];
,
inject[{dto->head,dtobar->bar,barpa->g0,st->sbundle},Dagger[dto]^=Function[Module[{a=DummyIn[st]},I dtobar@@Append[{##}[[1;;-2]],a]barpa[-a,-Last@{##}]]];
Dagger[dtobar]^=Function[Module[{a=DummyIn[st]},I barpa[-Last@{##},a] dto@@Append[{##}[[1;;-2]],-a]]];
];
];
];
(* correct variational derivative for Majorana spinors *)
If[st===Majorana,
Unprotect[LeftVarD];
inject[{dto->head,dtobar->bar},
dto/:ImplicitTensorDepQ[dto,dtobar]=True;
dtobar/:ImplicitTensorDepQ[dtobar,dto]=True;
LeftVarD[dtobar[__],cd_][dto[__],lrest_,0]:=0;
LeftVarD[dtobar[__],cd_][dto[__],0,rrest_]:=0;
LeftVarD[dtobar[barinds__],cd_][dto[inds__],lrest_,rrest_]:=Module[{chain},
chain=FindSpinChain[lrest\[CenterDot]dto[inds]\[CenterDot]rrest,dto[inds],GammaMatrixQ];
LeftVarD[dtobar[barinds],cd]@@FlipSpinChain[{dto[inds],lrest,rrest},chain]
];
LeftVarD[dto[__],cd_][dtobar[__],lrest_,0]:=0;
LeftVarD[dto[__],cd_][dtobar[__],0,rrest_]:=0;
LeftVarD[dto[inds__],cd_][dtobar[barinds__],lrest_,rrest_]:=Module[{chain},
chain=FindSpinChain[lrest\[CenterDot]dtobar[barinds]\[CenterDot]rrest,dtobar[barinds],GammaMatrixQ];
LeftVarD[dto[inds],cd]@@FlipSpinChain[{dtobar[barinds],lrest,rrest},chain]
];
];
Protect[LeftVarD];
];
If[pns,Protect[head];Protect[bar]];
];
If[SpinorsPkgLoaded&&SpinorsKeepDefs,
SetNumberOfArguments[DefGenSpinor,{2,Infinity}];
Protect[DefGenSpinor];
UndefGenSpinor[x___]:=UndefGenTensor[x];
Protect[UndefGenSpinor];
,
SetNumberOfArguments[DefSpinor,{2,Infinity}];
Protect[DefSpinor];
UndefSpinor[x___]:=UndefTensor[x];
Protect[UndefSpinor];
];


(* ::Input::Initialization:: *)
If[SpinorsPkgLoaded&&SpinorsKeepDefs,
DefOddSpinor[tens_,mani_,options:OptionsPattern[{DefGenSpinor,DefTensor}]]:=DefGenSpinor[tens,mani,Flatten[{options,GradeOfTensor->{CenterDot->1}}]];
DefOddSpinor[tens_,mani_,sym_,options:OptionsPattern[{DefGenSpinor,DefTensor}]]:=DefGenSpinor[tens,mani,sym,Flatten[{options,GradeOfTensor->{CenterDot->1}}]];
DefEvenSpinor[tens_,mani_,options:OptionsPattern[{DefGenSpinor,DefTensor}]]:=DefGenSpinor[tens,mani,Flatten[{options,GradeOfTensor->{CenterDot->0}}]];
DefEvenSpinor[tens_,mani_,sym_,options:OptionsPattern[{DefGenSpinor,DefTensor}]]:=DefGenSpinor[tens,mani,sym,Flatten[{options,GradeOfTensor->{CenterDot->0}}]];
,
DefOddSpinor[tens_,mani_,options:OptionsPattern[{DefSpinor,DefTensor}]]:=DefSpinor[tens,mani,Flatten[{options,GradeOfTensor->{CenterDot->1}}]];
DefOddSpinor[tens_,mani_,sym_,options:OptionsPattern[{DefSpinor,DefTensor}]]:=DefSpinor[tens,mani,sym,Flatten[{options,GradeOfTensor->{CenterDot->1}}]];
DefEvenSpinor[tens_,mani_,options:OptionsPattern[{DefSpinor,DefTensor}]]:=DefSpinor[tens,mani,Flatten[{options,GradeOfTensor->{CenterDot->0}}]];
DefEvenSpinor[tens_,mani_,sym_,options:OptionsPattern[{DefSpinor,DefTensor}]]:=DefSpinor[tens,mani,sym,Flatten[{options,GradeOfTensor->{CenterDot->0}}]];
];
SetNumberOfArguments[DefOddSpinor,{2,Infinity}];
SetNumberOfArguments[DefEvenSpinor,{2,Infinity}];
Protect[DefEvenSpinor,DefOddSpinor];


(* ::Input::Initialization:: *)
ConjugateSpinor[f_Symbol?SpinorQ]:=If[StringLength[SymbolName[f]]>3&&StringTake[SymbolName[f],3]=="bar",Symbol[StringDrop[SymbolName[f],3]],Symbol["bar"<>SymbolName[f]]];
SetNumberOfArguments[ConjugateSpinor,1];
Protect[ConjugateSpinor];


(* ::Input::Initialization:: *)
SpinScalar[IndexFree[expr_]]:=Module[{bundles},
bundles=Flatten@Map[Function[Flatten@ConstantArray[SlotsOfTensor[First@#],Last@#]],AllTensors[IndexFree[expr]]];
Length@Select[bundles,SpinBundleQ]==Length@Select[-bundles,SpinBundleQ]
];
SetNumberOfArguments[SpinScalar,1];
Protect[SpinScalar];


(* ::Input::Initialization:: *)
(****************************** 2.8 Flip and Fierz relations ******************************)


(* ::Input::Initialization:: *)
$SpinorFlipSigns={{-1,-1,+1,+1},{-1,-1,+1,+1},{+1,-1,-1,+1},{+1,-1,-1,+1},{+1,-1,-1,+1},{+1,+1,-1,-1},{-1,+1,+1,-1},{-1,+1,+1,-1}};
Protect[$SpinorFlipSigns];


(* ::Input::Initialization:: *)
SignOfGammaMatrix[f_?GammaMatrixQ]:=With[{dimm=Mod[DimOfVBundle@Tangent@BaseOfVBundle@VBundleOfMetric@MetricOfGammaMatrix[f],8,1]},Which[GammaStarQ[f],$SpinorFlipSigns[[dimm,Mod[1+dimm,4,1]]],
GammaZeroQ[f],$SpinorFlipSigns[[dimm,2]],
True,$SpinorFlipSigns[[dimm,Mod[1+Length@SlotsOfTensor[f]-2,4,1]]]]];
SetNumberOfArguments[SignOfGammaMatrix,1];
Protect[SignOfGammaMatrix];


(* ::Input::Initialization:: *)
FindSpinChain[expr_,start_,pat_:xTensorQ,incompl_:False]:=Catch@Module[{s1,s2,gammas,gam,i},
gammas={};
If[SpinorBarQ[Head@start],
(* we start with a conjugate spinor *)
s1=start;
s2=Null;
i=Last@s1;
While[True,
s2=FirstCase[expr,(_?SpinorQ|_?pat)[___,-i,___],Null,{0,Infinity}];
If[s2===Null,If[TrueQ@incompl,Break[],Throw@Message[SpinorFlip::error1,"Found uncontracted spinor index ",i]]];
If[SpinorQ[Head@s2],Break[],AppendTo[gammas,s2];i=Last@s2;];
];
,
(* we start with a regular spinor *)
s2=start;
s1=Null;
i=-Last@s2;
While[True,
s1=FirstCase[expr,(_?SpinorQ|_?pat)[___,i,___],Null,{0,Infinity}];
If[s1===Null,If[TrueQ@incompl,Break[],Throw@Message[SpinorFlip::error1,"Found uncontracted spinor index ",i]]];
If[SpinorQ[Head@s1],Break[],AppendTo[gammas,s1];i=-s1[[-2]];];
];
];
{s1,gammas,s2}
];
SetNumberOfArguments[FindSpinChain,{2,3}];
Protect[FindSpinChain];


(* ::Input::Initialization:: *)
FlipSpinChain[expr_,chain_]:=Module[{s1,s2,gammas,dimm,sbundle,sign,rules},
s1=chain[[1]];
gammas=chain[[2]];
s2=chain[[3]];
(* cannot flip incomplete chains *)
If[s1===Null,Return[expr]];
If[s2===Null,Return[expr]];
dimm=Mod[DimOfVBundle@Tangent@BaseOfVBundle[SlotsOfTensor[Head@s1][[-1]]],8,1];
(* calculate the signs *)
sign=Power[$SpinorFlipSigns[[dimm,1]],Length[gammas]+1]Product[SignOfGammaMatrix[gammas[[k,0]]],{k,1,Length[gammas]}];
(* determine replacement rules and replace terms, taking into account that the sign table was for anticommuting spinors and we don't change the order *)
(* the sign must be put into the spinor 2 because we also use it for the LeftVarD function *)
rules=Join[{s1->ReplacePart[ConjugateSpinor[Head@s1]@@s1,-1->-Last@s1],s2->-sign ReplacePart[ConjugateSpinor[Head@s2]@@s2,-1->-Last@s2]},Rule[#1,ReplacePart[#1,{-2->-#1[[-1]],-1->-#1[[-2]]}]]&/@gammas];
expr/.rules
];
SetNumberOfArguments[FlipSpinChain,2];
Protect[FlipSpinChain];


(* ::Input::Initialization:: *)
FlipSpinor[expr_]:=Catch@Module[{s1,s2,chain},
(* an expression with a single spinor bilinear *)
s1=Cases[expr,_?SpinorBarQ[__],{0,Infinity},Heads->True];
s2=Cases[expr,_?SpinorUnbarQ[__],{0,Infinity},Heads->True];
If[Length@s1!=1,Throw@Message[FlipSpinor::toomany,"conjugate spinors",Length@s1,1]];
If[Length@s2!=1,Throw@Message[FlipSpinor::toomany,"regular spinors",Length@s2,1]];
chain=FindSpinChain[expr,First@s1,GammaMatrixQ,True];
If[First@s2=!=Last@chain,Throw@Message[FlipSpinor::error,"No spinor bilinear found"]];
FlipSpinChain[expr,chain]
];
FlipSpinor[expr_,spinor:(_Symbol?SpinorQ|_Symbol?SpinorQ[__])]:=Catch@Module[{s,chain},
s=Cases[expr,If[SpinorQ[spinor],spinor[__],spinor],{0,Infinity},Heads->True];
If[Length@s!=1,Throw@Message[FlipSpinor::error1,spinor," not found"]];
chain=FindSpinChain[expr,First@s,GammaMatrixQ,True];
FlipSpinChain[expr,chain]
];
FlipSpinor[expr_,spinor1:(_Symbol?SpinorBarQ|_Symbol?SpinorBarQ[__]),spinor2:(_Symbol?SpinorUnbarQ|_Symbol?SpinorUnbarQ[__])]:=Catch@Module[{s1,s2,chain},
s1=Cases[expr,If[SpinorQ[spinor1],spinor1[__],spinor1],{0,Infinity},Heads->True];
s2=Cases[expr,If[SpinorQ[spinor2],spinor2[__],spinor2],{0,Infinity},Heads->True];
If[Length@s1!=1,Throw@Message[FlipSpinor::toomany,"conjugate spinors",Length@s1,1]];
If[Length@s2!=1,Throw@Message[FlipSpinor::toomany,"regular spinors",Length@s2,1]];
chain=FindSpinChain[expr,First@s1,GammaMatrixQ,True];
If[First@s2=!=Last@chain,Throw@Message[FlipSpinor::error,"No spinor bilinear found"]];
FlipSpinChain[expr,chain]
];
SetNumberOfArguments[FlipSpinor,{1,3}];
Protect[FlipSpinor];


(* ::Input::Initialization:: *)
FlipSpinorsToConjugateAmount[expr_,spinor:(_Symbol?SpinorQ),barspinorcount:(_Integer?NonNegative)]:=Catch@Module[{s=If[SpinorBarQ[spinor],ConjugateSpinor[spinor],spinor],spinors,barspinors,chains,complchains,flipchains,len,bsc,bscflip},
spinors=Cases[expr,s[__],{0,Infinity},Heads->True];
barspinors=Cases[expr,ConjugateSpinor[s][__],{0,Infinity},Heads->True];
If[barspinorcount==Length@barspinors,Return[expr]];
If[barspinorcount>Length@spinors+Length@barspinors,Throw@Message[FlipSpinorsToConjugateAmount::amount,"(conjugate) spinors","conjugate spinors",Length@spinors+Length@barspinors,barspinorcount]];
chains=DeleteDuplicates@Map[FindSpinChain[expr,#,GammaMatrixQ,True]&,Join[spinors,barspinors]];
(* only take complete chains *)
complchains=Select[chains,((#[[1]]=!=Null)&&(#[[-1]]=!=Null))&];
(* check how many conjugate spinors we have in the incomplete chains *)
bsc=Count[complchains,{ConjugateSpinor[s][__],{___},_}]-Count[chains,{ConjugateSpinor[s][__],{___},_}];
If[barspinorcount-bsc>Length@complchains,Throw@Message[FlipSpinorsToConjugateAmount::amount,"spinchains","conjugate spinors",Length@chains,barspinorcount]];
(* select chains which contain different spinors at both ends *)
flipchains=Select[complchains,(#[[1,0]]=!=ConjugateSpinor[#[[-1,0]]])&];
len=Length@complchains-Length@flipchains;
If[barspinorcount-bsc<len,Throw@Message[FlipSpinorsToConjugateAmount::amount,"spinchains with same spinor at both ends","conjugate spinors",len,barspinorcount]];
(* flip enough chains *)
bscflip=Count[flipchains,{ConjugateSpinor[s][__],{___},_}];
(* we need to flip spinors *)
If[barspinorcount-bsc>bscflip+len,
chains=Select[flipchains,(#[[-1,0]]===s)&];
Return@Fold[FlipSpinChain,expr,chains[[1;;barspinorcount-bsc-bscflip-len]]]
];
(* we need to flip conjugate spinors *)
If[barspinorcount-bsc<bscflip+len,
chains=Select[flipchains,(#[[1,0]]===ConjugateSpinor[s])&];
Return@Fold[FlipSpinChain,expr,chains[[1;;bscflip+len-barspinorcount+bsc]]]
];
(* we're already fine *)
expr
];
SetNumberOfArguments[FlipSpinorsToConjugateAmount,3];
Protect[FlipSpinorsToConjugateAmount];


(* ::Input::Initialization:: *)
SortSpinor[expr:(_List|_Plus),rules:(_Rule|{_Rule...})]:=Map[SortSpinor[#,rules]&,expr];
SortSpinor[expr_,rules:({_Rule...})]:=Fold[SortSpinor,expr,rules];
SortSpinor[expr_,rules_Rule]:=Catch@Module[{spinors,chains},
If[!SpinorQ[rules[[1]]]||!SpinorQ[rules[[2]]],Throw@Message[SortSpinor::error,"Can only flip spinors"]];
If[ConjugateSpinor[rules[[1]]]=!=rules[[2]],Throw@Message[SortSpinor::error,"Can only flip a spinor into its conjugate"]];
(* Find all spinors matching the head in the expression, and include covariant derivatives *)
spinors=Cases[expr,rules[[1]][__],{0,Infinity},Heads->True];
chains=Map[FindSpinChain[expr,#,GammaMatrixQ,True]&,spinors];
Fold[FlipSpinChain,expr,chains]
];
SetNumberOfArguments[SortSpinor,2];
Protect[SortSpinor];


(* ::Input::Initialization:: *)
SpinorFlipSymmetrize[expr:(_List|_Plus)]:=Map[SpinorFlipSymmetrize,expr];
SpinorFlipSymmetrize[expr_]:=Catch@Module[{spinors,chains},
(* find all spin chains *)
spinors=Cases[expr,_?SpinorBarQ[__],{0,Infinity},Heads->True];
chains=Map[FindSpinChain[expr,#,GammaMatrixQ,True]&,spinors];
Fold[((#1+FlipSpinChain[#1,#2])/2)&,expr,chains]
];
SetNumberOfArguments[SpinorFlipSymmetrize,1];
Protect[SpinorFlipSymmetrize];


(* ::Input::Initialization:: *)
FierzExpand[cd_?CovDQ[i__]@barspinor_?SpinorBarQ[ib__],spinor_?SpinorUnbarQ[is__]]:=(FierzExpand[barspinor[ib],spinor[is]]/.{barspinor[inds__]:>cd[i]@barspinor[inds]})
FierzExpand[barspinor_?SpinorBarQ[ib__],cd_?CovDQ[i__]@spinor_?SpinorUnbarQ[is__]]:=(FierzExpand[barspinor[ib],spinor[is]]/.{spinor[inds__]:>cd[i]@spinor[inds]})
FierzExpand[cd_?CovDQ[i1__]@barspinor_?SpinorBarQ[ib__],cd_?CovDQ[i2__]@spinor_?SpinorUnbarQ[is__]]:=(FierzExpand[barspinor[ib],spinor[is]]/.{barspinor[inds__]:>cd[i1]@barspinor[inds],spinor[inds__]:>cd[i2]@spinor[inds]})
FierzExpand[barspinor:_?SpinorBarQ[__],spinor:_?SpinorUnbarQ[__]]:=Catch@Module[{sbundle,tbundle,mfold,dim,k,gname,sinds,dum1,dum2},
sinds={Last@spinor,Last@barspinor};
sbundle=VBundleOfIndex[sinds[[1]]];
tbundle=Tangent[BaseOfVBundle[sbundle]];
If[VBundleOfIndex[sinds[[2]]]=!=sbundle,Throw@Message[FierzExpand::diffbundles,sbundle,VBundleOfIndex[sinds[[2]]]]];
dim=DimOfVBundle[tbundle];
gname="Gamma"<>SymbolName[First@MetricsOfVBundle[tbundle]];
{dum1,dum2}=DummiesIn[sbundle,2];
If[Mod[dim,2]==0,2^(-dim/2)(ReplacePart[barspinor,-1->dum1]\[CenterDot]ReplacePart[spinor,-1->-dum1]delta@@sinds+Sum[1/k!(-1)^(k (k-1)/2)Module[{s,inds},s=Symbol[gname<>ToString[k]];inds=DummiesIn[tbundle,k];s@@Join[inds,sinds] ReplacePart[barspinor,-1->dum1]\[CenterDot]s@@Join[-inds,{-dum1,dum2}]\[CenterDot]ReplacePart[spinor,-1->-dum2]],{k,1,dim}]),2^(-(dim-1)/2)(ReplacePart[barspinor,-1->dum1]\[CenterDot]ReplacePart[spinor,-1->-dum1]delta@@sinds+Sum[1/k!(-1)^(k (k-1)/2)Module[{s,inds},s=Symbol[gname<>ToString[k]];inds=DummiesIn[tbundle,k];s@@Join[inds,sinds] ReplacePart[barspinor,-1->dum1]\[CenterDot]s@@Join[-inds,{-dum1,dum2}]\[CenterDot]ReplacePart[spinor,-1->-dum2]],{k,1,(dim-1)/2}])]
]
SetNumberOfArguments[FierzExpand,2]
Protect[FierzExpand];


(* ::Input::Initialization:: *)
(****************************** 2.9 Irreducible spin tensors ******************************)


(* ::Input::Initialization:: *)
IrreducibleSpinTensor[basespinor_?SpinorUnbarQ,n_Integer?Positive,rep_String]:=Catch@Module[{sbundle,tbundle,liebundle,comm,extralie},
sbundle=-Last@SlotsOfTensor[basespinor];
tbundle=Tangent@BaseOfVBundle[sbundle];
(* only works in 4D so far *)
If[(DimOfVBundle[sbundle]!=4)||(DimOfVBundle[tbundle]!=4),Throw@Message[IrreducibleSpinTensor::wrongdim,DimOfVBundle[sbundle],DimOfVBundle[tbundle]]];
(* and at most one lie algebra index *)
If[Length@SlotsOfTensor[basespinor]>2,Throw@Message[IrreducibleSpinTensor::toomanyinds,Length@SlotsOfTensor[basespinor]-1]];
If[Length@SlotsOfTensor[basespinor]==2,liebundle=First@SlotsOfTensor[basespinor];If[!VBundleQ[liebundle],liebundle=-liebundle],liebundle=Null];
If[(Length@SlotsOfTensor[basespinor]>1)&&(tbundle===liebundle),Throw@Message[IrreducibleSpinTensor::nolie]];
(* and Majorana spinors *)
If[!MajoranaQ[basespinor],Throw@Message[IrreducibleSpinTensor::nomajorana]];
comm=(GradeOfTensor[basespinor,CenterDot]==0);
extralie=(Length@SlotsOfTensor[basespinor]>1);
Switch[n,
0,ZeroTensor,
1,basespinor,
(* two-spinor irreducibles *)
2,Which[
(comm)&&(!extralie),
If[MemberQ[{"4","6"},rep],defIrrSTensor[basespinor,sbundle,tbundle,liebundle,comm,extralie,n,rep],Throw@Message[IrreducibleSpinTensor::invalidrep,rep]],
(!comm)&&(!extralie),
If[MemberQ[{"1","4","1'"},rep],defIrrSTensor[basespinor,sbundle,tbundle,liebundle,comm,extralie,n,rep],Throw@Message[IrreducibleSpinTensor::invalidrep,rep]],
(comm)&&(extralie),
If[MemberQ[{"d(d-1)/2","2d(d+1)","3d(d+1)","2d(d-1)","d(d-1)/2'"},rep],defIrrSTensor[basespinor,sbundle,tbundle,liebundle,comm,extralie,n,rep],Throw@Message[IrreducibleSpinTensor::invalidrep,rep]],
(!comm)&&(extralie),
If[MemberQ[{"d(d+1)/2","2d(d-1)","3d(d-1)","2d(d+1)","d(d+1)/2'"},rep],defIrrSTensor[basespinor,sbundle,tbundle,liebundle,comm,extralie,n,rep],Throw@Message[IrreducibleSpinTensor::invalidrep,rep]]
],
(* three-spinor irreducibles *)
3,Which[
(comm)&&(!extralie),
If[MemberQ[{"8","12"},rep],defIrrSTensor[basespinor,sbundle,tbundle,liebundle,comm,extralie,n,rep],Throw@Message[IrreducibleSpinTensor::invalidrep,rep]],
(!comm)&&(!extralie),
If[MemberQ[{"4"},rep],defIrrSTensor[basespinor,sbundle,tbundle,liebundle,comm,extralie,n,rep],Throw@Message[IrreducibleSpinTensor::invalidrep,rep]],
(comm)&&(extralie),
If[MemberQ[{"2d(d-1)(d-2)/3","4d(d+1)(d-1)/3","2d(d+1)(d+2)","4d(d+1)(d-1)","4d(d+1)(d+2)/3","4d(d+1)(d-1)/3*"},rep],defIrrSTensor[basespinor,sbundle,tbundle,liebundle,comm,extralie,n,rep],Throw@Message[IrreducibleSpinTensor::invalidrep,rep]],
(!comm)&&(extralie),
If[MemberQ[{"2d(d+1)(d+2)/3","4d(d+1)(d-1)/3","2d(d-1)(d-2)","4d(d+1)(d-1)","4d(d-1)(d-2)/3","4d(d+1)(d-1)/3*"},rep],defIrrSTensor[basespinor,sbundle,tbundle,liebundle,comm,extralie,n,rep],Throw@Message[IrreducibleSpinTensor::invalidrep,rep]]
],
(* four-spinor irreducibles only for spinors without extra lie index *)
4,Which [
(comm)&&(!extralie),
If[MemberQ[{"9","10","16"},rep],defIrrSTensor[basespinor,sbundle,tbundle,liebundle,comm,extralie,n,rep],Throw@Message[IrreducibleSpinTensor::invalidrep,rep]],
(!comm)&&(!extralie),
If[MemberQ[{"1"},rep],defIrrSTensor[basespinor,sbundle,tbundle,liebundle,comm,extralie,n,rep],Throw@Message[IrreducibleSpinTensor::invalidrep,rep]],
True,Throw@Message[IrreducibleSpinTensor::notimpl]],
(* higher irreducibles only for anticommuting spinors without extra lie index *)
_,If[(!comm)&&(!extralie),ZeroTensor,Throw@Message[IrreducibleSpinTensor::notimpl]]
]
];
SetNumberOfArguments[IrreducibleSpinTensor,3];
Protect[IrreducibleSpinTensor];


(* ::Input::Initialization:: *)
IrreducibleSpinTensorQ[_]:=False;
SetNumberOfArguments[IrreducibleSpinTensorQ,1];
Protect[IrreducibleSpinTensorQ];


(* ::Input::Initialization:: *)
defIrrSTensor[basespinor_,sbundle_,tbundle_,liebundle_,comm_,extralie_,n_,rep_]:=Module[{tens,ttens,prot},
(* define irreducible head if not yet defined *)
tens=Symbol["Irr"<>SymbolName[sbundle]];
If[!xAct`xTensor`xTensorQ[tens[1,2,3,4,5]],
xUpSetDelayed[xAct`xTensor`xTensorQ[tens[spinor_,count_,replabel_,slots_,sym_]],True];
xUpSetDelayed[IrreducibleSpinTensorQ[tens],True];
inject[{ttens->tens},xAct`xTensor`PrintAs[ttens[spinor_,count_,replabel_,slots_,sym_]]^:=RowBox[{SuperscriptBox["Irr"<>xAct`xTensor`PrintAs[sbundle],RowBox[{"(",count,",",StyleBox[replabel,Bold],")"}]],"[",xAct`xTensor`PrintAs[spinor],"]"}]];
inject[{ttens->tens},xAct`TexAct`Tex[ttens[spinor_,count_,replabel_,slots_,sym_]]:="\\mathrm{Irr}"<>xAct`TexAct`Tex[sbundle]<>"^{("<>ToString[count]<>",\\mathbf{"<>replabel<>"})}["<>xAct`TexAct`Tex[spinor]<>"]"];
xAct`xTensor`SlotsOfTensor[tens[spinor_,count_,replabel_,slots_,sym_]]^:=slots;
xAct`xTensor`DependenciesOfTensor[tens[spinor_,count_,replabel_,slots_,sym_]]^:=xAct`xTensor`DependenciesOfTensor[spinor];
xAct`xTensor`DefInfo[tens[spinor_,count_,replabel_,slots_,sym_]]^:={"tensor","Irreducible spin tensor constructed from "<>SymbolName[spinor]<>" ."};
xAct`xTensor`HostsOf[tens[spinor_,count_,replabel_,slots_,sym_]]^:={};
xAct`xTensor`TensorID[tens[spinor_,count_,replabel_,slots_,sym_]]^:={};
xAct`xTensor`SymmetryGroupOfTensor[tens[spinor_,count_,replabel_,slots_,sym_]]^:=sym;
prot=Unprotect[CenterDot];
xAct`xTensor`GradeOfTensor[tens[spinor_,count_,replabel_,slots_,sym_],CenterDot]^:=xAct`xTensor`GradeOfTensor[spinor,CenterDot]*count;
Protect[prot];
];
(* return the actual irreducible. we do not need defaults, which are handled by the user-exposed function. *)
Switch[n,
(* two-spinor irreducibles *)
2,Which[
(comm)&&(!extralie),Switch[rep,
"4",tens[basespinor,2,"4",{tbundle},StrongGenSet[{},GenSet[]]],
"6",tens[basespinor,2,"6",{tbundle,tbundle},StrongGenSet[{1,2},GenSet[-Cycles[{1,2}]]]]
],
(!comm)&&(!extralie),Switch[rep,
"1",tens[basespinor,2,"1",{},StrongGenSet[{},GenSet[]]],
"4",tens[basespinor,2,"4",{tbundle},StrongGenSet[{},GenSet[]]],
"1'",tens[basespinor,2,"1'",{},StrongGenSet[{},GenSet[]]]
],
(comm)&&(extralie),Switch[rep,
"d(d-1)/2",tens[basespinor,2,"d(d-1)/2",{liebundle,liebundle},StrongGenSet[{1,2},GenSet[-Cycles[{1,2}]]]],
"2d(d+1)",tens[basespinor,2,"2d(d+1)",{liebundle,liebundle,tbundle},StrongGenSet[{1,2},GenSet[Cycles[{1,2}]]]],
"3d(d+1)",tens[basespinor,2,"3d(d+1)",{liebundle,liebundle,tbundle,tbundle},StrongGenSet[{1,2,3,4},GenSet[Cycles[{1,2}],-Cycles[{3,4}]]]],
"2d(d-1)",tens[basespinor,2,"2d(d-1)",{liebundle,liebundle,tbundle},StrongGenSet[{1,2},GenSet[-Cycles[{1,2}]]]],
"d(d-1)/2'",tens[basespinor,2,"d(d-1)/2'",{liebundle,liebundle},StrongGenSet[{1,2},GenSet[-Cycles[{1,2}]]]]
],
(!comm)&&(extralie),Switch[rep,
"d(d+1)/2",tens[basespinor,2,"d(d+1)/2",{liebundle,liebundle},StrongGenSet[{1,2},GenSet[Cycles[{1,2}]]]],
"2d(d-1)",tens[basespinor,2,"2d(d-1)",{liebundle,liebundle,tbundle},StrongGenSet[{1,2},GenSet[-Cycles[{1,2}]]]],
"3d(d-1)",tens[basespinor,2,"3d(d-1)",{liebundle,liebundle,tbundle,tbundle},StrongGenSet[{1,2,3,4},GenSet[-Cycles[{1,2}],-Cycles[{3,4}]]]],
"2d(d+1)",tens[basespinor,2,"2d(d+1)",{liebundle,liebundle,tbundle},StrongGenSet[{1,2},GenSet[Cycles[{1,2}]]]],
"d(d+1)/2'",tens[basespinor,2,"d(d+1)/2'",{liebundle,liebundle},StrongGenSet[{1,2},GenSet[Cycles[{1,2}]]]]
]
],
(* three-spinor irreducibles *)
3,Which[
(comm)&&(!extralie),Switch[rep,
"8",tens[basespinor,3,"8",{tbundle,tbundle,-sbundle},StrongGenSet[{1,2},GenSet[-Cycles[{1,2}]]]],
"12",tens[basespinor,3,"12",{tbundle,-sbundle},StrongGenSet[{},GenSet[]]]
],
(!comm)&&(!extralie),Switch[rep,
"4",tens[basespinor,3,"4",{-sbundle},StrongGenSet[{},GenSet[]]]
],
(comm)&&(extralie),Switch[rep,
"2d(d-1)(d-2)/3",tens[basespinor,3,"2d(d-1)(d-2)/3",{liebundle,liebundle,liebundle,-sbundle},StrongGenSet[{1,2,3},GenSet[-Cycles[{1,2}],-Cycles[{2,3}]]]],
"4d(d+1)(d-1)/3",tens[basespinor,3,"4d(d+1)(d-1)/3",{liebundle,liebundle,liebundle,-sbundle},StrongGenSet[{1,2},GenSet[-Cycles[{1,2}]]]],
"2d(d+1)(d+2)",tens[basespinor,3,"2d(d+1)(d+2)",{liebundle,liebundle,liebundle,tbundle,-sbundle},StrongGenSet[{1,2,3},GenSet[Cycles[{1,2}],Cycles[{2,3}]]]],
"4d(d+1)(d-1)",tens[basespinor,3,"4d(d+1)(d-1)",{liebundle,liebundle,liebundle,tbundle,-sbundle},StrongGenSet[{1,2},GenSet[Cycles[{1,2}]]]],
"4d(d+1)(d-1)/3*",tens[basespinor,3,"4d(d+1)(d-1)/3*",{liebundle,liebundle,liebundle,-sbundle},StrongGenSet[{1,2},GenSet[-Cycles[{1,2}]]]],
"4d(d+1)(d+2)/3",tens[basespinor,3,"4d(d+1)(d+2)/3",{liebundle,liebundle,liebundle,tbundle,tbundle,-sbundle},StrongGenSet[{1,2,3,4,5},GenSet[Cycles[{1,2}],Cycles[{2,3}],-Cycles[{4,5}]]]]
],
(!comm)&&(extralie),Switch[rep,
"2d(d+1)(d+2)/3",tens[basespinor,3,"2d(d+1)(d+2)/3",{liebundle,liebundle,liebundle,-sbundle},StrongGenSet[{1,2,3},GenSet[Cycles[{1,2}],Cycles[{2,3}]]]],
"4d(d+1)(d-1)/3",tens[basespinor,3,"4d(d+1)(d-1)/3",{liebundle,liebundle,liebundle,-sbundle},StrongGenSet[{1,2},GenSet[Cycles[{1,2}]]]],
"2d(d-1)(d-2)",tens[basespinor,3,"2d(d-1)(d-2)",{liebundle,liebundle,liebundle,tbundle,-sbundle},StrongGenSet[{1,2,3},GenSet[-Cycles[{1,2}],-Cycles[{2,3}]]]],
"4d(d+1)(d-1)",tens[basespinor,3,"4d(d+1)(d-1)",{liebundle,liebundle,liebundle,tbundle,-sbundle},StrongGenSet[{1,2},GenSet[-Cycles[{1,2}]]]],
"4d(d+1)(d-1)/3*",tens[basespinor,3,"4d(d+1)(d-1)/3*",{liebundle,liebundle,liebundle,-sbundle},StrongGenSet[{1,2},GenSet[Cycles[{1,2}]]]],
"4d(d-1)(d-2)/3",tens[basespinor,3,"4d(d-1)(d-2)/3",{liebundle,liebundle,liebundle,tbundle,tbundle,-sbundle},StrongGenSet[{1,2,3,4,5},GenSet[-Cycles[{1,2}],-Cycles[{2,3}],-Cycles[{4,5}]]]]
]
],
(* four-spinor irreducibles only for spinors without extra lie index *)
4,Which [
(comm)&&(!extralie),Switch[rep,
"9",tens[basespinor,4,"9",{tbundle,tbundle},StrongGenSet[{1,2},GenSet[Cycles[{1,2}]]]],
"10",tens[basespinor,4,"10",{tbundle,tbundle,tbundle,tbundle},StrongGenSet[{1,2,3,4},GenSet[-Cycles[{1,2}],-Cycles[{3,4}],Cycles[{1,3},{2,4}]]]],
"16",tens[basespinor,4,"16",{tbundle,tbundle,tbundle},StrongGenSet[{2,3},GenSet[-Cycles[{2,3}]]]]
],
(!comm)&&(!extralie),Switch[rep,
"1",tens[basespinor,4,"1",{},StrongGenSet[{},GenSet[]]]
]
]
]
]


(* ::Input::Initialization:: *)
ExpandIrreducibleSpinTensor[tens_?IrreducibleSpinTensorQ[spinor_,count_,rep_,slots_,sym_][inds___]]:=Catch@Module[{cs,ilist,sbundle,tbundle,met,gamma,eps,liebundle,comm,extralie},
cs=ConjugateSpinor[spinor];
ilist={inds};
sbundle=-Last@SlotsOfTensor[spinor];
tbundle=Tangent@BaseOfVBundle[sbundle];
met=First@MetricsOfVBundle[tbundle];
gamma=Symbol["Gamma"<>SymbolName[met]];
eps=epsilon[met];
If[Length@SlotsOfTensor[spinor]==2,liebundle=First@SlotsOfTensor[spinor];If[!VBundleQ[liebundle],liebundle=-liebundle],liebundle=Null];
comm=(GradeOfTensor[spinor,CenterDot]==0);
extralie=(Length@SlotsOfTensor[spinor]>1);
Switch[count,
2,Which[
(comm)&&(!extralie),Switch[rep,
"4",With[{A=DummyIn@sbundle,B=DummyIn@sbundle},cs[A]\[CenterDot]gamma[inds,-A,B]\[CenterDot]spinor[-B]],
"6",With[{A=DummyIn@sbundle,B=DummyIn@sbundle},cs[A]\[CenterDot]gamma[inds,-A,B]\[CenterDot]spinor[-B]]
],
(!comm)&&(!extralie),Switch[rep,
"1",With[{A=DummyIn@sbundle},cs[A]\[CenterDot]spinor[-A]],
"4",With[{A=DummyIn@sbundle,B=DummyIn@sbundle,mu=DummyIn@tbundle,nu=DummyIn@tbundle,rho=DummyIn@tbundle},1/6 eps[inds,mu,nu,rho]cs[A]\[CenterDot]gamma[-mu,-nu,-rho,-A,B]\[CenterDot]spinor[-B]],
"1'",With[{A=DummyIn@sbundle,B=DummyIn@sbundle,mu=DummyIn@tbundle,nu=DummyIn@tbundle,rho=DummyIn@tbundle,sigma=DummyIn@tbundle},1/24 eps[mu,nu,rho,sigma]cs[A]\[CenterDot]gamma[-mu,-nu,-rho,-sigma,-A,B]\[CenterDot]spinor[-B]]
],
(comm)&&(extralie),Switch[rep,
"d(d-1)/2",Antisymmetrize[With[{A=DummyIn@sbundle},cs[ilist[[1]],A]\[CenterDot]spinor[ilist[[2]],-A]],ilist[[1;;2]]],
"2d(d+1)",Symmetrize[With[{A=DummyIn@sbundle,B=DummyIn@sbundle},cs[ilist[[1]],A]\[CenterDot]gamma[ilist[[3]],-A,B]\[CenterDot]spinor[ilist[[2]],-B]],ilist[[1;;2]]],
"3d(d+1)",Symmetrize[With[{A=DummyIn@sbundle,B=DummyIn@sbundle},cs[ilist[[1]],A]\[CenterDot]gamma[ilist[[3]],ilist[[4]],-A,B]\[CenterDot]spinor[ilist[[2]],-B]],ilist[[1;;2]]],
"2d(d-1)",Antisymmetrize[With[{A=DummyIn@sbundle,B=DummyIn@sbundle,mu=DummyIn@tbundle,nu=DummyIn@tbundle,rho=DummyIn@tbundle},1/6eps[ilist[[3]],mu,nu,rho]cs[ilist[[1]],A]\[CenterDot]gamma[-mu,-nu,-rho,-A,B]\[CenterDot]spinor[ilist[[2]],-B]],ilist[[1;;2]]],
"d(d-1)/2'",Antisymmetrize[With[{A=DummyIn@sbundle,B=DummyIn@sbundle,mu=DummyIn@tbundle,nu=DummyIn@tbundle,rho=DummyIn@tbundle,sigma=DummyIn@tbundle},1/24eps[mu,nu,rho,sigma]cs[ilist[[1]],A]\[CenterDot]gamma[-mu,-nu,-rho,-sigma,-A,B]\[CenterDot]spinor[ilist[[2]],-B]],ilist[[1;;2]]]
],
(!comm)&&(extralie),Switch[rep,
"d(d+1)/2",Symmetrize[With[{A=DummyIn@sbundle},cs[ilist[[1]],A]\[CenterDot]spinor[ilist[[2]],-A]],ilist[[1;;2]]],
"2d(d-1)",Antisymmetrize[With[{A=DummyIn@sbundle,B=DummyIn@sbundle},cs[ilist[[1]],A]\[CenterDot]gamma[ilist[[3]],-A,B]\[CenterDot]spinor[ilist[[2]],-B]],ilist[[1;;2]]],
"3d(d-1)",Antisymmetrize[With[{A=DummyIn@sbundle,B=DummyIn@sbundle},cs[ilist[[1]],A]\[CenterDot]gamma[ilist[[3]],ilist[[4]],-A,B]\[CenterDot]spinor[ilist[[2]],-B]],ilist[[1;;2]]],
"2d(d+1)",Symmetrize[With[{A=DummyIn@sbundle,B=DummyIn@sbundle,mu=DummyIn@tbundle,nu=DummyIn@tbundle,rho=DummyIn@tbundle},1/6eps[ilist[[3]],mu,nu,rho]cs[ilist[[1]],A]\[CenterDot]gamma[-mu,-nu,-rho,-A,B]\[CenterDot]spinor[ilist[[2]],-B]],ilist[[1;;2]]],
"d(d+1)/2'",Symmetrize[With[{A=DummyIn@sbundle,B=DummyIn@sbundle,mu=DummyIn@tbundle,nu=DummyIn@tbundle,rho=DummyIn@tbundle,sigma=DummyIn@tbundle},1/24eps[mu,nu,rho,sigma]cs[ilist[[1]],A]\[CenterDot]gamma[-mu,-nu,-rho,-sigma,-A,B]\[CenterDot]spinor[ilist[[2]],-B]],ilist[[1;;2]]]
]
],
3,Which[
(*TODO*)(comm)&&(!extralie),Switch[rep,
"8",With[{A=DummyIn@sbundle,B=DummyIn@sbundle,K=DummyIn@sbundle},cs[A]\[CenterDot]gamma[ilist[[1]],ilist[[2]],-A,B]\[CenterDot]spinor[-B]\[CenterDot]spinor[ilist[[3]]]+1/2(gamma[ilist[[1]],ilist[[3]],A]\[CenterDot]cs[B]\[CenterDot]gamma[ilist[[2]],-B,K]\[CenterDot]spinor[-K]\[CenterDot]spinor[-A]-gamma[ilist[[2]],ilist[[3]],A]\[CenterDot]cs[B]\[CenterDot]gamma[ilist[[1]],-B,K]\[CenterDot]spinor[-K]\[CenterDot]spinor[-A])],
"12",With[{A=DummyIn@sbundle,B=DummyIn@sbundle},cs[A]\[CenterDot]gamma[ilist[[1]],-A,B]\[CenterDot]spinor[-B]\[CenterDot]spinor[ilist[[2]]]]
],
(!comm)&&(!extralie),Switch[rep,
"4",With[{A=DummyIn@sbundle},cs[A]\[CenterDot]spinor[-A]\[CenterDot]spinor[ilist[[1]]]]
],
(comm)&&(extralie),Switch[rep,
"2d(d-1)(d-2)/3",Antisymmetrize[ExpandIrreducibleSpinTensor[tens[spinor,2,"d(d-1)/2",{liebundle,liebundle},Null][ilist[[1]],ilist[[2]]]]spinor[ilist[[3]],ilist[[4]]],ilist[[1;;3]]],
"4d(d+1)(d-1)/3",2/3ExpandIrreducibleSpinTensor[tens[spinor,2,"d(d-1)/2",{liebundle,liebundle},Null][ilist[[1]],ilist[[2]]]]spinor[ilist[[3]],ilist[[4]]]-2/3Antisymmetrize[ExpandIrreducibleSpinTensor[tens[spinor,2,"d(d-1)/2",{liebundle,liebundle},Null][ilist[[3]],ilist[[1]]]]\[CenterDot]spinor[ilist[[2]],ilist[[4]]],ilist[[1;;2]]],
"4d(d+1)(d-1)/3*",With[{mu=DummyIn@tbundle,nu=DummyIn@tbundle,rho=DummyIn@tbundle,sigma=DummyIn@tbundle,A=DummyIn@sbundle},1/24eps[mu,nu,rho,sigma]gamma[-mu,-nu,-rho,-sigma,ilist[[4]],A](2/3ExpandIrreducibleSpinTensor[tens[spinor,2,"d(d-1)/2'",{liebundle,liebundle},Null][ilist[[1]],ilist[[2]]]]spinor[ilist[[3]],-A]-2/3Antisymmetrize[ExpandIrreducibleSpinTensor[tens[spinor,2,"d(d-1)/2'",{liebundle,liebundle},Null][ilist[[3]],ilist[[1]]]]spinor[ilist[[2]],-A],ilist[[1;;2]]])],
"2d(d+1)(d+2)",With[{A=DummyIn@sbundle,nu=DummyIn@tbundle},Symmetrize[3/4ExpandIrreducibleSpinTensor[tens[spinor,2,"2d(d+1)",{liebundle,liebundle,tbundle},Null][ilist[[1]],ilist[[2]],ilist[[4]]]]\[CenterDot]spinor[ilist[[3]],ilist[[5]]]-1/4gamma[ilist[[4]],nu,ilist[[5]],A]\[CenterDot]ExpandIrreducibleSpinTensor[tens[spinor,2,"2d(d+1)",{liebundle,liebundle,tbundle},Null][ilist[[1]],ilist[[2]],-nu]]\[CenterDot]spinor[ilist[[3]],-A],ilist[[1;;3]]]],
"4d(d+1)(d-1)",With[{A=DummyIn@sbundle,nu=DummyIn@tbundle},1/2ExpandIrreducibleSpinTensor[tens[spinor,2,"2d(d+1)",{liebundle,liebundle,tbundle},Null][ilist[[1]],ilist[[2]],ilist[[4]]]]\[CenterDot]spinor[ilist[[3]],ilist[[5]]]-1/2Symmetrize[ExpandIrreducibleSpinTensor[tens[spinor,2,"2d(d+1)",{liebundle,liebundle,tbundle},Null][ilist[[3]],ilist[[1]],ilist[[4]]]]\[CenterDot]spinor[ilist[[2]],ilist[[5]]],ilist[[1;;2]]]-1/6gamma[ilist[[4]],nu,ilist[[5]],A]\[CenterDot]ExpandIrreducibleSpinTensor[tens[spinor,2,"2d(d+1)",{liebundle,liebundle,tbundle},Null][ilist[[1]],ilist[[2]],-nu]]\[CenterDot]spinor[ilist[[3]],-A]+1/6Symmetrize[gamma[ilist[[4]],nu,ilist[[5]],A]\[CenterDot]ExpandIrreducibleSpinTensor[tens[spinor,2,"2d(d+1)",{liebundle,liebundle,tbundle},Null][ilist[[3]],ilist[[1]],-nu]]\[CenterDot]spinor[ilist[[2]],-A],ilist[[1;;2]]]],
"4d(d+1)(d+2)/3",With[{A=DummyIn@sbundle,rho=DummyIn@tbundle,sigma=DummyIn@tbundle},Symmetrize[1/3 ExpandIrreducibleSpinTensor[tens[spinor,2,"3d(d+1)",{liebundle,liebundle,tbundle,tbundle},Null][ilist[[1]],ilist[[2]],ilist[[4]],ilist[[5]]]]spinor[ilist[[3]],ilist[[6]]]-1/6(gamma[rho,ilist[[4]],ilist[[6]],A]ExpandIrreducibleSpinTensor[tens[spinor,2,"3d(d+1)",{liebundle,liebundle,tbundle,tbundle},Null][ilist[[1]],ilist[[2]],ilist[[5]],-rho]]-gamma[rho,ilist[[5]],ilist[[6]],A]ExpandIrreducibleSpinTensor[tens[spinor,2,"3d(d+1)",{liebundle,liebundle,tbundle,tbundle},Null][ilist[[1]],ilist[[2]],ilist[[4]],-rho]])spinor[ilist[[3]],-A]-1/6gamma[ilist[[4]],ilist[[5]],rho,sigma,ilist[[6]],A]ExpandIrreducibleSpinTensor[tens[spinor,2,"3d(d+1)",{liebundle,liebundle,tbundle,tbundle},Null][ilist[[1]],ilist[[2]],-rho,-sigma]]spinor[ilist[[3]],-A],ilist[[1;;3]]]]
],
(!comm)&&(extralie),Switch[rep,
"2d(d+1)(d+2)/3",Symmetrize[ExpandIrreducibleSpinTensor[tens[spinor,2,"d(d+1)/2",{liebundle,liebundle},Null][ilist[[1]],ilist[[2]]]]\[CenterDot]spinor[ilist[[3]],ilist[[4]]],ilist[[1;;3]]],
"4d(d+1)(d-1)/3",2/3ExpandIrreducibleSpinTensor[tens[spinor,2,"d(d+1)/2",{liebundle,liebundle},Null][ilist[[1]],ilist[[2]]]]\[CenterDot]spinor[ilist[[3]],ilist[[4]]]-2/3Symmetrize[ExpandIrreducibleSpinTensor[tens[spinor,2,"d(d+1)/2",{liebundle,liebundle},Null][ilist[[3]],ilist[[1]]]]\[CenterDot]spinor[ilist[[2]],ilist[[4]]],ilist[[1;;2]]],
"4d(d+1)(d-1)/3*",With[{mu=DummyIn@tbundle,nu=DummyIn@tbundle,rho=DummyIn@tbundle,sigma=DummyIn@tbundle,A=DummyIn@sbundle},1/24eps[mu,nu,rho,sigma]gamma[-mu,-nu,-rho,-sigma,ilist[[4]],A]\[CenterDot](2/3ExpandIrreducibleSpinTensor[tens[spinor,2,"d(d+1)/2'",{liebundle,liebundle},Null][ilist[[1]],ilist[[2]]]]\[CenterDot]spinor[ilist[[3]],-A]-2/3Symmetrize[ExpandIrreducibleSpinTensor[tens[spinor,2,"d(d+1)/2'",{liebundle,liebundle},Null][ilist[[3]],ilist[[1]]]]\[CenterDot]spinor[ilist[[2]],-A],ilist[[1;;2]]])],
"2d(d-1)(d-2)",With[{A=DummyIn@sbundle,nu=DummyIn@tbundle},Antisymmetrize[3/4ExpandIrreducibleSpinTensor[tens[spinor,2,"2d(d-1)",{liebundle,liebundle,tbundle},Null][ilist[[1]],ilist[[2]],ilist[[4]]]]\[CenterDot]spinor[ilist[[3]],ilist[[5]]]-1/4gamma[ilist[[4]],nu,ilist[[5]],A]\[CenterDot]ExpandIrreducibleSpinTensor[tens[spinor,2,"2d(d-1)",{liebundle,liebundle,tbundle},Null][ilist[[1]],ilist[[2]],-nu]]\[CenterDot]spinor[ilist[[3]],-A],ilist[[1;;3]]]],
"4d(d+1)(d-1)",With[{A=DummyIn@sbundle,nu=DummyIn@tbundle},1/2ExpandIrreducibleSpinTensor[tens[spinor,2,"2d(d-1)",{liebundle,liebundle,tbundle},Null][ilist[[1]],ilist[[2]],ilist[[4]]]]\[CenterDot]spinor[ilist[[3]],ilist[[5]]]-1/2Antisymmetrize[ExpandIrreducibleSpinTensor[tens[spinor,2,"2d(d-1)",{liebundle,liebundle},Null][ilist[[3]],ilist[[1]],ilist[[4]]]]\[CenterDot]spinor[ilist[[2]],ilist[[5]]],ilist[[1;;2]]]-1/6gamma[ilist[[4]],nu,ilist[[5]],A]\[CenterDot]ExpandIrreducibleSpinTensor[tens[spinor,2,"2d(d-1)",{liebundle,liebundle,tbundle},Null][ilist[[1]],ilist[[2]],-nu]]\[CenterDot]spinor[ilist[[3]],-A]+1/6Antisymmetrize[gamma[ilist[[4]],nu,ilist[[5]],A]\[CenterDot]ExpandIrreducibleSpinTensor[tens[spinor,2,"2d(d-1)",{liebundle,liebundle,tbundle},Null][ilist[[3]],ilist[[1]],-nu]]\[CenterDot]spinor[ilist[[2]],-A],ilist[[1;;2]]]],
"4d(d-1)(d-2)/3",With[{A=DummyIn@sbundle,rho=DummyIn@tbundle,sigma=DummyIn@tbundle},Antisymmetrize[1/3 ExpandIrreducibleSpinTensor[tens[spinor,2,"3d(d-1)",{liebundle,liebundle,tbundle,tbundle},Null][ilist[[1]],ilist[[2]],ilist[[4]],ilist[[5]]]]\[CenterDot]spinor[ilist[[3]],ilist[[6]]]-1/6(gamma[rho,ilist[[4]],ilist[[6]],A]ExpandIrreducibleSpinTensor[tens[spinor,2,"3d(d-1)",{liebundle,liebundle,tbundle,tbundle},Null][ilist[[1]],ilist[[2]],ilist[[5]],-rho]]-gamma[rho,ilist[[5]],ilist[[6]],A]ExpandIrreducibleSpinTensor[tens[spinor,2,"3d(d-1)",{liebundle,liebundle,tbundle,tbundle},Null][ilist[[1]],ilist[[2]],ilist[[4]],-rho]])\[CenterDot]spinor[ilist[[3]],-A]-1/6gamma[ilist[[4]],ilist[[5]],rho,sigma,ilist[[6]],A]ExpandIrreducibleSpinTensor[tens[spinor,2,"3d(d-1)",{liebundle,liebundle,tbundle,tbundle},Null][ilist[[1]],ilist[[2]],-rho,-sigma]]\[CenterDot]spinor[ilist[[3]],-A],ilist[[1;;3]]]]
]
],
4,Which[
(comm)&&(!extralie),Switch[rep,
"9",With[{A=DummyIn@sbundle,B=DummyIn@sbundle,K=DummyIn@sbundle,L=DummyIn@sbundle},cs[A]\[CenterDot]gamma[ilist[[1]],-A,B]\[CenterDot]spinor[-B]cs[K]\[CenterDot]gamma[ilist[[2]],-K,L]\[CenterDot]spinor[-L]],
"10",With[{A=DummyIn@sbundle,B=DummyIn@sbundle,K=DummyIn@sbundle,L=DummyIn@sbundle,alpha=DummyIn@tbundle,beta=DummyIn@tbundle},cs[A]\[CenterDot]gamma[ilist[[1]],ilist[[2]],-A,B]\[CenterDot]spinor[-B]cs[K]\[CenterDot]gamma[ilist[[3]],ilist[[4]],-K,L]\[CenterDot]spinor[-L]-1/2(cs[A]\[CenterDot]gamma[alpha,ilist[[1]],-A,B]\[CenterDot]spinor[-B]met[ilist[[2]],ilist[[3]]]cs[K]\[CenterDot]gamma[ilist[[4]],-alpha,-K,L]\[CenterDot]spinor[-L]-cs[A]\[CenterDot]gamma[alpha,ilist[[2]],-A,B]\[CenterDot]spinor[-B]met[ilist[[1]],ilist[[3]]]cs[K]\[CenterDot]gamma[ilist[[4]],-alpha,-K,L]\[CenterDot]spinor[-L]-cs[A]\[CenterDot]gamma[alpha,ilist[[1]],-A,B]\[CenterDot]spinor[-B]met[ilist[[2]],ilist[[4]]]cs[K]\[CenterDot]gamma[ilist[[3]],-alpha,-K,L]\[CenterDot]spinor[-L]+cs[A]\[CenterDot]gamma[alpha,ilist[[2]],-A,B]\[CenterDot]spinor[-B]met[ilist[[1]],ilist[[4]]]cs[K]\[CenterDot]gamma[ilist[[3]],-alpha,-K,L]\[CenterDot]spinor[-L])+1/6(met[ilist[[1]],ilist[[3]]]met[ilist[[2]],ilist[[4]]]-met[ilist[[1]],ilist[[4]]]met[ilist[[2]],ilist[[3]]])cs[A]\[CenterDot]gamma[alpha,beta,-A,B]\[CenterDot]spinor[-B]cs[K]\[CenterDot]gamma[-alpha,-beta,-K,L]\[CenterDot]spinor[-L]],
"16",With[{A=DummyIn@sbundle,B=DummyIn@sbundle,K=DummyIn@sbundle,L=DummyIn@sbundle},1/2(cs[A]\[CenterDot]gamma[ilist[[1]],-A,B]\[CenterDot]spinor[-B] cs[K]\[CenterDot]gamma[ilist[[2]],ilist[[3]],-K,L]\[CenterDot]spinor[-L]+cs[A]\[CenterDot]gamma[ilist[[2]],-A,B]\[CenterDot]spinor[-B] cs[K]\[CenterDot]gamma[ilist[[1]],ilist[[3]],-K,L]\[CenterDot]spinor[-L])]
],
(!comm)&&(!extralie),Switch[rep,
"1",With[{A=DummyIn@sbundle,B=DummyIn@sbundle},cs[A]\[CenterDot]spinor[-A]\[CenterDot]cs[B]\[CenterDot]spinor[-B]]
],
(comm)&&(extralie),Throw@Message[IrreducibleSpinTensor::notimpl],
(!comm)&&(extralie),Throw@Message[IrreducibleSpinTensor::notimpl]
],
_,Throw@Message[ExpandIrreducibleSpinTensor::error,"Malformed irreducible tensor: too many base spinors"]
]
];
SetNumberOfArguments[ExpandIrreducibleSpinTensor,1];
Protect[ExpandIrreducibleSpinTensor];


(* ::Input::Initialization:: *)
ExpandIrreducibleSpinTensors[expr_]:=expr/.{tens_?IrreducibleSpinTensorQ[defs__][inds___]:>ExpandIrreducibleSpinTensor[tens[defs][inds]]}
SetNumberOfArguments[ExpandIrreducibleSpinTensors,1];
Protect[ExpandIrreducibleSpinTensors];


(* ::Input::Initialization:: *)
IrreducibleSpinDecompose[expr_,spinor_?SpinorUnbarQ]:=Catch@Module[{expr2=Expand[expr],sbundle,tbundle,liebundle,comm,extralie},
sbundle=-Last@SlotsOfTensor[spinor];
tbundle=Tangent@BaseOfVBundle[sbundle];
(* only works in 4D so far *)
If[(DimOfVBundle[sbundle]!=4)||(DimOfVBundle[tbundle]!=4),Throw@Message[IrreducibleSpinTensor::wrongdim,DimOfVBundle[sbundle],DimOfVBundle[tbundle]]];
(* and at most one Lie algebra index *)
If[Length@SlotsOfTensor[spinor]>2,Throw@Message[IrreducibleSpinTensor::toomanyinds,Length@SlotsOfTensor[spinor]-1]];
If[Length@SlotsOfTensor[spinor]==2,liebundle=First@SlotsOfTensor[spinor];If[!VBundleQ[liebundle],liebundle=-liebundle],liebundle=Null];
If[(Length@SlotsOfTensor[spinor]>1)&&(tbundle===liebundle),Throw@Message[IrreducibleSpinTensor::nolie]];
comm=(GradeOfTensor[spinor,CenterDot]==0);
extralie=(Length@SlotsOfTensor[spinor]>1);
If[Head[expr2]===Plus,Map[irrSDecomp[spinor,sbundle,tbundle,liebundle,comm,extralie,#]&,expr2],irrSDecomp[spinor,sbundle,tbundle,liebundle,comm,extralie,expr2]]
];
SetNumberOfArguments[IrreducibleSpinDecompose,2];
Protect[IrreducibleSpinDecompose];


(* ::Input::Initialization:: *)
irrSDecomp[spinor_,sbundle_,tbundle_,liebundle_,comm_,extralie_,expr_]:=Catch@Module[{cs=ConjugateSpinor[spinor],scount,barscount,met,gamma,eps,t},
(* only count spinors without derivatives *)
barscount=TensorCount[expr,cs,False,True];
scount=TensorCount[expr,spinor,False,True]+barscount;
met=First@MetricsOfVBundle[tbundle];
gamma=Symbol["Gamma"<>SymbolName[met]];
eps=epsilon[met];
Switch[scount,
0,expr,
1,If[barscount==1,t=FirstCase[expr,cs[__],Null,{1,2}];FlipSpinor[expr,t],expr],
2,Which[
(comm)&&(!extralie),(FlipSpinorsToConjugateAmount[expr,spinor,1]/.{cs[A_]spinor[B_]:>With[{mu=DummyIn@tbundle,nu=DummyIn@tbundle},1/4 gamma[mu,B,A]defIrrSTensor[spinor,sbundle,tbundle,liebundle,comm,extralie,2,"4"][-mu]-1/8 gamma[mu,nu,B,A]defIrrSTensor[spinor,sbundle,tbundle,liebundle,comm,extralie,2,"6"][-mu,-nu]]}),
(!comm)&&(!extralie),(FlipSpinorsToConjugateAmount[TimesToCenterDot@expr,spinor,1]/.{Verbatim[CenterDot][x___,spinor[B_],y___,cs[A_],z___]:>-CenterDot[x,cs[A],y,spinor[B],z]}/.{Verbatim[CenterDot][x___,cs[A_],y___,spinor[B_],z___]:>(-1)^(Plus@@(GradeOfTensor[#,CenterDot]&/@Head/@{y}))CenterDot[x,With[{mu=DummyIn@tbundle,nu=DummyIn@tbundle,rho=DummyIn@tbundle,sigma=DummyIn@tbundle},1/4delta[B,A]defIrrSTensor[spinor,sbundle,tbundle,liebundle,comm,extralie,2,"1"][]-1/24 eps[-mu,-nu,-rho,-sigma]gamma[mu,nu,rho,B,A]defIrrSTensor[spinor,sbundle,tbundle,liebundle,comm,extralie,2,"4"][sigma]-1/96eps[-mu,-nu,-rho,-sigma]gamma[mu,nu,rho,sigma,B,A]defIrrSTensor[spinor,sbundle,tbundle,liebundle,comm,extralie,2,"1'"][]],y,z]}),
(comm)&&(extralie),
(FlipSpinorsToConjugateAmount[expr,spinor,1]/.{cs[i_,A_]spinor[j_,B_]:>With[{mu=DummyIn@tbundle,nu=DummyIn@tbundle,rho=DummyIn@tbundle,sigma=DummyIn@tbundle},1/4delta[B,A]defIrrSTensor[spinor,sbundle,tbundle,liebundle,comm,extralie,2,"d(d-1)/2"][i,j]+1/4 gamma[-mu,B,A]defIrrSTensor[spinor,sbundle,tbundle,liebundle,comm,extralie,2,"2d(d+1)"][i,j,mu]-1/8 gamma[-mu,-nu,B,A]defIrrSTensor[spinor,sbundle,tbundle,liebundle,comm,extralie,2,"3d(d+1)"][i,j,mu,nu]-1/24 eps[-mu,-nu,-rho,-sigma]gamma[mu,nu,rho,B,A]defIrrSTensor[spinor,sbundle,tbundle,liebundle,comm,extralie,2,"2d(d-1)"][i,j,sigma]-1/96eps[-mu,-nu,-rho,-sigma]gamma[mu,nu,rho,sigma,B,A]defIrrSTensor[spinor,sbundle,tbundle,liebundle,comm,extralie,2,"d(d-1)/2'"][i,j]]}),
(!comm)&&(extralie),(FlipSpinorsToConjugateAmount[TimesToCenterDot@expr,spinor,1]/.{Verbatim[CenterDot][x___,spinor[j_,B_],y___,cs[i_,A_],z___]:>-CenterDot[x,cs[i,A],y,spinor[j,B],z]}/.{Verbatim[CenterDot][x___,cs[i_,A_],y___,spinor[j_,B_],z___]:>(-1)^(Plus@@(GradeOfTensor[#,CenterDot]&/@Head/@{y}))CenterDot[x,With[{mu=DummyIn@tbundle,nu=DummyIn@tbundle,rho=DummyIn@tbundle,sigma=DummyIn@tbundle},1/4delta[B,A]defIrrSTensor[spinor,sbundle,tbundle,liebundle,comm,extralie,2,"d(d+1)/2"][i,j]+1/4 gamma[-mu,B,A]defIrrSTensor[spinor,sbundle,tbundle,liebundle,comm,extralie,2,"2d(d-1)"][i,j,mu]-1/8 gamma[-mu,-nu,B,A]defIrrSTensor[spinor,sbundle,tbundle,liebundle,comm,extralie,2,"3d(d-1)"][i,j,mu,nu]-1/24 eps[-mu,-nu,-rho,-sigma]gamma[mu,nu,rho,B,A]defIrrSTensor[spinor,sbundle,tbundle,liebundle,comm,extralie,2,"2d(d+1)"][i,j,sigma]-1/96eps[-mu,-nu,-rho,-sigma]gamma[mu,nu,rho,sigma,B,A]defIrrSTensor[spinor,sbundle,tbundle,liebundle,comm,extralie,2,"d(d+1)/2'"][i,j]],y,z]})
],
3,Which[
(comm)&&(!extralie),(FlipSpinorsToConjugateAmount[expr,spinor,1]/.{spinor[A_]cs[B_]spinor[C_]:>With[{mu=DummyIn@tbundle,nu=DummyIn@tbundle,K=DummyIn@sbundle},1/8(gamma[-mu,A,B]defIrrSTensor[spinor,sbundle,tbundle,liebundle,comm,extralie,3,"12"][mu,C]+gamma[-mu,C,B]defIrrSTensor[spinor,sbundle,tbundle,liebundle,comm,extralie,3,"12"][mu,A])+1/16(gamma[-mu,-nu,A,B]gamma[mu,C,K]defIrrSTensor[spinor,sbundle,tbundle,liebundle,comm,extralie,3,"12"][nu,-K]+gamma[-mu,-nu,C,B]gamma[mu,A,K]defIrrSTensor[spinor,sbundle,tbundle,liebundle,comm,extralie,3,"12"][nu,-K])-1/16(gamma[-mu,-nu,A,B]defIrrSTensor[spinor,sbundle,tbundle,liebundle,comm,extralie,3,"8"][mu,nu,C]+gamma[-mu,-nu,C,B]defIrrSTensor[spinor,sbundle,tbundle,liebundle,comm,extralie,3,"8"][mu,nu,A])]}),
(!comm)&&(!extralie),
(FlipSpinorsToConjugateAmount[TimesToCenterDot@expr,spinor,1]//.{Verbatim[CenterDot][u___,spinor[C_],x___,spinor[B_],y___,cs[A_],z___]:>-CenterDot[u,spinor[C],x,cs[A],y,spinor[B],z],Verbatim[CenterDot][u___,cs[A_],x___,spinor[B_],y___,spinor[C_],z___]:>-CenterDot[u,spinor[B],x,cs[A],y,spinor[C],z]}/.{Verbatim[CenterDot][u___,spinor[A_],x___,cs[B_],y___,spinor[C_],z___]:>(-1)^(Plus@@(GradeOfTensor[#,CenterDot]&/@Head/@{y}))CenterDot[u,With[{mu=DummyIn@tbundle,nu=DummyIn@tbundle,rho=DummyIn@tbundle,sigma=DummyIn@tbundle,F=DummyIn@sbundle},-1/8(delta[A,B]delta[C,F]-delta[C,B]delta[A,F]+1/6gamma[-mu,-nu,-rho,A,B]gamma[mu,nu,rho,C,F]-1/6gamma[-mu,-nu,-rho,C,B]gamma[mu,nu,rho,A,F]-1/24 gamma[-mu,-nu,-rho,-sigma,A,B]gamma[mu,nu,rho,sigma,C,F]+1/24 gamma[-mu,-nu,-rho,-sigma,C,B]gamma[mu,nu,rho,sigma,A,F])defIrrSTensor[spinor,sbundle,tbundle,liebundle,comm,extralie,3,"4"][-F]],x,y,z]}),
(comm)&&(extralie),
(FlipSpinorsToConjugateAmount[expr,spinor,1]/.{spinor[a_,A_]cs[b_,B_]spinor[c_,C_]:>With[{mu=DummyIn@tbundle,nu=DummyIn@tbundle,rho=DummyIn@tbundle,sigma=DummyIn@tbundle,F=DummyIn@sbundle},-1/96(12(delta[A,B]delta[C,F]-delta[C,B]delta[A,F])+2(gamma[-mu,-nu,-rho,A,B]gamma[mu,nu,rho,C,F]-gamma[-mu,-nu,-rho,C,B]gamma[mu,nu,rho,A,F])-1/2(gamma[-mu,-nu,-rho,-sigma,A,B]gamma[mu,nu,rho,sigma,C,F]-gamma[-mu,-nu,-rho,-sigma,C,B]gamma[mu,nu,rho,sigma,A,F]))defIrrSTensor[spinor,sbundle,tbundle,liebundle,comm,extralie,3,"2d(d-1)(d-2)/3"][a,b,c,-F]-1/192(24 delta[A,B]delta[C,F]+6gamma[mu,C,B]gamma[-mu,A,F]-2gamma[mu,nu,C,B]gamma[-mu,-nu,A,F]-gamma[mu,nu,rho,A,B]gamma[-mu,-nu,-rho,C,F])defIrrSTensor[spinor,sbundle,tbundle,liebundle,comm,extralie,3,"4d(d+1)(d-1)/3"][a,b,c,-F]-1/192(24 delta[C,B]delta[A,F]+6gamma[mu,A,B]gamma[-mu,C,F]-2gamma[mu,nu,A,B]gamma[-mu,-nu,C,F]-gamma[mu,nu,rho,C,B]gamma[-mu,-nu,-rho,A,F])defIrrSTensor[spinor,sbundle,tbundle,liebundle,comm,extralie,3,"4d(d+1)(d-1)/3"][c,b,a,-F]-1/48(3/2(gamma[mu,A,B]gamma[-mu,C,F]-gamma[mu,C,B]gamma[-mu,A,F])-1/2(gamma[mu,nu,A,B]gamma[-mu,-nu,C,F]-gamma[mu,nu,C,B]gamma[-mu,-nu,A,F]))defIrrSTensor[spinor,sbundle,tbundle,liebundle,comm,extralie,3,"4d(d+1)(d-1)/3"][c,a,b,-F]-1/192(6 gamma[mu,C,B]gamma[-mu,A,F]+2 gamma[mu,nu,C,B]gamma[-mu,-nu,A,F]- gamma[mu,nu,rho,A,B]gamma[-mu,-nu,-rho,C,F]- gamma[mu,nu,rho,sigma,A,B]gamma[-mu,-nu,-rho,-sigma,C,F])defIrrSTensor[spinor,sbundle,tbundle,liebundle,comm,extralie,3,"4d(d+1)(d-1)/3*"][a,b,c,-F]-1/192(6 gamma[mu,A,B]gamma[-mu,C,F]+2 gamma[mu,nu,A,B]gamma[-mu,-nu,C,F]- gamma[mu,nu,rho,C,B]gamma[-mu,-nu,-rho,A,F]- gamma[mu,nu,rho,sigma,C,B]gamma[-mu,-nu,-rho,-sigma,A,F])defIrrSTensor[spinor,sbundle,tbundle,liebundle,comm,extralie,3,"4d(d+1)(d-1)/3*"][c,b,a,-F]-1/48(3/2(gamma[mu,A,B]gamma[-mu,C,F]-gamma[mu,C,B]gamma[-mu,A,F])+1/2(gamma[mu,nu,A,B]gamma[-mu,-nu,C,F]-gamma[mu,nu,C,B]gamma[-mu,-nu,A,F]))defIrrSTensor[spinor,sbundle,tbundle,liebundle,comm,extralie,3,"4d(d+1)(d-1)/3*"][c,a,b,-F]+1/8(gamma[nu,A,B]delta[C,F]+gamma[nu,C,B]delta[A,F]+1/2(gamma[mu,nu,A,B]gamma[-mu,C,F]+gamma[mu,nu,C,B]gamma[-mu,A,F]))defIrrSTensor[spinor,sbundle,tbundle,liebundle,comm,extralie,3,"2d(d+1)(d+2)"][a,b,c,-nu,-F]+1/16(2gamma[nu,A,B]delta[C,F]-2gamma[mu,nu,A,B]gamma[-mu,C,F]+gamma[mu,nu,rho,C,B]gamma[-mu,-rho,A,F])defIrrSTensor[spinor,sbundle,tbundle,liebundle,comm,extralie,3,"4d(d+1)(d-1)"][a,b,c,-nu,-F]+1/16(2gamma[nu,C,B]delta[A,F]-2gamma[mu,nu,C,B]gamma[-mu,A,F]+gamma[mu,nu,rho,A,B]gamma[-mu,-rho,C,F])defIrrSTensor[spinor,sbundle,tbundle,liebundle,comm,extralie,3,"4d(d+1)(d-1)"][c,b,a,-nu,-F]+1/16(gamma[mu,nu,rho,A,B]gamma[-mu,-nu,C,F]+gamma[mu,nu,rho,C,B]gamma[-mu,-nu,A,F])defIrrSTensor[spinor,sbundle,tbundle,liebundle,comm,extralie,3,"4d(d+1)(d-1)"][c,a,b,-rho,-F]-1/16(gamma[mu,nu,A,B]delta[C,F]+gamma[mu,nu,C,B]delta[A,F])defIrrSTensor[spinor,sbundle,tbundle,liebundle,comm,extralie,3,"4d(d+1)(d+2)/3"][a,b,c,-mu,-nu,-F]]}),
(!comm)&&(extralie),
(FlipSpinorsToConjugateAmount[TimesToCenterDot@expr,spinor,1]//.{Verbatim[CenterDot][u___,spinor[k_,C_],x___,spinor[j_,B_],y___,cs[i_,A_],z___]:>-CenterDot[u,spinor[k,C],x,cs[i,A],y,spinor[j,B],z],Verbatim[CenterDot][u___,cs[i_,A_],x___,spinor[j_,B_],y___,spinor[k_,C_],z___]:>-CenterDot[u,spinor[j,B],x,cs[i,A],y,spinor[k,C],z]}/.{Verbatim[CenterDot][u___,spinor[a_,A_],x___,cs[b_,B_],y___,spinor[c_,C_],z___]:>(-1)^(Plus@@(GradeOfTensor[#,CenterDot]&/@Head/@{y}))CenterDot[u,With[{mu=DummyIn@tbundle,nu=DummyIn@tbundle,rho=DummyIn@tbundle,sigma=DummyIn@tbundle,F=DummyIn@sbundle},-1/96(12(delta[A,B]delta[C,F]-delta[C,B]delta[A,F])+2(gamma[-mu,-nu,-rho,A,B]gamma[mu,nu,rho,C,F]-gamma[-mu,-nu,-rho,C,B]gamma[mu,nu,rho,A,F])-1/2(gamma[-mu,-nu,-rho,-sigma,A,B]gamma[mu,nu,rho,sigma,C,F]-gamma[-mu,-nu,-rho,-sigma,C,B]gamma[mu,nu,rho,sigma,A,F]))defIrrSTensor[spinor,sbundle,tbundle,liebundle,comm,extralie,3,"2d(d+1)(d+2)/3"][a,b,c,-F]-1/192(24 delta[A,B]delta[C,F]+6gamma[mu,C,B]gamma[-mu,A,F]-2gamma[mu,nu,C,B]gamma[-mu,-nu,A,F]-gamma[mu,nu,rho,A,B]gamma[-mu,-nu,-rho,C,F])defIrrSTensor[spinor,sbundle,tbundle,liebundle,comm,extralie,3,"4d(d+1)(d-1)/3"][a,b,c,-F]+1/192(24 delta[C,B]delta[A,F]+6gamma[mu,A,B]gamma[-mu,C,F]-2gamma[mu,nu,A,B]gamma[-mu,-nu,C,F]-gamma[mu,nu,rho,C,B]gamma[-mu,-nu,-rho,A,F])defIrrSTensor[spinor,sbundle,tbundle,liebundle,comm,extralie,3,"4d(d+1)(d-1)/3"][c,b,a,-F]-1/48(3/2(gamma[mu,A,B]gamma[-mu,C,F]-gamma[mu,C,B]gamma[-mu,A,F])-1/2(gamma[mu,nu,A,B]gamma[-mu,-nu,C,F]-gamma[mu,nu,C,B]gamma[-mu,-nu,A,F]))defIrrSTensor[spinor,sbundle,tbundle,liebundle,comm,extralie,3,"4d(d+1)(d-1)/3"][c,a,b,-F]-1/192(6gamma[mu,C,B]gamma[-mu,A,F]+2gamma[mu,nu,C,B]gamma[-mu,-nu,A,F]-gamma[mu,nu,rho,A,B]gamma[-mu,-nu,-rho,C,F]-gamma[mu,nu,rho,sigma,A,B]gamma[-mu,-nu,-rho,-sigma,C,F])defIrrSTensor[spinor,sbundle,tbundle,liebundle,comm,extralie,3,"4d(d+1)(d-1)/3*"][a,b,c,-F]+1/192(6gamma[mu,A,B]gamma[-mu,C,F]+2gamma[mu,nu,A,B]gamma[-mu,-nu,C,F]-gamma[mu,nu,rho,C,B]gamma[-mu,-nu,-rho,A,F]-gamma[mu,nu,rho,sigma,C,B]gamma[-mu,-nu,-rho,-sigma,A,F])defIrrSTensor[spinor,sbundle,tbundle,liebundle,comm,extralie,3,"4d(d+1)(d-1)/3*"][c,b,a,-F]-1/48(3/2(gamma[mu,A,B]gamma[-mu,C,F]-gamma[mu,C,B]gamma[-mu,A,F])+1/2(gamma[mu,nu,A,B]gamma[-mu,-nu,C,F]-gamma[mu,nu,C,B]gamma[-mu,-nu,A,F]))defIrrSTensor[spinor,sbundle,tbundle,liebundle,comm,extralie,3,"4d(d+1)(d-1)/3*"][c,a,b,-F]+1/8(gamma[nu,A,B]delta[C,F]+gamma[nu,C,B]delta[A,F]+1/2(gamma[mu,nu,A,B]gamma[-mu,C,F]+gamma[mu,nu,C,B]gamma[-mu,A,F]))defIrrSTensor[spinor,sbundle,tbundle,liebundle,comm,extralie,3,"2d(d-1)(d-2)"][a,b,c,-nu,-F]+1/16(2gamma[nu,A,B]delta[C,F]-2gamma[mu,nu,A,B]gamma[-mu,C,F]+gamma[mu,nu,rho,C,B]gamma[-mu,-rho,A,F])defIrrSTensor[spinor,sbundle,tbundle,liebundle,comm,extralie,3,"4d(d+1)(d-1)"][a,b,c,-nu,-F]-1/16(2gamma[nu,C,B]delta[A,F]-2gamma[mu,nu,C,B]gamma[-mu,A,F]+gamma[mu,nu,rho,A,B]gamma[-mu,-rho,C,F])defIrrSTensor[spinor,sbundle,tbundle,liebundle,comm,extralie,3,"4d(d+1)(d-1)"][c,b,a,-nu,-F]+1/16(gamma[mu,nu,rho,A,B]gamma[-mu,-nu,C,F]+gamma[mu,nu,rho,C,B]gamma[-mu,-nu,A,F])defIrrSTensor[spinor,sbundle,tbundle,liebundle,comm,extralie,3,"4d(d+1)(d-1)"][c,a,b,-rho,-F]-1/16(gamma[mu,nu,A,B]delta[C,F]+gamma[mu,nu,C,B]delta[A,F])defIrrSTensor[spinor,sbundle,tbundle,liebundle,comm,extralie,3,"4d(d-1)(d-2)/3"][a,b,c,-mu,-nu,-F]],x,y,z]})
],
4,Which[
(comm)&&(!extralie),(FlipSpinorsToConjugateAmount[expr,spinor,2]/.{cs[A_]spinor[B_]cs[C_]spinor[D_]:>With[{mu=DummyIn@tbundle,nu=DummyIn@tbundle,rho=DummyIn@tbundle,sigma=DummyIn@tbundle},1/16(gamma[mu,B,A]gamma[nu,D,C]+gamma[mu,D,A]gamma[nu,B,C])defIrrSTensor[spinor,sbundle,tbundle,liebundle,comm,extralie,4,"9"][-mu,-nu]+1/32(gamma[rho,mu,B,A]gamma[-rho,nu,D,C]+gamma[rho,mu,D,A]gamma[-rho,nu,B,C])defIrrSTensor[spinor,sbundle,tbundle,liebundle,comm,extralie,4,"9"][-mu,-nu]-1/12(gamma[mu,B,A]gamma[nu,rho,D,C]+gamma[mu,D,A]gamma[nu,rho,B,C])defIrrSTensor[spinor,sbundle,tbundle,liebundle,comm,extralie,4,"16"][-mu,-nu,-rho]+1/64(gamma[mu,nu,B,A]gamma[rho,sigma,D,C]+gamma[mu,nu,D,A]gamma[rho,sigma,B,C])defIrrSTensor[spinor,sbundle,tbundle,liebundle,comm,extralie,4,"10"][-mu,-nu,-rho,-sigma]]}),
(!comm)&&(!extralie),
(FlipSpinorsToConjugateAmount[TimesToCenterDot@expr,spinor,2]//.{Verbatim[CenterDot][u___,spinor[D_],x___,spinor[B_],y___,cs[C_],z___,cs[A_],v___]:>-CenterDot[u,cs[A],x,spinor[B],y,cs[C],z,spinor[D],v],Verbatim[CenterDot][u___,spinor[B_],x___,cs[A_],y___,spinor[D_],z___,cs[C_],v___]:>CenterDot[u,cs[A],x,spinor[B],y,cs[C],z,spinor[D],v],Verbatim[CenterDot][u___,cs[A_],x___,spinor[B_],y___,spinor[D_],z___,cs[C_],v___]:>-CenterDot[u,cs[A],x,spinor[B],y,cs[C],z,spinor[D],v],Verbatim[CenterDot][u___,cs[A_],x___,cs[C_],y___,spinor[B_],z___,spinor[D_],v___]:>-CenterDot[u,cs[A],x,spinor[B],y,cs[C],z,spinor[D],v],Verbatim[CenterDot][u___,spinor[B_],x___,cs[A_],y___,cs[C_],z___,spinor[D_],v___]:>-CenterDot[u,cs[A],x,spinor[B],y,cs[C],z,spinor[D],v]}/.{Verbatim[CenterDot][u___,cs[B_],x___,spinor[A_],y___,cs[D_],z___,spinor[C_],v___]:>(-1)^(Plus@@(GradeOfTensor[#,CenterDot]&/@Head/@{x,z}))CenterDot[u,With[{mu=DummyIn@tbundle,nu=DummyIn@tbundle,rho=DummyIn@tbundle,sigma=DummyIn@tbundle,F=DummyIn@sbundle},1/32(delta[A,B]delta[C,D]-delta[C,B]delta[A,D]+1/6gamma[-mu,-nu,-rho,A,B]gamma[mu,nu,rho,C,D]-1/6gamma[-mu,-nu,-rho,C,B]gamma[mu,nu,rho,A,D]-1/24 gamma[-mu,-nu,-rho,-sigma,A,B]gamma[mu,nu,rho,sigma,C,D]+1/24 gamma[-mu,-nu,-rho,-sigma,C,B]gamma[mu,nu,rho,sigma,A,D])defIrrSTensor[spinor,sbundle,tbundle,liebundle,comm,extralie,4,"1"][]],x,y,z,v]}),
(comm)&&(extralie),
Throw@Message[IrreducibleSpinTensor::notimpl],
(!comm)&&(extralie),
Throw@Message[IrreducibleSpinTensor::notimpl]
],
_,If[(!comm)&&!(extralie),0,Throw@Message[IrreducibleSpinDecompose::error1,"Can decompose up to 4 spinors into irreducibles, but found ",scount]]
]
]


(* ::Input::Initialization:: *)
IrreducibleSpinProject[expr_,spinor_?SpinorUnbarQ]:=Catch@Module[{sbundle,tbundle,liebundle,comm,extralie},
sbundle=-Last@SlotsOfTensor[spinor];
tbundle=Tangent@BaseOfVBundle[sbundle];
(* only works in 4D so far *)
If[(DimOfVBundle[sbundle]!=4)||(DimOfVBundle[tbundle]!=4),Throw@Message[IrreducibleSpinTensor::wrongdim,DimOfVBundle[sbundle],DimOfVBundle[tbundle]]];
(* and at most one Lie algebra index *)
If[Length@SlotsOfTensor[spinor]>2,Throw@Message[IrreducibleSpinTensor::toomanyinds,Length@SlotsOfTensor[spinor]-1]];
If[Length@SlotsOfTensor[spinor]==2,liebundle=First@SlotsOfTensor[spinor];If[!VBundleQ[liebundle],liebundle=-liebundle],liebundle=Null];
If[(Length@SlotsOfTensor[spinor]>1)&&(tbundle===liebundle),Throw@Message[IrreducibleSpinTensor::nolie]];
comm=(GradeOfTensor[spinor,CenterDot]==0);
extralie=(Length@SlotsOfTensor[spinor]>1);
irrSProj[spinor,sbundle,tbundle,liebundle,comm,extralie,Expand[expr]]
];
SetNumberOfArguments[IrreducibleSpinProject,2];
Protect[IrreducibleSpinProject];


(* ::Input::Initialization:: *)
irrSProj[spinor_,sbundle_,tbundle_,liebundle_,comm_,extralie_,expr_]:=Catch@Module[{reps={},repsyoung={},repslie={},met,gam,eps,tens,t,g1,g2},
met=First@MetricsOfVBundle[tbundle];
gam="Gamma"<>SymbolName[met];
eps=epsilon[met];
tens=Symbol["Irr"<>SymbolName[sbundle]];
(* orthogonal to \[Gamma] matrices *)
AppendTo[reps,inject[{t->tens,g1->Symbol[gam<>"1"]},g1[mu_,A_,B_]t[spinor,3,rep__][i1___,-mu_,i2___,-B_]:>0]];
If[!comm,AppendTo[reps,inject[{t->tens,g1->Symbol[gam<>"1"]},g1[mu_,A_,B_]Verbatim[CenterDot][left___,t[spinor,3,rep__][i1___,-mu_,i2___,-B_],right___]:>0]]];
AppendTo[reps,inject[{t->tens,g1->Symbol[gam<>"1"]},g1[-mu_,A_,B_]t[spinor,3,rep__][i1___,mu_,i2___,-B_]:>0]];
If[!comm,AppendTo[reps,inject[{t->tens,g1->Symbol[gam<>"1"]},g1[-mu_,A_,B_]Verbatim[CenterDot][left___,t[spinor,3,rep__][i1___,mu_,i2___,-B_],right___]:>0]]];
AppendTo[reps,inject[{t->tens,g1->Symbol[gam<>"2"]},g1[mu_,nu_,A_,B_]t[spinor,3,rep__][i1___,-mu_,i2___,-B_]:>t[spinor,3,rep][i1,nu,i2,A]]];
If[!comm,AppendTo[reps,inject[{t->tens,g1->Symbol[gam<>"2"]},g1[mu_,nu_,A_,B_]Verbatim[CenterDot][left___,t[spinor,3,rep__][i1___,-mu_,i2___,-B_],right___]:>CenterDot[left,t[spinor,3,rep][i1,nu,i2,A],right]]]];
AppendTo[reps,inject[{t->tens,g1->Symbol[gam<>"2"]},g1[-mu_,nu_,A_,B_]t[spinor,3,rep__][i1___,mu_,i2___,-B_]:>t[spinor,3,rep][i1,nu,i2,A]]];
If[!comm,AppendTo[reps,inject[{t->tens,g1->Symbol[gam<>"2"]},g1[-mu_,nu_,A_,B_]Verbatim[CenterDot][left___,t[spinor,3,rep__][i1___,mu_,i2___,-B_],right___]:>CenterDot[left,t[spinor,3,rep][i1,nu,i2,A],right]]]];
AppendTo[reps,inject[{t->tens,g1->Symbol[gam<>"2"]},g1[nu_,mu_,A_,B_]t[spinor,3,rep__][i1___,-mu_,i2___,-B_]:>-t[spinor,3,rep][i1,nu,i2,A]]];
If[!comm,AppendTo[reps,inject[{t->tens,g1->Symbol[gam<>"2"]},g1[nu_,mu_,A_,B_]Verbatim[CenterDot][left___,t[spinor,3,rep__][i1___,-mu_,i2___,-B_],right___]:>-CenterDot[left,t[spinor,3,rep][i1,nu,i2,A],right]]]];
AppendTo[reps,inject[{t->tens,g1->Symbol[gam<>"2"]},g1[nu_,-mu_,A_,B_]t[spinor,3,rep__][i1___,mu_,i2___,-B_]:>-t[spinor,3,rep][i1,nu,i2,A]]];
If[!comm,AppendTo[reps,inject[{t->tens,g1->Symbol[gam<>"2"]},g1[nu_,-mu_,A_,B_]Verbatim[CenterDot][left___,t[spinor,3,rep__][i1___,mu_,i2___,-B_],right___]:>-CenterDot[left,t[spinor,3,rep][i1,nu,i2,A],right]]]];
AppendTo[reps,inject[{t->tens,g1->Symbol[gam<>"3"],g2->Symbol[gam<>"1"]},g1[mu_,rho_,sigma_,A_,B_]t[spinor,3,rep__][i1___,-mu_,i2___,-B_]:>g2[sigma,A,B]t[spinor,3,rep][i1,rho,i2,-B]-g2[rho,A,B]t[spinor,3,rep][i1,sigma,i2,-B]]];
If[!comm,AppendTo[reps,inject[{t->tens,g1->Symbol[gam<>"3"],g2->Symbol[gam<>"1"]},g1[mu_,rho_,sigma_,A_,B_]Verbatim[CenterDot][left___,t[spinor,3,rep__][i1___,-mu_,i2___,-B_],right___]:>g2[sigma,A,B]CenterDot[left,t[spinor,3,rep][i1,rho,i2,-B],right]-g2[rho,A,B]CenterDot[left,t[spinor,3,rep][i1,sigma,i2,-B],right]]]];
AppendTo[reps,inject[{t->tens,g1->Symbol[gam<>"3"],g2->Symbol[gam<>"1"]},g1[-mu_,rho_,sigma_,A_,B_]t[spinor,3,rep__][i1___,mu_,i2___,-B_]:>g2[sigma,A,B]t[spinor,3,rep][i1,rho,i2,-B]-g2[rho,A,B]t[spinor,3,rep][i1,sigma,i2,-B]]];
If[!comm,AppendTo[reps,inject[{t->tens,g1->Symbol[gam<>"3"],g2->Symbol[gam<>"1"]},g1[-mu_,rho_,sigma_,A_,B_]Verbatim[CenterDot][left___,t[spinor,3,rep__][i1___,mu_,i2___,-B_],right___]:>g2[sigma,A,B]CenterDot[left,t[spinor,3,rep][i1,rho,i2,-B],right]-g2[rho,A,B]CenterDot[left,t[spinor,3,rep][i1,sigma,i2,-B],right]]]];
AppendTo[reps,inject[{t->tens,g1->Symbol[gam<>"3"],g2->Symbol[gam<>"1"]},g1[rho_,mu_,sigma_,A_,B_]t[spinor,3,rep__][i1___,-mu_,i2___,-B_]:>-g2[sigma,A,B]t[spinor,3,rep][i1,rho,i2,-B]+g2[rho,A,B]t[spinor,3,rep][i1,sigma,i2,-B]]];
If[!comm,AppendTo[reps,inject[{t->tens,g1->Symbol[gam<>"3"],g2->Symbol[gam<>"1"]},g1[rho_,mu_,sigma_,A_,B_]Verbatim[CenterDot][left___,t[spinor,3,rep__][i1___,-mu_,i2___,-B_],right___]:>-g2[sigma,A,B]CenterDot[left,t[spinor,3,rep][i1,rho,i2,-B],right]+g2[rho,A,B]CenterDot[left,t[spinor,3,rep][i1,sigma,i2,-B],right]]]];
AppendTo[reps,inject[{t->tens,g1->Symbol[gam<>"3"],g2->Symbol[gam<>"1"]},g1[rho_,-mu_,sigma_,A_,B_]t[spinor,3,rep__][i1___,mu_,i2___,-B_]:>-g2[sigma,A,B]t[spinor,3,rep][i1,rho,i2,-B]+g2[rho,A,B]t[spinor,3,rep][i1,sigma,i2,-B]]];
If[!comm,AppendTo[reps,inject[{t->tens,g1->Symbol[gam<>"3"],g2->Symbol[gam<>"1"]},g1[rho_,-mu_,sigma_,A_,B_]Verbatim[CenterDot][left___,t[spinor,3,rep__][i1___,mu_,i2___,-B_],right___]:>-g2[sigma,A,B]CenterDot[left,t[spinor,3,rep][i1,rho,i2,-B],right]+g2[rho,A,B]CenterDot[left,t[spinor,3,rep][i1,sigma,i2,-B],right]]]];
AppendTo[reps,inject[{t->tens,g1->Symbol[gam<>"3"],g2->Symbol[gam<>"1"]},g1[rho_,sigma_,mu_,A_,B_]t[spinor,3,rep__][i1___,-mu_,i2___,-B_]:>g2[sigma,A,B]t[spinor,3,rep][i1,rho,i2,-B]-g2[rho,A,B]t[spinor,3,rep][i1,sigma,i2,-B]]];
If[!comm,AppendTo[reps,inject[{t->tens,g1->Symbol[gam<>"3"],g2->Symbol[gam<>"1"]},g1[rho_,sigma_,mu_,A_,B_]Verbatim[CenterDot][left___,t[spinor,3,rep__][i1___,-mu_,i2___,-B_],right___]:>g2[sigma,A,B]CenterDot[left,t[spinor,3,rep][i1,rho,i2,-B],right]-g2[rho,A,B]CenterDot[left,t[spinor,3,rep][i1,sigma,i2,-B],right]]]];
AppendTo[reps,inject[{t->tens,g1->Symbol[gam<>"3"],g2->Symbol[gam<>"1"]},g1[rho_,sigma_,-mu_,A_,B_]t[spinor,3,rep__][i1___,mu_,i2___,-B_]:>g2[sigma,A,B]t[spinor,3,rep][i1,rho,i2,-B]-g2[rho,A,B]t[spinor,3,rep][i1,sigma,i2,-B]]];
If[!comm,AppendTo[reps,inject[{t->tens,g1->Symbol[gam<>"3"],g2->Symbol[gam<>"1"]},g1[rho_,sigma_,-mu_,A_,B_]Verbatim[CenterDot][left___,t[spinor,3,rep__][i1___,mu_,i2___,-B_],right___]:>g2[sigma,A,B]CenterDot[left,t[spinor,3,rep][i1,rho,i2,-B],right]-g2[rho,A,B]CenterDot[left,t[spinor,3,rep][i1,sigma,i2,-B],right]]]];
AppendTo[reps,inject[{t->tens,g1->Symbol[gam<>"4"],g2->Symbol[gam<>"2"]},g1[mu_,nu_,rho_,sigma_,A_,B_]t[spinor,3,rep__][i1___,-mu_,i2___,-B_]:>g2[rho,sigma,A,B]t[spinor,3,rep][i1,nu,i2,-B]+g2[sigma,nu,A,B]t[spinor,3,rep][i1,rho,i2,-B]+g2[nu,rho,A,B]t[spinor,3,rep][i1,sigma,i2,-B]]];
If[!comm,AppendTo[reps,inject[{t->tens,g1->Symbol[gam<>"4"],g2->Symbol[gam<>"2"]},g1[mu_,nu_,rho_,sigma_,A_,B_]Verbatim[CenterDot][left___,t[spinor,3,rep__][i1___,-mu_,i2___,-B_],right___]:>g2[rho,sigma,A,B]CenterDot[left,t[spinor,3,rep][i1,nu,i2,-B],right]+g2[sigma,nu,A,B]CenterDot[left,t[spinor,3,rep][i1,rho,i2,-B],right]+g2[nu,rho,A,B]CenterDot[left,t[spinor,3,rep][i1,sigma,i2,-B],right]]]];
AppendTo[reps,inject[{t->tens,g1->Symbol[gam<>"4"],g2->Symbol[gam<>"2"]},g1[-mu_,nu_,rho_,sigma_,A_,B_]t[spinor,3,rep__][i1___,mu_,i2___,-B_]:>g2[rho,sigma,A,B]t[spinor,3,rep][i1,nu,i2,-B]+g2[sigma,nu,A,B]t[spinor,3,rep][i1,rho,i2,-B]+g2[nu,rho,A,B]t[spinor,3,rep][i1,sigma,i2,-B]]];
If[!comm,AppendTo[reps,inject[{t->tens,g1->Symbol[gam<>"4"],g2->Symbol[gam<>"2"]},g1[-mu_,nu_,rho_,sigma_,A_,B_]Verbatim[CenterDot][left___,t[spinor,3,rep__][i1___,mu_,i2___,-B_],right___]:>g2[rho,sigma,A,B]CenterDot[left,t[spinor,3,rep][i1,nu,i2,-B],right]+g2[sigma,nu,A,B]CenterDot[left,t[spinor,3,rep][i1,rho,i2,-B],right]+g2[nu,rho,A,B]CenterDot[left,t[spinor,3,rep][i1,sigma,i2,-B],right]]]];
AppendTo[reps,inject[{t->tens,g1->Symbol[gam<>"4"],g2->Symbol[gam<>"2"]},g1[nu_,mu_,rho_,sigma_,A_,B_]t[spinor,3,rep__][i1___,-mu_,i2___,-B_]:>-g2[rho,sigma,A,B]t[spinor,3,rep][i1,nu,i2,-B]-g2[sigma,nu,A,B]t[spinor,3,rep][i1,rho,i2,-B]-g2[nu,rho,A,B]t[spinor,3,rep][i1,sigma,i2,-B]]];
If[!comm,AppendTo[reps,inject[{t->tens,g1->Symbol[gam<>"4"],g2->Symbol[gam<>"2"]},g1[nu_,mu_,rho_,sigma_,A_,B_]Verbatim[CenterDot][left___,t[spinor,3,rep__][i1___,-mu_,i2___,-B_],right___]:>-g2[rho,sigma,A,B]CenterDot[left,t[spinor,3,rep][i1,nu,i2,-B],right]-g2[sigma,nu,A,B]CenterDot[left,t[spinor,3,rep][i1,rho,i2,-B],right]-g2[nu,rho,A,B]CenterDot[left,t[spinor,3,rep][i1,sigma,i2,-B],right]]]];
AppendTo[reps,inject[{t->tens,g1->Symbol[gam<>"4"],g2->Symbol[gam<>"2"]},g1[nu_,-mu_,rho_,sigma_,A_,B_]t[spinor,3,rep__][i1___,mu_,i2___,-B_]:>-g2[rho,sigma,A,B]t[spinor,3,rep][i1,nu,i2,-B]-g2[sigma,nu,A,B]t[spinor,3,rep][i1,rho,i2,-B]-g2[nu,rho,A,B]t[spinor,3,rep][i1,sigma,i2,-B]]];
If[!comm,AppendTo[reps,inject[{t->tens,g1->Symbol[gam<>"4"],g2->Symbol[gam<>"2"]},g1[nu_,-mu_,rho_,sigma_,A_,B_]Verbatim[CenterDot][left___,t[spinor,3,rep__][i1___,mu_,i2___,-B_],right___]:>-g2[rho,sigma,A,B]CenterDot[left,t[spinor,3,rep][i1,nu,i2,-B],right]-g2[sigma,nu,A,B]CenterDot[left,t[spinor,3,rep][i1,rho,i2,-B],right]-g2[nu,rho,A,B]CenterDot[left,t[spinor,3,rep][i1,sigma,i2,-B],right]]]];
AppendTo[reps,inject[{t->tens,g1->Symbol[gam<>"4"],g2->Symbol[gam<>"2"]},g1[nu_,rho_,mu_,sigma_,A_,B_]t[spinor,3,rep__][i1___,-mu_,i2___,-B_]:>g2[rho,sigma,A,B]t[spinor,3,rep][i1,nu,i2,-B]+g2[sigma,nu,A,B]t[spinor,3,rep][i1,rho,i2,-B]+g2[nu,rho,A,B]t[spinor,3,rep][i1,sigma,i2,-B]]];
If[!comm,AppendTo[reps,inject[{t->tens,g1->Symbol[gam<>"4"],g2->Symbol[gam<>"2"]},g1[nu_,rho_,mu_,sigma_,A_,B_]Verbatim[CenterDot][left___,t[spinor,3,rep__][i1___,-mu_,i2___,-B_],right___]:>g2[rho,sigma,A,B]CenterDot[left,t[spinor,3,rep][i1,nu,i2,-B],right]+g2[sigma,nu,A,B]CenterDot[left,t[spinor,3,rep][i1,rho,i2,-B],right]+g2[nu,rho,A,B]CenterDot[left,t[spinor,3,rep][i1,sigma,i2,-B],right]]]];
AppendTo[reps,inject[{t->tens,g1->Symbol[gam<>"4"],g2->Symbol[gam<>"2"]},g1[nu_,rho_,-mu_,sigma_,A_,B_]t[spinor,3,rep__][i1___,mu_,i2___,-B_]:>g2[rho,sigma,A,B]t[spinor,3,rep][i1,nu,i2,-B]+g2[sigma,nu,A,B]t[spinor,3,rep][i1,rho,i2,-B]+g2[nu,rho,A,B]t[spinor,3,rep][i1,sigma,i2,-B]]];
If[!comm,AppendTo[reps,inject[{t->tens,g1->Symbol[gam<>"4"],g2->Symbol[gam<>"2"]},g1[nu_,rho_,-mu_,sigma_,A_,B_]Verbatim[CenterDot][left___,t[spinor,3,rep__][i1___,mu_,i2___,-B_],right___]:>g2[rho,sigma,A,B]CenterDot[left,t[spinor,3,rep][i1,nu,i2,-B],right]+g2[sigma,nu,A,B]CenterDot[left,t[spinor,3,rep][i1,rho,i2,-B],right]+g2[nu,rho,A,B]CenterDot[left,t[spinor,3,rep][i1,sigma,i2,-B],right]]]];
AppendTo[reps,inject[{t->tens,g1->Symbol[gam<>"4"],g2->Symbol[gam<>"2"]},g1[nu_,rho_,sigma_,mu_,A_,B_]t[spinor,3,rep__][i1___,-mu_,i2___,-B_]:>-g2[rho,sigma,A,B]t[spinor,3,rep][i1,nu,i2,-B]-g2[sigma,nu,A,B]t[spinor,3,rep][i1,rho,i2,-B]-g2[nu,rho,A,B]t[spinor,3,rep][i1,sigma,i2,-B]]];
If[!comm,AppendTo[reps,inject[{t->tens,g1->Symbol[gam<>"4"],g2->Symbol[gam<>"2"]},g1[nu_,rho_,sigma_,mu_,A_,B_]Verbatim[CenterDot][left___,t[spinor,3,rep__][i1___,-mu_,i2___,-B_],right___]:>-g2[rho,sigma,A,B]CenterDot[left,t[spinor,3,rep][i1,nu,i2,-B],right]-g2[sigma,nu,A,B]CenterDot[left,t[spinor,3,rep][i1,rho,i2,-B],right]-g2[nu,rho,A,B]CenterDot[left,t[spinor,3,rep][i1,sigma,i2,-B],right]]]];
AppendTo[reps,inject[{t->tens,g1->Symbol[gam<>"4"],g2->Symbol[gam<>"2"]},g1[nu_,rho_,sigma_,-mu_,A_,B_]t[spinor,3,rep__][i1___,mu_,i2___,-B_]:>-g2[rho,sigma,A,B]t[spinor,3,rep][i1,nu,i2,-B]-g2[sigma,nu,A,B]t[spinor,3,rep][i1,rho,i2,-B]-g2[nu,rho,A,B]t[spinor,3,rep][i1,sigma,i2,-B]]];
If[!comm,AppendTo[reps,inject[{t->tens,g1->Symbol[gam<>"4"],g2->Symbol[gam<>"2"]},g1[nu_,rho_,sigma_,-mu_,A_,B_]Verbatim[CenterDot][left___,t[spinor,3,rep__][i1___,mu_,i2___,-B_],right___]:>-g2[rho,sigma,A,B]CenterDot[left,t[spinor,3,rep][i1,nu,i2,-B],right]-g2[sigma,nu,A,B]CenterDot[left,t[spinor,3,rep][i1,rho,i2,-B],right]-g2[nu,rho,A,B]CenterDot[left,t[spinor,3,rep][i1,sigma,i2,-B],right]]]];
(* Young tableau projection to remove totally antisymmetric part, which vanishes after double Hodge dual *)
If[extralie,
If[comm,
(*\[Gamma]3 t1*)AppendTo[reps,inject[{t->tens,g1->Symbol[gam<>"3"]},g1[mu_,nu_,rho_,A_,B_]t[spinor,3,"2d(d+1)(d+2)",rep__][i1___,alpha_,-B_]:>3/4g1[mu,nu,rho,A,B]t[spinor,3,"2d(d+1)(d+2)",rep][i1,alpha,-B]+1/4g1[alpha,mu,nu,A,B]t[spinor,3,"2d(d+1)(d+2)",rep][i1,rho,-B]+1/4g1[alpha,rho,mu,A,B]t[spinor,3,"2d(d+1)(d+2)",rep][i1,nu,-B]+1/4g1[alpha,nu,rho,A,B]t[spinor,3,"2d(d+1)(d+2)",rep][i1,mu,-B]]];
(*\[Gamma]3 t1*)AppendTo[reps,inject[{t->tens,g1->Symbol[gam<>"3"]},g1[mu_,nu_,rho_,A_,B_]t[spinor,3,"4d(d+1)(d-1)",rep__][i1___,alpha_,-B_]:>3/4g1[mu,nu,rho,A,B]t[spinor,3,"4d(d+1)(d-1)",rep][i1,alpha,-B]+1/4g1[alpha,mu,nu,A,B]t[spinor,3,"4d(d+1)(d-1)",rep][i1,rho,-B]+1/4g1[alpha,rho,mu,A,B]t[spinor,3,"4d(d+1)(d-1)",rep][i1,nu,-B]+1/4g1[alpha,nu,rho,A,B]t[spinor,3,"4d(d+1)(d-1)",rep][i1,mu,-B]]];
(*\[Gamma]1 t2*)AppendTo[reps,inject[{t->tens,g1->Symbol[gam<>"1"]},g1[mu_,A_,B_]t[spinor,3,"4d(d+1)(d+2)/3",rep__][i1___,alpha_,beta_,-B_]:>2/3g1[mu,A,B]t[spinor,3,"4d(d+1)(d+2)/3",rep][i1,alpha,beta,-B]-1/3g1[alpha,A,B]t[spinor,3,"4d(d+1)(d+2)/3",rep][i1,beta,mu,-B]+1/3g1[beta,A,B]t[spinor,3,"4d(d+1)(d+2)/3",rep][i1,alpha,mu,-B]]];
(*\[Gamma]2 t2*)AppendTo[reps,inject[{t->tens,g1->Symbol[gam<>"2"]},g1[mu_,nu_,A_,B_]t[spinor,3,"4d(d+1)(d+2)/3",rep__][i1___,alpha_,beta_,-B_]:>Antisymmetrize[5/6g1[mu,nu,A,B]t[spinor,3,"4d(d+1)(d+2)/3",rep][i1,alpha,beta,-B]-1/3g1[mu,alpha,A,B]t[spinor,3,"4d(d+1)(d+2)/3",rep][i1,beta,nu,-B]+1/3g1[mu,beta,A,B]t[spinor,3,"4d(d+1)(d+2)/3",rep][i1,alpha,nu,-B]-1/6g1[alpha,beta,A,B]t[spinor,3,"4d(d+1)(d+2)/3",rep][i1,mu,nu,-B],{mu,nu}]]];
(*\[Gamma]3 t2*)AppendTo[reps,inject[{t->tens,g1->Symbol[gam<>"3"]},g1[mu_,nu_,rho_,A_,B_]t[spinor,3,"4d(d+1)(d+2)/3",rep__][i1___,alpha_,beta_,-B_]:>Antisymmetrize[1/2g1[mu,nu,rho,A,B]t[spinor,3,"4d(d+1)(d+2)/3",rep][i1,alpha,beta,-B]+1/2g1[alpha,beta,mu,A,B]t[spinor,3,"4d(d+1)(d+2)/3",rep][i1,nu,rho,-B]+1/2g1[alpha,mu,nu,A,B]t[spinor,3,"4d(d+1)(d+2)/3",rep][i1,rho,beta,-B]-1/2g1[beta,mu,nu,A,B]t[spinor,3,"4d(d+1)(d+2)/3",rep][i1,rho,alpha,-B],{mu,nu,rho}]]];
(*\[Gamma]4 t2*)AppendTo[reps,inject[{t->tens,g1->Symbol[gam<>"4"]},g1[mu_,nu_,rho_,sigma_,A_,B_]t[spinor,3,"4d(d+1)(d+2)/3",rep__][i1___,alpha_,beta_,-B_]:>Antisymmetrize[3/5g1[mu,nu,rho,sigma,A,B]t[spinor,3,"4d(d+1)(d+2)/3",rep][i1,alpha,beta,-B]-3/5g1[alpha,mu,nu,rho,A,B]t[spinor,3,"4d(d+1)(d+2)/3",rep][i1,sigma,beta,-B]+3/5g1[beta,mu,nu,rho,A,B]t[spinor,3,"4d(d+1)(d+2)/3",rep][i1,sigma,alpha,-B]+3/5g1[alpha,beta,mu,nu,A,B]t[spinor,3,"4d(d+1)(d+2)/3",rep][i1,rho,sigma,-B],{mu,nu,rho,sigma}]]];
,
(*\[Gamma]3 t1*)AppendTo[reps,inject[{t->tens,g1->Symbol[gam<>"3"]},g1[mu_,nu_,rho_,A_,B_]t[spinor,3,"2d(d-1)(d-2)",rep__][i1___,alpha_,-B_]:>3/4g1[mu,nu,rho,A,B]t[spinor,3,"2d(d-1)(d-2)",rep][i1,alpha,-B]+1/4g1[alpha,mu,nu,A,B]t[spinor,3,"2d(d-1)(d-2)",rep][i1,rho,-B]+1/4g1[alpha,rho,mu,A,B]t[spinor,3,"2d(d-1)(d-2)",rep][i1,nu,-B]+1/4g1[alpha,nu,rho,A,B]t[spinor,3,"2d(d-1)(d-2)",rep][i1,mu,-B]]];
(*\[Gamma]3 t1*)AppendTo[reps,inject[{t->tens,g1->Symbol[gam<>"3"]},g1[mu_,nu_,rho_,A_,B_]Verbatim[CenterDot][left___,t[spinor,3,"2d(d-1)(d-2)",rep__][i1___,alpha_,-B_],right___]:>3/4g1[mu,nu,rho,A,B]CenterDot[left,t[spinor,3,"2d(d-1)(d-2)",rep][i1,alpha,-B],right]+1/4g1[alpha,mu,nu,A,B]CenterDot[left,t[spinor,3,"2d(d-1)(d-2)",rep][i1,rho,-B],right]+1/4g1[alpha,rho,mu,A,B]CenterDot[left,t[spinor,3,"2d(d-1)(d-2)",rep][i1,nu,-B],right]+1/4g1[alpha,nu,rho,A,B]CenterDot[left,t[spinor,3,"2d(d-1)(d-2)",rep][i1,mu,-B],right]]];
(*\[Gamma]3 t1*)AppendTo[reps,inject[{t->tens,g1->Symbol[gam<>"3"]},g1[mu_,nu_,rho_,A_,B_]t[spinor,3,"4d(d+1)(d-1)",rep__][i1___,alpha_,-B_]:>3/4g1[mu,nu,rho,A,B]t[spinor,3,"4d(d+1)(d-1)",rep][i1,alpha,-B]+1/4g1[alpha,mu,nu,A,B]t[spinor,3,"4d(d+1)(d-1)",rep][i1,rho,-B]+1/4g1[alpha,rho,mu,A,B]t[spinor,3,"4d(d+1)(d-1)",rep][i1,nu,-B]+1/4g1[alpha,nu,rho,A,B]t[spinor,3,"4d(d+1)(d-1)",rep][i1,mu,-B]]];
(*\[Gamma]3 t1*)AppendTo[reps,inject[{t->tens,g1->Symbol[gam<>"3"]},g1[mu_,nu_,rho_,A_,B_]Verbatim[CenterDot][left___,t[spinor,3,"4d(d+1)(d-1)",rep__][i1___,alpha_,-B_],right___]:>3/4g1[mu,nu,rho,A,B]CenterDot[left,t[spinor,3,"4d(d+1)(d-1)",rep][i1,alpha,-B],right]+1/4g1[alpha,mu,nu,A,B]CenterDot[left,t[spinor,3,"4d(d+1)(d-1)",rep][i1,rho,-B],right]+1/4g1[alpha,rho,mu,A,B]CenterDot[left,t[spinor,3,"4d(d+1)(d-1)",rep][i1,nu,-B],right]+1/4g1[alpha,nu,rho,A,B]CenterDot[left,t[spinor,3,"4d(d+1)(d-1)",rep][i1,mu,-B],right]]];
(*\[Gamma]1 t2*)AppendTo[reps,inject[{t->tens,g1->Symbol[gam<>"1"]},g1[mu_,A_,B_]t[spinor,3,"4d(d-1)(d-2)/3",rep__][i1___,alpha_,beta_,-B_]:>2/3g1[mu,A,B]t[spinor,3,"4d(d-1)(d-2)/3",rep][i1,alpha,beta,-B]-1/3g1[alpha,A,B]t[spinor,3,"4d(d-1)(d-2)/3",rep][i1,beta,mu,-B]+1/3g1[beta,A,B]t[spinor,3,"4d(d-1)(d-2)/3",rep][i1,alpha,mu,-B]]];
(*\[Gamma]1 t2*)AppendTo[reps,inject[{t->tens,g1->Symbol[gam<>"1"]},g1[mu_,A_,B_]Verbatim[CenterDot][left___,t[spinor,3,"4d(d-1)(d-2)/3",rep__][i1___,alpha_,beta_,-B_],right___]:>2/3g1[mu,A,B]CenterDot[left,t[spinor,3,"4d(d-1)(d-2)/3",rep][i1,alpha,beta,-B],right]-1/3g1[alpha,A,B]CenterDot[left,t[spinor,3,"4d(d-1)(d-2)/3",rep][i1,beta,mu,-B],right]+1/3g1[beta,A,B]CenterDot[left,t[spinor,3,"4d(d-1)(d-2)/3",rep][i1,alpha,mu,-B],right]]];
(*\[Gamma]2 t2*)AppendTo[reps,inject[{t->tens,g1->Symbol[gam<>"2"]},g1[mu_,nu_,A_,B_]t[spinor,3,"4d(d-1)(d-2)/3",rep__][i1___,alpha_,beta_,-B_]:>Antisymmetrize[5/6g1[mu,nu,A,B]t[spinor,3,"4d(d-1)(d-2)/3",rep][i1,alpha,beta,-B]-1/3g1[mu,alpha,A,B]t[spinor,3,"4d(d-1)(d-2)/3",rep][i1,beta,nu,-B]+1/3g1[mu,beta,A,B]t[spinor,3,"4d(d-1)(d-2)/3",rep][i1,alpha,nu,-B]-1/6g1[alpha,beta,A,B]t[spinor,3,"4d(d-1)(d-2)/3",rep][i1,mu,nu,-B],{mu,nu}]]];
(*\[Gamma]2 t2*)AppendTo[reps,inject[{t->tens,g1->Symbol[gam<>"2"]},g1[mu_,nu_,A_,B_]Verbatim[CenterDot][left___,t[spinor,3,"4d(d-1)(d-2)/3",rep__][i1___,alpha_,beta_,-B_],right___]:>Antisymmetrize[5/6g1[mu,nu,A,B]t[spinor,3,"4d(d-1)(d-2)/3",rep][i1,alpha,beta,-B]-1/3g1[mu,alpha,A,B]CenterDot[left,t[spinor,3,"4d(d-1)(d-2)/3",rep][i1,beta,nu,-B],right]+1/3g1[mu,beta,A,B]CenterDot[left,t[spinor,3,"4d(d-1)(d-2)/3",rep][i1,alpha,nu,-B],right]-1/6g1[alpha,beta,A,B]CenterDot[left,t[spinor,3,"4d(d-1)(d-2)/3",rep][i1,mu,nu,-B],right],{mu,nu}]]];
(*\[Gamma]3 t2*)AppendTo[reps,inject[{t->tens,g1->Symbol[gam<>"3"]},g1[mu_,nu_,rho_,A_,B_]t[spinor,3,"4d(d-1)(d-2)/3",rep__][i1___,alpha_,beta_,-B_]:>Antisymmetrize[1/2g1[mu,nu,rho,A,B]t[spinor,3,"4d(d-1)(d-2)/3",rep][i1,alpha,beta,-B]+1/2g1[alpha,beta,mu,A,B]t[spinor,3,"4d(d-1)(d-2)/3",rep][i1,nu,rho,-B]+1/2g1[alpha,mu,nu,A,B]t[spinor,3,"4d(d-1)(d-2)/3",rep][i1,rho,beta,-B]-1/2g1[beta,mu,nu,A,B]t[spinor,3,"4d(d-1)(d-2)/3",rep][i1,rho,alpha,-B],{mu,nu,rho}]]];
(*\[Gamma]3 t2*)AppendTo[reps,inject[{t->tens,g1->Symbol[gam<>"3"]},g1[mu_,nu_,rho_,A_,B_]Verbatim[CenterDot][left___,t[spinor,3,"4d(d-1)(d-2)/3",rep__][i1___,alpha_,beta_,-B_],right___]:>Antisymmetrize[1/2g1[mu,nu,rho,A,B]t[spinor,3,"4d(d-1)(d-2)/3",rep][i1,alpha,beta,-B]+1/2g1[alpha,beta,mu,A,B]CenterDot[left,t[spinor,3,"4d(d-1)(d-2)/3",rep][i1,nu,rho,-B],right]+1/2g1[alpha,mu,nu,A,B]CenterDot[left,t[spinor,3,"4d(d-1)(d-2)/3",rep][i1,rho,beta,-B],right]-1/2g1[beta,mu,nu,A,B]CenterDot[left,t[spinor,3,"4d(d-1)(d-2)/3",rep][i1,rho,alpha,-B],right],{mu,nu,rho}]]];
(*\[Gamma]4 t2*)AppendTo[reps,inject[{t->tens,g1->Symbol[gam<>"4"]},g1[mu_,nu_,rho_,sigma_,A_,B_]t[spinor,3,"4d(d-1)(d-2)/3",rep__][i1___,alpha_,beta_,-B_]:>Antisymmetrize[3/5g1[mu,nu,rho,sigma,A,B]t[spinor,3,"4d(d-1)(d-2)/3",rep][i1,alpha,beta,-B]-3/5g1[alpha,mu,nu,rho,A,B]t[spinor,3,"4d(d-1)(d-2)/3",rep][i1,sigma,beta,-B]+3/5g1[beta,mu,nu,rho,A,B]t[spinor,3,"4d(d-1)(d-2)/3",rep][i1,sigma,alpha,-B]+3/5g1[alpha,beta,mu,nu,A,B]t[spinor,3,"4d(d-1)(d-2)/3",rep][i1,rho,sigma,-B],{mu,nu,rho,sigma}]]];
(*\[Gamma]4 t2*)AppendTo[reps,inject[{t->tens,g1->Symbol[gam<>"4"]},g1[mu_,nu_,rho_,sigma_,A_,B_]Verbatim[CenterDot][left___,t[spinor,3,"4d(d-1)(d-2)/3",rep__][i1___,alpha_,beta_,-B_],right___]:>Antisymmetrize[3/5g1[mu,nu,rho,sigma,A,B]t[spinor,3,"4d(d-1)(d-2)/3",rep][i1,alpha,beta,-B]-3/5g1[alpha,mu,nu,rho,A,B]CenterDot[left,t[spinor,3,"4d(d-1)(d-2)/3",rep][i1,sigma,beta,-B],right]+3/5g1[beta,mu,nu,rho,A,B]CenterDot[left,t[spinor,3,"4d(d-1)(d-2)/3",rep][i1,sigma,alpha,-B],right]+3/5g1[alpha,beta,mu,nu,A,B]CenterDot[left,t[spinor,3,"4d(d-1)(d-2)/3",rep][i1,rho,sigma,-B],right],{mu,nu,rho,sigma}]]];
],
If[comm,
(*\[Gamma]3 t1*)AppendTo[reps,inject[{t->tens,g1->Symbol[gam<>"3"]},g1[mu_,nu_,rho_,A_,B_]t[spinor,3,"12",rep__][i1___,alpha_,-B_]:>3/4g1[mu,nu,rho,A,B]t[spinor,3,"12",rep][i1,alpha,-B]+1/4g1[alpha,mu,nu,A,B]t[spinor,3,"12",rep][i1,rho,-B]+1/4g1[alpha,rho,mu,A,B]t[spinor,3,"12",rep][i1,nu,-B]+1/4g1[alpha,nu,rho,A,B]t[spinor,3,"12",rep][i1,mu,-B]]];
(*\[Gamma]1 t2*)AppendTo[reps,inject[{t->tens,g1->Symbol[gam<>"1"]},g1[mu_,A_,B_]t[spinor,3,"8",rep__][i1___,alpha_,beta_,-B_]:>2/3g1[mu,A,B]t[spinor,3,"8",rep][i1,alpha,beta,-B]-1/3g1[alpha,A,B]t[spinor,3,"8",rep][i1,beta,mu,-B]+1/3g1[beta,A,B]t[spinor,3,"8",rep][i1,alpha,mu,-B]]];
(*\[Gamma]2 t2*)AppendTo[reps,inject[{t->tens,g1->Symbol[gam<>"2"]},g1[mu_,nu_,A_,B_]t[spinor,3,"8",rep__][i1___,alpha_,beta_,-B_]:>Antisymmetrize[5/6g1[mu,nu,A,B]t[spinor,3,"8",rep][i1,alpha,beta,-B]-1/3g1[mu,alpha,A,B]t[spinor,3,"8",rep][i1,beta,nu,-B]+1/3g1[mu,beta,A,B]t[spinor,3,"8",rep][i1,alpha,nu,-B]-1/6g1[alpha,beta,A,B]t[spinor,3,"8",rep][i1,mu,nu,-B],{mu,nu}]]];
(*\[Gamma]3 t2*)AppendTo[reps,inject[{t->tens,g1->Symbol[gam<>"3"]},g1[mu_,nu_,rho_,A_,B_]t[spinor,3,"8",rep__][i1___,alpha_,beta_,-B_]:>Antisymmetrize[1/2g1[mu,nu,rho,A,B]t[spinor,3,"8",rep][i1,alpha,beta,-B]+1/2g1[alpha,beta,mu,A,B]t[spinor,3,"8",rep][i1,nu,rho,-B]+1/2g1[alpha,mu,nu,A,B]t[spinor,3,"8",rep][i1,rho,beta,-B]-1/2g1[beta,mu,nu,A,B]t[spinor,3,"8",rep][i1,rho,alpha,-B],{mu,nu,rho}]]];
(*\[Gamma]4 t2*)AppendTo[reps,inject[{t->tens,g1->Symbol[gam<>"4"]},g1[mu_,nu_,rho_,sigma_,A_,B_]t[spinor,3,"8",rep__][i1___,alpha_,beta_,-B_]:>Antisymmetrize[3/5g1[mu,nu,rho,sigma,A,B]t[spinor,3,"8",rep][i1,alpha,beta,-B]-3/5g1[alpha,mu,nu,rho,A,B]t[spinor,3,"8",rep][i1,sigma,beta,-B]+3/5g1[beta,mu,nu,rho,A,B]t[spinor,3,"8",rep][i1,sigma,alpha,-B]+3/5g1[alpha,beta,mu,nu,A,B]t[spinor,3,"8",rep][i1,rho,sigma,-B],{mu,nu,rho,sigma}]]];
]
];
(* traces *)
AppendTo[reps,inject[{t->tens},t[spinor,__][___,a_,___,-a_,___]:>0]];
AppendTo[reps,inject[{t->tens},t[spinor,__][___,-a_,___,a_,___]:>0]];
(* Young tableau projection for lie algebra indices *)
If[extralie,
If[comm,
(*13,2*)AppendTo[reps,inject[{t->tens},t[spinor,3,"4d(d+1)(d-1)/3",rep__][a_,b_,c_,A_]:>2/3t[spinor,3,"4d(d+1)(d-1)/3",rep][a,b,c,A]+1/3t[spinor,3,"4d(d+1)(d-1)/3",rep][a,c,b,A]-1/3t[spinor,3,"4d(d+1)(d-1)/3",rep][b,c,a,A]]];
(*12,3*)AppendTo[reps,inject[{t->tens},t[spinor,3,"4d(d+1)(d-1)",rep__][a_,b_,c_,mu_,A_]:>2/3t[spinor,3,"4d(d+1)(d-1)",rep][a,b,c,mu,A]-1/3t[spinor,3,"4d(d+1)(d-1)",rep][a,c,b,mu,A]-1/3t[spinor,3,"4d(d+1)(d-1)",rep][b,c,a,mu,A]]];
(*13,2*)AppendTo[reps,inject[{t->tens},t[spinor,3,"4d(d+1)(d-1)/3*",rep__][a_,b_,c_,A_]:>2/3t[spinor,3,"4d(d+1)(d-1)/3*",rep][a,b,c,A]+1/3t[spinor,3,"4d(d+1)(d-1)/3*",rep][a,c,b,A]-1/3t[spinor,3,"4d(d+1)(d-1)/3*",rep][b,c,a,A]]];
,
(*12,3*)AppendTo[reps,inject[{t->tens},t[spinor,3,"4d(d+1)(d-1)/3",rep__][a_,b_,c_,A_]:>2/3t[spinor,3,"4d(d+1)(d-1)/3",rep][a,b,c,A]-1/3t[spinor,3,"4d(d+1)(d-1)/3",rep][a,c,b,A]-1/3t[spinor,3,"4d(d+1)(d-1)/3",rep][b,c,a,A]]];
(*13,2*)AppendTo[reps,inject[{t->tens},t[spinor,3,"4d(d+1)(d-1)",rep__][a_,b_,c_,mu_,A_]:>2/3t[spinor,3,"4d(d+1)(d-1)",rep][a,b,c,mu,A]+1/3t[spinor,3,"4d(d+1)(d-1)",rep][a,c,b,mu,A]-1/3t[spinor,3,"4d(d+1)(d-1)",rep][b,c,a,mu,A]]];
(*12,3*)AppendTo[reps,inject[{t->tens},t[spinor,3,"4d(d+1)(d-1)/3*",rep__][a_,b_,c_,A_]:>2/3t[spinor,3,"4d(d+1)(d-1)/3*",rep][a,b,c,A]-1/3t[spinor,3,"4d(d+1)(d-1)/3*",rep][a,c,b,A]-1/3t[spinor,3,"4d(d+1)(d-1)/3*",rep][b,c,a,A]]];
]
];
(* replace *)
reps=Dispatch[reps];
repsyoung=Dispatch[repsyoung];
repslie=Dispatch[repslie];
expr/.reps/.repsyoung/.repslie
]


(* ::Input::Initialization:: *)
(****************************** 2.10 Gradings ******************************)


(* ::Input::Initialization:: *)
$Gradings={};


(* ::Input::Initialization:: *)
Options[DefGrading]={SumGrading->(Undefined&),ZeroGrading->Undefined,Master->Null,ProtectNewSymbol:>$ProtectNewSymbols,DefInfo->{"grading",""}};
DefGrading[list_List,rest___]:=Scan[DefGrading[#,rest]&,list];
DefGrading[gh_,options:OptionsPattern[]]:=Catch@With[{head=SubHead[gh]},Module[{sg,zg,master,pns,info},{sg,zg,master,pns,info}=OptionValue[{SumGrading,ZeroGrading,Master,ProtectNewSymbol,DefInfo}];
(*Validate*)ValidateSymbol[head];
ValidateSymbolInSession[head];
(*Register*)xAct`xTensor`Private`MakeDefInfo[DefGrading,gh,info];
MakexTensions[DefGrading,"Beginning",gh,options];
AppendToUnevaluated[$Gradings,head];
head/:GradingQ[gh]=True;
head/:DefInfo[gh]=info;
xAct`xTensor`Private`SymbolRelations[head,master,{}];
(*not linear in general*)LinearQ[head]^=False;
(*numbers have no grading*)head/:head[Verbatim[Times][l___,x_?NumericQ,r___]]:=head[Times[l,r]];
(*sums have grading according to options*)head/:head[sum_Plus]:=sg[head[#]&/@List@@sum];
(*zero has grading according to options*)head/:head[0]:=zg;
(*additive over products*)head/:head[Verbatim[Times][l___,p_?(!NumericQ[#]&),r___]]:=head[p]+head[Times[l,r]];
head/:head[Verbatim[CenterDot][l___,p_?(!NumericQ[#]&),r___]]:=head[p]+head[CenterDot[l,r]];
(*additive over derivatives*)head/:head[t_?CovDQ[i___][expr_]]:=Length[{i}]head[t]+head[expr];
(*ignore tensor indices*)head/:head[t_?xTensorQ[i___]]:=head[t];
(*simplifications when acting on index free expressions*)head/:head[IndexFree[t_?CovDQ[expr_]]]:=head[t]+head[IndexFree[expr]];
head/:head[IndexFree[Verbatim[Times][l_,r___]]]:=head[IndexFree[Times[l]]]+head[IndexFree[Times[r]]];
head/:head[IndexFree[t_?xTensorQ]]:=head[t];
head/:head[IndexFree[t_^k_Integer]]:=k head[IndexFree[t]];
(*Register*)MakexTensions[DefGrading,"End",gh,options];
(*Protect*)If[pns,Protect[head]];]];
SetNumberOfArguments[DefGrading,{1,Infinity}];
Protect[DefGrading];


(* ::Input::Initialization:: *)
UndefGrading[gh_]:=Catch@With[{head=SubHead[gh]},Module[{servants=ServantsOf[head]},
If[!MemberQ[$Gradings,head],Throw@Message[UndefGrading::unknown,"grading",head]];
xAct`xTensor`Private`CheckRemoveSymbol[head];
MakexTensions[UndefGrading,"Beginning",head];
xUpSet[ServantsOf[head],{}];xAct`xTensor`Private`DropFromHosts[head];Undef/@Reverse[servants];$Gradings=DeleteCases[$Gradings,head];MakexTensions[UndefGrading,"End",head];xAct`xTensor`Private`MakeUndefInfo[UndefGrading,head];xAct`xTensor`Private`RemoveSymbol[head];
]];
SetNumberOfArguments[UndefGrading,1];
Protect[UndefGrading];


(* ::Input::Initialization:: *)
SetGrading[list_List,rest___]:=Scan[SetGrading[#,rest]&,list];
SetGrading[tens_,list_List]:=Scan[SetGrading[tens,#]&,list];
SetGrading[tens_,r_Rule]:=Catch@Module[{head=SubHead[tens]},
If[!MemberQ[$Gradings,r[[1]]],Throw@Message[SetGrading::unknown,r[[1]],"as a grading"]];
xTagSet[{head,r[[1]][head]},r[[2]]];
(* set the grading also for the barred spinor *)
If[SpinorQ[head]&&(!SpinorBarQ[head]),head=ConjugateSpinor[head];xTagSet[{head,r[[1]][head]},r[[2]]];];
];
SetNumberOfArguments[SetGrading,2];
Protect[SetGrading];


(* ::Input::Initialization:: *)
(****************************** 2.11 Left and right variational derivatives ******************************)


(* ::Input::Initialization:: *)
(* Assume PD derivative *)
LeftVarD[tensor_][expr_]:=LeftVarD[tensor,PD][expr];
(* Generate rest. Replace dummies in expr. This does not act on scalar arguments of functions *)
LeftVarD[tensor_,der_][expr_]:=If[ScalarQ[expr],LeftVarD[tensor,der][ReplaceDummies[expr],1,1],Throw@Message[VarD::nouse,"VarD","a non-scalar expression"]];
(* Thread over Plus *)
LeftVarD[tensor_,der_][expr_Plus,lrest_,rrest_]:=LeftVarD[tensor,der][#,lrest,rrest]&/@expr;
(* VarD on products *)
LeftVarD[tensor_,der_][expr_Times|expr_CenterDot,lrest_,rrest_]:=LeftVarD[tensor,der][expr[[1]],lrest,expr[[2;;-1]]\[CenterDot]rrest]+(-1)^(Parity[expr[[1]]]Parity[tensor])LeftVarD[tensor,der][expr[[2;;-1]],lrest\[CenterDot]expr[[1]],rrest];
(* Scalar functions *)
LeftVarD[tensor_,der_][func_?ScalarFunctionQ[args___],lrest_,rrest_]:=With[{repargs=ReplaceDummies/@{args}},Plus@@MapThread[LeftVarD[tensor,der][#1,lrest\[CenterDot](Derivative@@#2)[func]@@repargs,rrest]&,{repargs,IdentityMatrix[Length[repargs]]}]];
(* Remove Scalar head because in general the result is not a scalar *)
LeftVarD[tensor_,der_][Scalar[expr_],lrest_,rrest_]:=LeftVarD[tensor,der][NoScalar@Scalar[expr],lrest,rrest];
(* Constants *)
LeftVarD[tensor_,der_][x_?ConstantQ,lrest_,rrest_]:=0;
(* Same tensor: metric. Do not use ContractMetric, which hides the metric *)
LeftVarD[metric_[a_,b_],der_][metric_Symbol?MetricQ[c_,d_],lrest_,rrest_]:=xAct`xTensor`Private`metricsign[a,b,c,d]ToCanonical[lrest\[CenterDot]rrest(metric[ChangeIndex@a,c]metric[ChangeIndex@b,d]+metric[ChangeIndex@a,d]metric[ChangeIndex@b,c])/2,UseMetricOnVBundle->None];
(* Same tensor. Place indices in proper delta positions. QUESTION: could this be problematic for spinors? *)
LeftVarD[tensor_[inds1___],der_][tensor_?xTensorQ[inds2___],lrest_,rrest_]:=With[{clist=ChangeIndex/@IndexList[inds1]},
ToCanonical[ImposeSymmetry[Inner[xAct`xTensor`Private`varddelta,clist,IndexList[inds2],Times],clist,SymmetryGroupOfTensor[tensor[inds1]]]lrest\[CenterDot]rrest,UseMetricOnVBundle->None]];
(* A different tensor *)
LeftVarD[tensor1_[inds1___],der_][tensor2_?xTensorQ[inds2___],lrest_,rrest_]:=0/;!ImplicitTensorDepQ[tensor2,tensor1];
(* Same connection: integration by parts including torsion *)
LeftVarD[tensor_,covd_][covd_?CovDQ[ind_][expr_],lrest_,rrest_]:=-LeftVarD[tensor,covd][expr,covd[ind][lrest],rrest]-LeftVarD[tensor,covd][expr,lrest,covd[ind][rrest]]+If[TorsionQ[covd],With[{i2=DummyIn@VBundleOfIndex[ind]},LeftVarD[tensor,covd][Torsion[covd][i2,-i2,ind]expr,lrest,rrest]],0];
(* Symmetrized derivatives: explode them, since we need to split between left and right remainder *)
LeftVarD[tensor_,covd_][covd_?SymCovDQ[inds__][expr_],lrest_,rrest_]:=LeftVarD[tensor,covd][ExpandSymCovDs[covd[inds][expr],covd],lrest,rrest];
(* Different connection: ChangeCovD *)
LeftVarD[tensor_,covd1_?CovDQ][expr:covd2_?CovDQ[_][_],lrest_,rrest_]:=LeftVarD[tensor,covd1][ChangeCovD[expr,covd2,covd1],lrest,rrest]/;xAct`xTensor`Private`CompatibleCovDsQ[covd1,covd2];
(* Support for parametric derivatives *)
LeftVarD[tensor_,OverDot][OverDot[expr_],lrest_,rrest_]:=-LeftVarD[tensor,OverDot][expr,OverDot[lrest],rrest]-LeftVarD[tensor,OverDot][expr,lrest,OverDot[rrest]];
LeftVarD[tensor_,ParamD[p_]][ParamD[pl___,p_,pr___][expr_],lrest_,rrest_]:=-LeftVarD[tensor,ParamD[p]][ParamD[pl,pr][expr],ParamD[p][lrest],rrest]-LeftVarD[tensor,ParamD[p]][ParamD[pl,pr][expr],lrest,ParamD[p][rrest]];
Protect[LeftVarD];


(* ::Input::Initialization:: *)
(* Assume PD derivative *)
RightVarD[tensor_][expr_]:=RightVarD[tensor,PD][expr];
(* Thread over Plus *)
RightVarD[tensor_,der_][expr_Plus]:=RightVarD[tensor,der][#]&/@expr;
(* Grading for products, which must be scalars *)
RightVarD[tensor_,der_][expr_]:=If[ScalarQ[expr],(-1)^((1+Parity[expr])Parity[tensor])LeftVarD[tensor,der][NoScalar@Scalar[expr],1,1],Throw@Message[VarD::nouse,"VarD","a non-scalar expression"]];
Protect[RightVarD];


(* ::Input::Initialization:: *)
(****************************** 2.12 Contractions and Monomials ******************************)


(* ::Input::Initialization:: *)
ReduceAllContractions[expr_,reps_:{}]:=Module[{expr2,bd,bdi},
expr2=Nest[xAct`xTras`Private`DeleteDuplicateFactors,ToCanonical[ContractMetric[expr/.reps]],2];
bd=DeleteDuplicates[VBundleOfIndex/@List@@FindIndices[expr]];
bdi=IndexList@@Flatten[Map[IndicesOfVBundle,bd]];
ReplaceDummies[expr2,bdi]
];


(* ::Input::Initialization:: *)
Options[FindAllContractions]^={Verbose->False,SymmetrizeMethod->ImposeSymmetry,AuxiliaryTensor->Default,Parallelization->(System`$VersionNumber>=8)};
FindAllContractions[expr_,options___?OptionQ]:=FindAllContractions[expr, IndexList[], options];
FindAllContractions[expr_,freeIndices:(IndexList|List)[___?AIndexQ],options___?OptionQ]:=FindAllContractions[expr, freeIndices, StrongGenSet[{},GenSet[]], options];
FindAllContractions[expr_List, freeIndices:(IndexList|List)[___?AIndexQ], symmetry_, options___?OptionQ]:=Union@@If[TrueQ[Verbose/.CheckOptions[options] /. Options[AllContractions]],MapTimed[#1,#2,Description->"Computing all contractions"]&,Map][FindAllContractions[#, freeIndices, symmetry, options]&,expr];
FindAllContractions[expr_,freeIndices:(IndexList|List)[___?AIndexQ], symmetry_, options___?OptionQ] := Module[{expl,parallel,verbose,symmethod,map,exprIndices,exprBundles,numBundleIndices,numIndices,spinbundles,sbmetric,spinbundlemetrics,metricsOfBundle,auxT,i,auxTexpr,auxTname,indexBundles,sym,man,contractions,contractionsPerBundle,indexlist,dummylist},
(* Set the options. *)
{parallel,verbose,symmethod,auxTname}={Parallelization,Verbose,SymmetrizeMethod,AuxiliaryTensor}/.CheckOptions[options]/.Options[FindAllContractions];
If[TrueQ[verbose],map=MapTimed,map=Map[#1,#2]&];
If[auxTname=!=Default,auxT=auxTname];
expl=FromIndexFree[expr];
(* Some checks *)
If[IndicesOf[Dummy][expl]=!=IndexList[],Throw@Message[FindAllContractions::error, "Input expression cannot have dummy indices."];];
If[!$xpermQ,Throw@Message[AllContractions::error, "There is no link to the external xPerm executable."];];
(* Get the indices of the complete expression (expr + freeindices), sort them by bundle, and count them. *)
exprIndices=Join[List@@freeIndices,List@@IndicesOf[Free][expl]];
exprBundles=VBundleOfIndex/@exprIndices;
numBundleIndices=Tally[exprBundles];
exprBundles=DeleteDuplicates[exprBundles];
(* Can only contract an even number of indices in all bundles *)
If[!AllTrue[numBundleIndices,(EvenQ[#[[2]]]&)],Return@{}];
numIndices=Plus@@Transpose[numBundleIndices][[2]];
(* If there are spin bundles, define temporarily a metric for them *)
spinbundles=Select[exprBundles,SpinBundleQ];
spinbundlemetrics={};
Block[{$DefInfoQ=False},For[i=1,i<=Length@spinbundles,i++,
sbmetric=Symbol[SymbolName[spinbundles[[i]]]<>"AuxMetric"];
man=GetIndicesOfVBundle[spinbundles[[i]],2];
DefTensor[sbmetric[-man[[1]],-man[[1]]],BaseOfVBundle[spinbundles[[i]]],Symmetric[{1,2}],DefInfo->{"metric of vbundle",""}];
MetricQ[sbmetric]^=True;
xUpAppendTo[MetricsOfVBundle[spinbundles[[i]]],sbmetric];
VBundleOfMetric[sbmetric]^=spinbundles[[i]];
AppendTo[$Metrics,sbmetric];
InducedFrom[sbmetric]^=Null;
sbmetric[a_Symbol,-b_Symbol]:=delta[a,-b];
sbmetric[-a_Symbol,b_Symbol]:=delta[-a,b];
CovDOfMetric[sbmetric]^=CovDOfMetric@First@MetricsOfVBundle@Tangent@BaseOfVBundle[spinbundles[[i]]];
AppendTo[spinbundlemetrics,sbmetric];
]];
(* Metrics must be symmetric *)
metricsOfBundle=MetricsOfVBundle/@exprBundles;
If[AnyTrue[metricsOfBundle,(Length[#]===0)&],Throw@Message[FindAllContractions::error, "No metric found for at least one bundle."]];
If[AnyTrue[metricsOfBundle,(xAct`xTensor`Private`SymmetryOfMetric@First[#]=!=1)&],Throw@Message[FindAllContractions::error, "Can't do contractions for non-symmetric metrics."]];
(* All bundles must be on the same base manifold *)
man=DeleteDuplicates[BaseOfVBundle/@exprBundles];
If[Length[man]===1,man=First@man,Throw@Message[FindAllContractions::error, "All bundles must be defined on the same base manifold."]];
(* Define an auxiliary tensor if it is not already defined. We vary w.r.t. to this tensor afterwards to free the indices. *)
If[xTensorQ[auxT],
If[SymmetryGroupOfTensor[auxT]=!=(xAct`xTensor`Private`SGSofsym[symmetry]/.Thread[List@@freeIndices->Range@Length@freeIndices])||SlotsOfTensor[auxT]=!=(List@@freeIndices/.{i_?AbstractIndexQ:>VBundleOfIndex[i]}),
Throw@Message[FindAllContractions::error, "Existing auxiliary tensor has wrong index structure and/or symmetry."];],
ValidateSymbol[Evaluate@auxT];
Block[{$DefInfoQ=False},DefTensor[auxT@@freeIndices,man,symmetry]];
];
(* Replace indices on the auxT (because they might overlap with expr). *)
auxTexpr=expl*auxT@@Table[DummyIn@VBundleOfIndex[freeIndices[[i]]],{i,1,Length@freeIndices}];
(* Get the symmetry, sorted per bundle. *)
sym=BundleSymmetryOf[auxTexpr,Sorted->False,Offset->True];
(* Use xTras function to compute the contractions, and put them into proper order. *)
contractionsPerBundle=Table[(First/@((InversePerm@Images[#]&)/@xAct`xTras`Private`ComputeContractions[sym[[4,i,3]],sym[[1,i,2]],sym[[1,i,2]]/2,False,False]))+sym[[4,i,2]],{i,1,Length[sym[[1]]]}];
If[MemberQ[contractionsPerBundle,{}],contractions={},
(* All contractions are obtained as tensor product of the contractions per bundle. *)
contractions=Outer[Join,Sequence@@contractionsPerBundle,1];
contractions=Flatten[contractions,Depth[contractions]-3];
(* Construct a list of indices from the proper bundle. Don't include freeIndices, because they will clash later when we remove the auxiliary tensor. *)
dummylist=Flatten[Function[GetIndicesOfVBundle[#[[1]],#[[2]]/2,UpIndex/@freeIndices]]/@sym[[1]]];
indexlist=IndexList@@Riffle[dummylist,-dummylist];
(* Reconstruct tensorial expressions from the permutations. *)
contractions=UxSort[Function[sym[[2]]/. Inner[Rule,xAct`xTensor`Private`slot/@IndexList@@Range[numIndices],PermuteList[indexlist,Images[#]],List]]/@contractions];
(* Remove the auxiliary tensor using the function from xTras. *)
contractions=xAct`xTras`Private`RemoveAuxT[contractions,auxT,freeIndices,IndexList@@dummylist,symmethod];
];
(* Lastly, undefine the auxiliary tensor. We couldn't do this before because we needed its symmetry in the previous step. *)
If[FreeQ[contractions,auxT],Block[{$UndefInfoQ=False},UndefTensor[auxT]]];
(* If there are spin bundles, convert \[Gamma] matrices and tensors into proper co-spinor form. At the end, remove \[Gamma] matrices with wrong index positions. *)
If[Length@spinbundles>0,
contractions=contractions/.{t_?GammaMatrixQ[inds___,si_?UpIndexQ,-si_]:>t[inds,-si,si]}/.{x_ t_?GammaMatrixQ[inds___,si_?UpIndexQ,si2_]/;!FreeQ[x,si]:>(x/.{si->-si})t[inds,-si,si2]}/.{x_ t_?GammaMatrixQ[inds___,si_,-si2_]/;!FreeQ[x,si2]:>(x/.{si2->-si2})t[inds,si,si2]}/.{t_?SpinorUnbarQ[inds___,si_?UpIndexQ]:>ConjugateSpinor[t][inds,si],t_?SpinorBarQ[inds___,si_?DownIndexQ]:>ConjugateSpinor[t][inds,si],t_?GammaMatrixQ[inds___,si_?UpIndexQ,si2_]:>0,t_?GammaMatrixQ[inds___,si_,si2_?DownIndexQ]:>0};
];
(* Also undefine temporary spin bundle metrics *)
Block[{$UndefInfoQ=False},For[i=1,i<=Length@spinbundles,i++,
sbmetric=spinbundlemetrics[[i]];
$Metrics=DeleteCases[$Metrics,sbmetric];
xUpSet[MetricsOfVBundle[spinbundles[[i]]],DeleteCases[MetricsOfVBundle[spinbundles[[i]]],sbmetric]];
UndefTensor[sbmetric];
]];
(* Now remove redundant contractions with a ToCanonical and return result. *)
xAct`xTras`Private`DeleteDuplicateFactors[map[ToCanonical,contractions,Description->"Removing duplicates."]]
];
SetNumberOfArguments[FindAllContractions,{1,Infinity}];
Protect[FindAllContractions];


(* ::Input::Initialization:: *)
Options[GenerateMonomials]={Verbose->False,FreeIndices->{},Constraint->(True&),Replacements->{},MaxNumberOfFields->5,MaxNumberOfInvTensors->1,MaxNumberOfDerivatives->3,IndexFree->False};
GenerateMonomials[fields_List,invtens_List,OptionsPattern[]]:=Catch@Module[{verbose,maxinvtens,maxder,maxfields,fdcomb,i,k,ansatzfd,ansatztens,ansatz,contr,cd},
{verbose,maxder,maxfields,maxinvtens}=OptionValue[{Verbose,MaxNumberOfDerivatives,MaxNumberOfFields,MaxNumberOfInvTensors}];
cd=CovDOfMetric[First@MetricsOfVBundle[Tangent[First@Select[DependenciesOfTensor[If[Head[fields[[1]]]===List,fields[[1,1]],fields[[1]]]],ManifoldQ]]]];
If[TrueQ[verbose],Print["GenerateMonomials: about to generate list of fields"]];
If[Head[fields[[1]]]===List,
If[Head[maxder]=!=List,maxder=ConstantArray[maxder,Length@fields]];
If[Head[maxfields]=!=List,maxfields=ConstantArray[maxfields,Length@fields]];
fdcomb=Table[Flatten[Table[Table[Nest[cd,f,i],{i,0,maxder[[k]]}],{f,fields[[k]]}]],{k,1,Length[fields]}];
ansatzfd=Table[(Times@@#)&/@Multisets[fdcomb[[i]],{0,maxfields[[i]]}],{i,Length[fields]}];
ansatzfd=Flatten[Outer[Times,Sequence@@ansatzfd]][[2;;-1]];
,
fdcomb=Flatten[Table[Table[Nest[cd,f,i],{i,0,maxder}],{f,fields}]];
ansatzfd=(Times@@#)&/@Multisets[fdcomb,{1,maxfields}];
];
If[Length@invtens===0,
If[TrueQ[verbose],Print["GenerateMonomials: about to impose constraint"]];
ansatz=Select[IndexFree/@Flatten[ansatzfd],OptionValue[Constraint]];
,
If[TrueQ[verbose],Print["GenerateMonomials: about to generate list of invariant tensors"]];
If[Head[invtens[[1]]]===List,
If[Head[maxinvtens]=!=List,maxinvtens=ConstantArray[maxinvtens,Length@invtens]];
ansatztens=Table[(Times@@#)&/@Multisets[invtens[[i]],{0,maxinvtens[[i]]}],{i,Length[invtens]}];
ansatztens=Flatten[Outer[Times,Sequence@@ansatztens]];
,
ansatztens=(Times@@#)&/@Multisets[invtens,{0,maxinvtens}];
];
If[TrueQ[verbose],Print["GenerateMonomials: about to impose constraint"]];
ansatz=Select[IndexFree/@Flatten[Outer[Times,ansatzfd,ansatztens]],OptionValue[Constraint]];
];
If[TrueQ@OptionValue[IndexFree],
ansatz,
If[TrueQ[verbose],Print["GenerateMonomials: about to contract indices"]];
contr=Flatten[(FindAllContractions[TimesToCenterDot@FromIndexFree[#],OptionValue[FreeIndices],Parallelization->False])&/@ansatz];
ReduceAllContractions[contr,OptionValue[Replacements]]
]
];
SetNumberOfArguments[GenerateMonomials,{2,Infinity}];
Protect[GenerateMonomials];


(* ::Input::Initialization:: *)
NotTooManyGammas[expr_]:=Module[{tens=AllTensors[expr]},Plus@@(Last/@Select[tens,Function[SpinorQ@First@#]])/2>=Plus@@(Last/@Select[tens,Function[GammaMatrixQ@First@#]])]
Options[GenerateMonomialsByGrading]={Verbose->False,FreeIndices->{},Constraint->(True&),Replacements->{},MaxNumberOfFields->Infinity,MaxNumberOfInvTensors->1,MaxNumberOfDerivatives->Infinity,FilterGammaMatrices->True,IndexFree->False};
GenerateMonomialsByGrading[fields_List,invtens_List,Rule[grad_?GradingQ,n_],OptionsPattern[]]:=Catch@Module[{verbose,fieldinfo,tensinfo,zerofieldinfo,maxder,maxfields,maxinvtens,filtergamma,cd,cdgrad,i,k,maxcd,maxfieldfunc,fldgrads,factor,cannotgrad,parts,ansatz,zeroansatz,contr},
{verbose,maxder,maxfields,maxinvtens,filtergamma}=OptionValue[{Verbose,MaxNumberOfDerivatives,MaxNumberOfFields,MaxNumberOfInvTensors,FilterGammaMatrices}];
cd=CovDOfMetric[First@MetricsOfVBundle[Tangent[First@Select[DependenciesOfTensor[If[Head[fields[[1]]]===List,fields[[1,1]],fields[[1]]]],ManifoldQ]]]];
(* gather information about fields: a list of terms of the form {A, grad(A), max #(A), max #CD(A)} *)
If[Head[fields[[1]]]===List,
If[Head[maxder]=!=List,maxder=ConstantArray[maxder,Length@fields]];
If[Head[maxfields]=!=List,maxfields=ConstantArray[maxfields,Length@fields]];
fieldinfo=Flatten[Table[Map[Function[{#,grad[#],maxfields[[i]],maxder[[i]]}],fields[[i]]],{i,Length@fields}],1];
,
fieldinfo=Map[Function[{#,grad[#],maxfields,maxder}],fields];
];
(* include invariant tensors, which also may be graded *)
If[Length@invtens=!=0,
If[Head[invtens[[1]]]===List,
If[Head[maxinvtens]=!=List,maxinvtens=ConstantArray[maxinvtens,Length@invtens]];
tensinfo=Flatten[Table[Map[Function[{#,grad[#],maxinvtens[[i]],0}],invtens[[i]]],{i,Length@invtens}],1];
,
tensinfo=Map[Function[{#,grad[#],maxinvtens,0}],invtens];
];
fieldinfo=Join[fieldinfo,tensinfo];
];
(* create a function to ensure that not more than the max number of fields is taken *)
maxfieldfunc={True};
If[Head[fields[[1]]]===List,
For[i=1,i<=Length@fields,i++,
If[maxfields[[i]]<Infinity,AppendTo[maxfieldfunc,ReleaseHold[(Plus@@Map[TensorCount[fldgrads,#]&,fields[[i]]])/.{fldgrads->Hold[#]}]<=maxfields[[i]]]];
];
,
If[maxfields<Infinity,AppendTo[maxfieldfunc,ReleaseHold[(Plus@@Map[TensorCount[fldgrads,#]&,fields])/.{fldgrads->Hold[#]}]<=maxfields]];
];
If[Length@invtens=!=0,
If[Head[invtens[[1]]]===List,
For[i=1,i<=Length@invtens,i++,
If[maxinvtens[[i]]<Infinity,AppendTo[maxfieldfunc,ReleaseHold[(Plus@@Map[TensorCount[fldgrads,#]&,invtens[[i]]])/.{fldgrads->Hold[#]}]<=maxinvtens[[i]]]];
];
,
If[maxinvtens<Infinity,AppendTo[maxfieldfunc,ReleaseHold[(Plus@@Map[TensorCount[fldgrads,#]&,invtens])/.{fldgrads->Hold[#]}]<=maxinvtens]];
];
];
maxfieldfunc=Function[Evaluate[And@@maxfieldfunc]];
(* sort by grading and split off the zero-dimension fields *)
fieldinfo=Reverse@SortBy[fieldinfo,#[[2]]&];
If[!AllTrue[fieldinfo[[All,2]],Reduce`RationalNumberQ],Throw@Message[GenerateMonomialsByGrading::error, "Gradings of all fields must be rational numbers."]];
If[!AllTrue[fieldinfo[[All,2]],NonNegative],Throw@Message[GenerateMonomialsByGrading::error, "Gradings of all fields must be non-negative."]];
i=First@FirstPosition[fieldinfo,{_,0,_,_},{0},{1}];
If[i==0,zerofieldinfo={};,zerofieldinfo=Drop[fieldinfo,i-1];fieldinfo=Take[fieldinfo,i-1];];
(* all zero-dimension fields must have a maximum number *)
If[!AllTrue[zerofieldinfo[[All,3]],(#<Infinity)&],Throw@Message[GenerateMonomialsByGrading::error, "Must specify a maximum number for fields with zero grading."]];
(* no derivatives can act on zero-dimension fields *)
If[!AllTrue[zerofieldinfo[[All,4]],(#==0)&],Throw@Message[GenerateMonomialsByGrading::error, "Cannot have derivatives acting on fields with zero grading."]];
(* if dimension of cd is zero, must have maximum number of derivatives *)
cdgrad=grad[cd];
If[(cdgrad==0)&&((!AllTrue[fieldinfo[[All,4]],(#<Infinity)&])||(!AllTrue[zerofieldinfo[[All,4]],(#<Infinity)&])),Throw@Message[GenerateMonomialsByGrading::error, "Must specify a maximum number of derivatives for derivative with zero grading."]];
If[TrueQ[verbose],Print["GenerateMonomialsByGrading: about to generate list of fields"]];
(* generate list of fields+derivatives and their gradings *)
tensinfo=ConstantArray[{},Length@fieldinfo];
For[i=1,i<=Length@fieldinfo,i++,
maxcd=Floor@If[cdgrad==0,fieldinfo[[i,4]],Min[(n-fieldinfo[[i,2]])/cdgrad,fieldinfo[[i,4]]]];
tensinfo[[i]]=Table[{Nest[cd,fieldinfo[[i,1]],k],fieldinfo[[i,2]]+k*cdgrad},{k,0,maxcd}];
];
tensinfo=Flatten[tensinfo,1];
tensinfo=Function[{#[[1,2]],#[[All,1]]}]/@GatherBy[tensinfo,Last];
(* get list of gradings and rescale to integers *)
fldgrads=tensinfo[[All,1]];
factor=1/GCD@@fldgrads;
cannotgrad=Complement[Range[n*factor],fldgrads*factor];
If[TrueQ[verbose],Print["GenerateMonomialsByGrading: about to generate integer partitions"]];
(* find partitions of n into integers, and exclude non-existent gradings *)
parts=Select[IntegerPartitions[n*factor],ContainsNone[#,cannotgrad]&]/factor;
If[TrueQ[verbose],Print["GenerateMonomialsByGrading: about to replace partition with fields"]];
(* replace gradings by fields, and select those with correct maximum number of fields *)
ansatz=IndexFree/@Flatten@Map[DeleteDuplicates[Times@@@Tuples@Table[Last@FirstCase[tensinfo,{dim,_}],{dim,#}]]&,parts];
ansatz=Select[ansatz,maxfieldfunc];
If[TrueQ[verbose],Print["GenerateMonomialsByGrading: about to generate ansatz for zero-dimension fields"]];
(* now for each field of zero dimension, take outer product, and ensure maximum number of fields is observed *)
zeroansatz={IndexFree[1]};
If[Length@zerofieldinfo>0,
For[i=1,i<=Length@zerofieldinfo,i++,
fldgrads=Table[zerofieldinfo[[i,1]]^k,{k,0,zerofieldinfo[[i,3]]}];
zeroansatz=Select[Flatten@Outer[Function[IndexFree@Times[#1,First@#2]],fldgrads,zeroansatz],maxfieldfunc];
];
];
If[TrueQ[verbose],Print["GenerateMonomialsByGrading: Length of ansatz =",Length@ansatz]];
If[TrueQ[verbose],Print["GenerateMonomialsByGrading: Length of zeroansatz =",Length@zeroansatz]];
If[TrueQ[verbose],Print["GenerateMonomialsByGrading: about to tensor with zero-dimension fields"]];
ansatz=Select[Flatten@Outer[Function[IndexFree@Times[First@#1,First@#2]],zeroansatz,ansatz],maxfieldfunc];
If[filtergamma,
If[TrueQ[verbose],Print["GenerateMonomialsByGrading: about to filter gamma matrices"]];
ansatz=Select[ansatz,NotTooManyGammas];
];
If[TrueQ[verbose],Print["GenerateMonomialsByGrading: about to impose constraint"]];
(* impose constraint *)
ansatz=DeleteDuplicates[Select[ansatz,OptionValue[Constraint]]];
If[TrueQ[verbose],Print["GenerateMonomialsByGrading: Length of ansatz =",Length@ansatz]];
If[TrueQ@OptionValue[IndexFree],
ansatz,
If[TrueQ[verbose],Print["GenerateMonomialsByGrading: about to contract indices"]];
contr=Flatten[(FindAllContractions[TimesToCenterDot@FromIndexFree[#],OptionValue[FreeIndices],Parallelization->False])&/@ansatz];
ReduceAllContractions[contr,OptionValue[Replacements]]
]
];
SetNumberOfArguments[GenerateMonomialsByGrading,{3,Infinity}];
Protect[GenerateMonomialsByGrading];


(* ::Input::Initialization:: *)
(****************************** 2.13 BRST operator and filtrations ******************************)


(* ::Input::Initialization:: *)
Options[DefOddDifferential]={Master->Null,ProtectNewSymbol:>$ProtectNewSymbols,DefInfo->{"grading",""}};
DefOddDifferential[gh_,options:OptionsPattern[]]:=Catch@With[{head=SubHead[gh]},Module[{master,pns,info},{master,pns,info}=OptionValue[{Master,ProtectNewSymbol,DefInfo}];
(*Validate*)ValidateSymbol[head];
ValidateSymbolInSession[head];
(*Register*)xAct`xTensor`Private`MakeDefInfo[DefOddDifferential,gh,info];
MakexTensions[DefOddDifferential,"Beginning",gh,options];
head/:DefInfo[gh]=info;
xAct`xTensor`Private`SymbolRelations[head,master,{}];
(* linear inert head *)LinearQ[head]^=True;
InertHeadQ[head]^=True;
(* sums *)head/:head[sum_Plus]:=Map[head,sum];
(* products *)head/:head[x_ y___]:=CenterDot[head[x],y]+(-1)^Parity[x]CenterDot[x,head[Times[y]]];
head/:head[Verbatim[CenterDot][x_, y___]]:=CenterDot[head[x],y]+(-1)^Parity[x]CenterDot[x,head[CenterDot[y]]];
(* constants *)head/:head[_?ConstantQ]:=0;
(* scalars *)head/:head[f_?ScalarFunctionQ[args___]]:=xAct`xTensor`Private`multiD[head,f[args]];
head/:head[Scalar[expr_]]:=head[NoScalar@Scalar[expr]];
(* lists *)head/:head[list_List]:=Map[head,list];
(* commutes with partial derivatives *)head/:head[PD[i___][expr_]]:=PD[i][head[expr]];
(* and invariant tensors *)head/:head[t_?InvariantTraceTensorQ[i__]]:=0;
(* and delta *)head/:head[delta[_,_]]:=0;
(* odd differential *)xTagSetDelayed[{head,Grade[head[expr_],CenterDot]},1+Grade[expr,CenterDot]];
(*Register*)MakexTensions[DefOddDifferential,"End",gh,options];
(*Protect*)If[pns,Protect[head]];]];
SetNumberOfArguments[DefOddDifferential,{1,Infinity}];
Protect[DefOddDifferential];


(* ::Input::Initialization:: *)
ClearAll[BRST];
Block[{$DefInfoQ=False},DefOddDifferential[BRST];];


(* ::Input::Initialization:: *)
ClearAll[BRST0];
Block[{$DefInfoQ=False},DefOddDifferential[BRST0];];


(* ::Input::Initialization:: *)
BRSTWeightInequalities[fields_List,brst_,weightname_:weight,reduce_:True]:=Module[{posweight,posweighttrue,newineq,ineq={},ineq2={},brstres,i},
posweight=Map[weightname[#]>=0&,fields];
posweighttrue=Map[(#->True)&,posweight];
For[i=1,i<=Length@fields,i++,
brstres=Expand[brst[FromIndexFree@IndexFree@fields[[i]]]];
If[brstres===0,Continue[]];
If[Head[brstres]===Plus,brstres=List@@brstres,brstres={brstres}];
newineq=Table[weightname[fields[[i]]]<=Sum[Count[brstpart,fld[___],{0,Infinity}]weightname[fld],{fld,fields}],{brstpart,brstres}];
AppendTo[ineq,newineq];
If[TrueQ@reduce,newineq=Reduce[Join[posweight,newineq],Reals]/.posweighttrue;];
AppendTo[ineq2,newineq];
];
newineq=Map[(#[[2]]-#[[1]])&,Flatten[ineq]];
Join[{posweight},{{Min[newineq]==0}},ineq2]
];
SetNumberOfArguments[BRSTWeightInequalities,{2,4}];
Protect[BRSTWeightInequalities];


(* ::Input::Initialization:: *)
FindBRSTWeights[fields_List,brst_,maxweight_Integer?NonNegative]:=Module[{weightineq,weightname,newineq,i},
weightineq={And@@Flatten@BRSTWeightInequalities[fields,brst,weightname,False]};
For[i=1,i<=Length@fields,i++,
weightineq=Map[Table[(#/.{weightname[fields[[i]]]->kk/2}),{kk,0,2maxweight}]&,weightineq];
];
Reverse[Position[First@weightineq,True],2]-1
];
SetNumberOfArguments[FindBRSTWeights,3];
Protect[FindBRSTWeights];


(* ::Input::Initialization:: *)
Options[CheckFiltration]={Display->IndexFree};
CheckFiltration[fields_List,weights_List,brst_,OptionsPattern[]]:=Catch@Module[{brstweightineq,weightname,brsttbl={},i,brstfilt},
If[!AllTrue[Evaluate[2weights],(IntegerQ[#]&&NonNegative[#])&],Throw@Message[CheckFiltration::invalid,weights,"filtration: weights must be positive (half-)integers or zero"]];
If[Length@fields!=Length@weights,Throw@Message[CheckFiltration::invalid,weights,"filtration: must specify as many weights as fields"]];
brstweightineq=And@@@(BRSTWeightInequalities[fields,brst,(#&),False]/.MapThread[Rule,{fields,weights}]);
If[brstweightineq[[2]]==False,Throw@Message[CheckFiltration::invalid,weights,"filtration: none of the BRST transformations preserves the weight"]];
For[i=3,i<=Length@brstweightineq,i++,
If[brstweightineq[[i]]==False,Throw@Message[CheckFiltration::invalid,weights,"filtration: BRST[" <> SymbolName[fields[[i-2]]] <>"] reduces the weight"]];
];
For[i=1,i<=Length@fields,i++,
(* get BRST transformation and convert to list *)
brstfilt=Expand[brst[FromIndexFree@IndexFree@fields[[i]]]];
If[Head[brstfilt]===Plus,brstfilt=List@@brstfilt,brstfilt={brstfilt}];
(* retain terms which do not change weight *)
brstfilt=Select[brstfilt,(weights[[i]]==Sum[Count[#,fields[[fld]][___],{0,Infinity}]weights[[fld]],{fld,Length@fields}])&];
If[OptionValue[Display]===IndexFree,
brstfilt=DeleteDuplicates@ToIndexFree[Nest[xAct`xTras`Private`DeleteDuplicateFactors,brstfilt,2]];
AppendTo[brsttbl,(ToString@brst<>"0")[IndexFree@fields[[i]]]->Plus@@brstfilt];
,
AppendTo[brsttbl,(ToString@brst<>"0")[FromIndexFree@IndexFree@fields[[i]]]->ScreenDollarIndices[Plus@@brstfilt]];
];
];
TableForm[brsttbl]
];
CheckFiltration[filtrfields:{Verbatim[Rule][___]..},brst_,options:OptionsPattern[]]:=CheckFiltration[First/@filtrfields,Last/@filtrfields,brst,options];
SetNumberOfArguments[CheckFiltration,{2,Infinity}];
Protect[CheckFiltration];


(* ::Input::Initialization:: *)
Filtrate[fields_List,weights_List,Rule[brst_,brst0_]]:=Catch@Module[{brstweightineq,weightname,i,field,brstfilt,fieldpat,rep,newbrst,prot=Unprotect[brst0]},
If[!AllTrue[weights,(IntegerQ[#]&&NonNegative[#])&],Throw@Message[CheckFiltration::invalid,weights,"filtration: weights must be positive integers or zero"]];
If[Length@fields!=Length@weights,Throw@Message[CheckFiltration::invalid,weights,"filtration: must specify as many weights as fields"]];
brstweightineq=And@@@(BRSTWeightInequalities[fields,brst,(#&),False]/.MapThread[Rule,{fields,weights}]);
If[brstweightineq[[2]]==False,Throw@Message[CheckFiltration::invalid,weights,"filtration: none of the BRST transformations preserves the weight"]];
For[i=3,i<=Length@brstweightineq,i++,
If[brstweightineq[[i]]==False,Throw@Message[CheckFiltration::invalid,weights,"filtration: BRST[" <> SymbolName[fields[[i-2]]] <>"] reduces the weight"]];
];
For[i=1,i<=Length@fields,i++,
(* get BRST transformation and convert to list *)
field=FromIndexFree@IndexFree@fields[[i]];
(* convert lower to upper indices if there is a metric *)
field=Function[If[DownIndexQ[#]&&(Length@MetricsOfVBundle@VBundleOfIndex[#]>0),Evaluate[-#],#]]/@field;
brstfilt=Expand[brst[field]];
If[Head[brstfilt]===Plus,brstfilt=List@@brstfilt,brstfilt={brstfilt}];
(* retain terms which do not change weight *)
brstfilt=Plus@@Select[brstfilt,(weights[[i]]==Sum[Count[#,fields[[fld]][___],{0,Infinity}]weights[[fld]],{fld,Length@fields}])&];
(* remove field from brst0 operator *)
DownValues[brst0]=DeleteCases[DownValues[brst0],inject[{rep->fields[[i]]},HoldPattern[Verbatim[HoldPattern][brst0[rep[___]]]:>_]]];
(* and add new transformation back *)
fieldpat=Function[If[DownIndexQ[#],-Pattern[Evaluate[-#],_],Pattern[#,_]]]/@field;
newbrst=ReplacePart[IndexRule[field,brstfilt],1->inject[{rep->fieldpat},HoldPattern[brst0[rep]]]];
AppendTo[DownValues[brst0],newbrst];
];
Protect[Evaluate[prot]];
];
Filtrate[filtrfields:{Verbatim[Rule][___]..},Rule[brst_,brst0_]]:=Filtrate[First/@filtrfields,Last/@filtrfields,Rule[brst,brst0]];
SetNumberOfArguments[Filtrate,{2,3}];
Protect[Filtrate];


(* ::Input::Initialization:: *)
RemoveFiltration[brst0_]:=Catch@Module[{prot=Unprotect[brst0]},
DownValues[brst0]=DownValues[brst0][[1;;11]];
Protect[Evaluate[prot]];
];
SetNumberOfArguments[RemoveFiltration,1];
Protect[RemoveFiltration];


(* ::Input::Initialization:: *)
(****************************** 2.14 Cohomology ******************************)


(* ::Input::Initialization:: *)
Options[CohomologyFromAnsatz]={SimplifyMethod->Identity,CanonicalizeMethod->Function[CollectTensors[ReduceInvariantTraceTensors[ContractMetric[SymmetrizeCovDs[Expand[#]]]],SimplifyMethod->Identity]]};
CohomologyFromAnsatz[opbrst_,ansatz_List,optriv_,ansatztriv_List,OptionsPattern[]]:=Module[{canmethod,simplmethod,consts,trivconsts,nontrivconsts,brstansatz,sollnull,sol,i,cohom,nontrivcohom},
canmethod=OptionValue[CanonicalizeMethod];
simplmethod=OptionValue[SimplifyMethod];
(* define constants for ansatz *)
consts=Map[Symbol["CohomologyFromAnsatzConst"<>ToString[#]]&,Range[Length@ansatz]];
Block[{$DefInfoQ=False},Quiet[DefConstantSymbol[consts],{ValidateSymbol::used}]];
trivconsts=Map[Symbol["CohomologyFromAnsatzConst"<>ToString[#]]&,Range[1+Length@ansatz,Length@ansatz+Length@ansatztriv]];
Block[{$DefInfoQ=False},Quiet[DefConstantSymbol[trivconsts],{ValidateSymbol::used}]];
(* make an ansatz for the cohomology *)
brstansatz=Dot[ansatz,consts];
(* apply transformation *)
sollnull=canmethod[opbrst[brstansatz]];
(* find solution *)
sol=Quiet[First@SolveConstants[sollnull==0,consts],Solve::svars];
brstansatz=brstansatz/.sol;
(* get elements of cohomology, sorted by simplicity *)
cohom=(Table[Coefficient[brstansatz,consts[[i]]],{i,Length[consts]}]/.{0->Sequence[]});
cohom=Sort[cohom,(LeafCount[#1]<LeafCount[#2])&];
(* make an ansatz for trivial elements and apply transformation *)
brstansatz=canmethod[optriv[Dot[ansatztriv,trivconsts]]];
(* filter out trivial elements *)
nontrivcohom={};
For[i=1,i<=Length[cohom],i++,
(* check if cohomology element can be written as a combination of trivial elements and elements which already have been found *)
nontrivconsts=consts[[1;;Length@nontrivcohom]];
sollnull=cohom[[i]]+brstansatz+Dot[nontrivcohom,nontrivconsts];
sol=Quiet[SolveConstants[sollnull==0,Join[trivconsts,nontrivconsts]],Solve::svars];
(* no solution was found, so we have a new non-trivial element *)
If[sol==={},AppendTo[nontrivcohom,simplmethod@cohom[[i]]]];
];
(* clean up*)
Block[{$UndefInfoQ=False},UndefConstantSymbol[consts]];
Block[{$UndefInfoQ=False},UndefConstantSymbol[trivconsts]];
(* return non-trivial elements *)
nontrivcohom
];
SetNumberOfArguments[CohomologyFromAnsatz,{4,Infinity}];
Protect[CohomologyFromAnsatz];


(* ::Input::Initialization:: *)
Options[RelativeCohomologyFromAnsatz]={SimplifyMethod->Identity,CanonicalizeMethod->Function[CollectTensors[ReduceInvariantTraceTensors[ContractMetric[SymmetrizeCovDs[Expand[#]]]],SimplifyMethod->Identity]]};
RelativeCohomologyFromAnsatz[opbrst_,ansatz_List,opd_,dansatz_List,optriv_,ansatztriv_List,optrivd_,ansatztrivd_List,OptionsPattern[]]:=Module[{canmethod,simplmethod,consts,dconsts,trivconsts,trivdconsts,nontrivconsts,brstansatz,brstdansatz,sollnull,sol,i,cohom,nontrivcohom},
canmethod=OptionValue[CanonicalizeMethod];
simplmethod=OptionValue[SimplifyMethod];
(* define constants for ansatz *)
consts=Map[Symbol["RelativeCohomologyFromAnsatzConst"<>ToString[#]]&,Range[Length@ansatz]];
Block[{$DefInfoQ=False},Quiet[DefConstantSymbol[consts],{ValidateSymbol::used}]];
dconsts=Map[Symbol["RelativeCohomologyFromAnsatzConst"<>ToString[#]]&,Range[1+Length@ansatz,Length@ansatz+Length@dansatz]];
Block[{$DefInfoQ=False},Quiet[DefConstantSymbol[dconsts],{ValidateSymbol::used}]];
trivconsts=Map[Symbol["RelativeCohomologyFromAnsatzConst"<>ToString[#]]&,Range[1+Length@ansatz+Length@dansatz,Length@ansatz+Length@dansatz+Length@ansatztriv]];
Block[{$DefInfoQ=False},Quiet[DefConstantSymbol[trivconsts],{ValidateSymbol::used}]];
trivdconsts=Map[Symbol["RelativeCohomologyFromAnsatzConst"<>ToString[#]]&,Range[1+Length@ansatz+Length@dansatz+Length@ansatztriv,Length@ansatz+Length@dansatz+Length@ansatztriv+Length@ansatztrivd]];
Block[{$DefInfoQ=False},Quiet[DefConstantSymbol[trivdconsts],{ValidateSymbol::used}]];
(* make an ansatz for the cohomology *)
brstansatz=Dot[ansatz,consts];
brstdansatz=Dot[dansatz,dconsts];
(* apply transformation *)
sollnull=canmethod[opbrst[brstansatz]+opd[brstdansatz]];
(* find solution *)
sol=Quiet[First@SolveConstants[sollnull==0,Join[consts,dconsts]],Solve::svars];
brstansatz=brstansatz/.sol;
brstdansatz=brstdansatz/.sol;
(* get elements of cohomology, sorted by simplicity *)
cohom=(Join[Table[{Coefficient[brstansatz,consts[[i]]],Coefficient[brstdansatz,consts[[i]]]},{i,Length[consts]}],Table[{Coefficient[brstansatz,dconsts[[i]]],Coefficient[brstdansatz,dconsts[[i]]]},{i,Length[dconsts]}]]/.{{0,_}:>Sequence[]});
cohom=Sort[cohom,(LeafCount[First@#1]<LeafCount[First@#2])&];
(* make an ansatz for trivial elements and apply transformation *)
brstansatz=canmethod[optriv[Dot[ansatztriv,trivconsts]]+optrivd[Dot[ansatztrivd,trivdconsts]]];
(* filter out trivial elements *)
nontrivcohom={};
For[i=1,i<=Length[cohom],i++,
(* check if cohomology element can be written as a combination of trivial elements and elements which already have been found *)
nontrivconsts=consts[[1;;Length@nontrivcohom]];
sollnull=cohom[[i,1]]+brstansatz+Dot[nontrivcohom[[All,1]],nontrivconsts];
sol=Quiet[SolveConstants[sollnull==0,Join[trivconsts,trivdconsts,nontrivconsts]],Solve::svars];
(* no solution was found, so we have a new non-trivial element *)
If[sol==={},AppendTo[nontrivcohom,simplmethod@cohom[[i]]]];
];
(* clean up*)
Block[{$UndefInfoQ=False},UndefConstantSymbol[consts]];
Block[{$UndefInfoQ=False},UndefConstantSymbol[dconsts]];
Block[{$UndefInfoQ=False},UndefConstantSymbol[trivconsts]];
Block[{$UndefInfoQ=False},UndefConstantSymbol[trivdconsts]];
(* return non-trivial elements *)
nontrivcohom
];
SetNumberOfArguments[RelativeCohomologyFromAnsatz,{8,Infinity}];
Protect[RelativeCohomologyFromAnsatz];


(* ::Input::Initialization:: *)
(****************************** 3. End of Package ******************************)

End[];
EndPackage[];
